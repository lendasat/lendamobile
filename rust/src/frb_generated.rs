// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -511400265;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__ark_api__address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_amount = <Option<u64>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::address(api_amount).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::balance().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__currency_code_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "currency_code",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_currency =
                <crate::models::exchange_rates::FiatCurrency>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::currency_code(api_currency))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__fetch_exchange_rates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_exchange_rates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::fetch_exchange_rates().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bitcoin_api__fetch_historical_prices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_historical_prices",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_url = <String>::sse_decode(&mut deserializer);
            let api_time_range = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bitcoin_api::fetch_historical_prices(
                            api_server_url,
                            api_time_range,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_block_by_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_block_by_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_hash = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::get_block_by_hash(api_hash).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_block_by_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_block_by_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_hash = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::mempool_api::get_block_by_hash(&api_hash).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_block_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_block_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_hash = <String>::sse_decode(&mut deserializer);
            let api_start_index = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::get_block_transactions(api_hash, api_start_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_block_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_block_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_hash = <String>::sse_decode(&mut deserializer);
            let api_start_index = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::mempool_api::get_block_transactions(
                            &api_hash,
                            api_start_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_blocks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_blocks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::get_blocks().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_blocks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_blocks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::mempool_api::get_blocks().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_blocks_at_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_blocks_at_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_height = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::get_blocks_at_height(api_height).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_blocks_at_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_blocks_at_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_height = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::mempool_api::get_blocks_at_height(api_height).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__get_boarding_utxos_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_boarding_utxos",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::get_boarding_utxos().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_fear_greed_index_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_fear_greed_index",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_api_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::mempool_api::get_fear_greed_index(api_api_key).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_hashrate_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_hashrate_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_period = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::get_hashrate_data(api_period).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_hashrate_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_hashrate_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_period = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::mempool_api::get_hashrate_data(&api_period).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__get_mnemonic_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_mnemonic",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::ark_api::get_mnemonic(api_data_dir)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__get_pending_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_pending_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::get_pending_balance().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_recommended_fees_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_recommended_fees",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::get_recommended_fees().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_recommended_fees_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_recommended_fees",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::mempool_api::get_recommended_fees().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_supported_currencies_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_supported_currencies",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::get_supported_currencies())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_txid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::get_transaction(api_txid).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_api__get_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_txid = <String>::sse_decode(&mut deserializer);
            let api_base_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::mempool_api::get_transaction(&api_txid, &api_base_url)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__information_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "information",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::information().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__init_logging_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_logging",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::logger::LogEntry,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::init_logging(api_sink);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_authenticate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_authenticate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_authenticate().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_broadcast_claim_ark_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_broadcast_claim_ark_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            let api_signed_ark_psbt = <String>::sse_decode(&mut deserializer);
            let api_signed_checkpoint_psbts = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_broadcast_claim_ark_tx(
                            api_contract_id,
                            api_signed_ark_psbt,
                            api_signed_checkpoint_psbts,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_broadcast_claim_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_broadcast_claim_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            let api_signed_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_broadcast_claim_tx(
                            api_contract_id,
                            api_signed_tx,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_broadcast_recover_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_broadcast_recover_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            let api_signed_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_broadcast_recover_tx(
                            api_contract_id,
                            api_signed_tx,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_cancel_contract_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_cancel_contract",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendasat_api::lendasat_cancel_contract(api_contract_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_create_contract_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_create_contract",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_offer_id = <String>::sse_decode(&mut deserializer);
            let api_loan_amount = <f64>::sse_decode(&mut deserializer);
            let api_duration_days = <i32>::sse_decode(&mut deserializer);
            let api_borrower_loan_address = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_create_contract(
                            api_offer_id,
                            api_loan_amount,
                            api_duration_days,
                            api_borrower_loan_address,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_finish_settle_ark_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_finish_settle_ark",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            let api_signed_intent_psbt = <String>::sse_decode(&mut deserializer);
            let api_signed_forfeit_psbts = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_finish_settle_ark(
                            api_contract_id,
                            api_signed_intent_psbt,
                            api_signed_forfeit_psbts,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_claim_ark_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_claim_ark_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendasat_api::lendasat_get_claim_ark_psbt(api_contract_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_claim_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_claim_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            let api_fee_rate = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_get_claim_psbt(
                            api_contract_id,
                            api_fee_rate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_contract_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_contract",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendasat_api::lendasat_get_contract(api_contract_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_contracts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_contracts",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filters =
                <Option<crate::lendasat::models::ContractFilters>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendasat_api::lendasat_get_contracts(api_filters).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_derivation_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_derivation_path",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::lendasat_api::lendasat_get_derivation_path(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_offer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_offer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_offer_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendasat_api::lendasat_get_offer(api_offer_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_offers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_offers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filters =
                <Option<crate::lendasat::models::OfferFilters>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendasat_api::lendasat_get_offers(api_filters).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_public_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_public_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_get_public_key().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_recover_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_recover_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            let api_fee_rate = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_get_recover_psbt(
                            api_contract_id,
                            api_fee_rate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_get_settle_ark_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_get_settle_ark_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendasat_api::lendasat_get_settle_ark_psbt(api_contract_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            let api_api_url = <String>::sse_decode(&mut deserializer);
            let api_network = <String>::sse_decode(&mut deserializer);
            let api_api_key = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_init(
                            api_data_dir,
                            api_api_url,
                            api_network,
                            api_api_key,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_is_authenticated_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_is_authenticated",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::lendasat_api::lendasat_is_authenticated().await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_is_initialized_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_is_initialized",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::lendasat_api::lendasat_is_initialized())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_logout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_logout",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_logout().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_mark_installment_paid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_mark_installment_paid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_contract_id = <String>::sse_decode(&mut deserializer);
            let api_installment_id = <String>::sse_decode(&mut deserializer);
            let api_payment_txid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_mark_installment_paid(
                            api_contract_id,
                            api_installment_id,
                            api_payment_txid,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_register_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_register",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_email = <String>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_invite_code = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_register(
                            api_email,
                            api_name,
                            api_invite_code,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__lendasat_sign_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendasat_sign_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_hex = <String>::sse_decode(&mut deserializer);
            let api_collateral_descriptor = <String>::sse_decode(&mut deserializer);
            let api_borrower_pk = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendasat_api::lendasat_sign_psbt(
                            api_psbt_hex,
                            api_collateral_descriptor,
                            api_borrower_pk,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_claim_gelato_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_claim_gelato",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_swap_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_claim_gelato(api_swap_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_claim_vhtlc_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_claim_vhtlc",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_swap_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_claim_vhtlc(api_swap_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_create_btc_to_evm_swap_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_create_btc_to_evm_swap",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_target_evm_address = <String>::sse_decode(&mut deserializer);
            let api_target_amount_usd = <f64>::sse_decode(&mut deserializer);
            let api_target_token = <String>::sse_decode(&mut deserializer);
            let api_target_chain = <String>::sse_decode(&mut deserializer);
            let api_referral_code = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_create_btc_to_evm_swap(
                                api_target_evm_address,
                                api_target_amount_usd,
                                api_target_token,
                                api_target_chain,
                                api_referral_code,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_create_evm_to_btc_swap_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_create_evm_to_btc_swap",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_target_ark_address = <String>::sse_decode(&mut deserializer);
            let api_user_evm_address = <String>::sse_decode(&mut deserializer);
            let api_source_amount_usd = <f64>::sse_decode(&mut deserializer);
            let api_source_token = <String>::sse_decode(&mut deserializer);
            let api_source_chain = <String>::sse_decode(&mut deserializer);
            let api_referral_code = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_create_evm_to_btc_swap(
                                api_target_ark_address,
                                api_user_evm_address,
                                api_source_amount_usd,
                                api_source_token,
                                api_source_chain,
                                api_referral_code,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_create_evm_to_lightning_swap_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_create_evm_to_lightning_swap",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_bolt11_invoice = <String>::sse_decode(&mut deserializer);
            let api_user_evm_address = <String>::sse_decode(&mut deserializer);
            let api_source_token = <String>::sse_decode(&mut deserializer);
            let api_source_chain = <String>::sse_decode(&mut deserializer);
            let api_referral_code = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_create_evm_to_lightning_swap(
                                api_bolt11_invoice,
                                api_user_evm_address,
                                api_source_token,
                                api_source_chain,
                                api_referral_code,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_delete_swap_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_delete_swap",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_swap_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_delete_swap(api_swap_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_get_asset_pairs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_get_asset_pairs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_get_asset_pairs().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_get_quote_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_get_quote",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_from_token = <String>::sse_decode(&mut deserializer);
            let api_to_token = <String>::sse_decode(&mut deserializer);
            let api_amount_sats = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendaswap_api::lendaswap_get_quote(
                            api_from_token,
                            api_to_token,
                            api_amount_sats,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_get_swap_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_get_swap",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_swap_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_get_swap(api_swap_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            let api_network = <String>::sse_decode(&mut deserializer);
            let api_api_url = <String>::sse_decode(&mut deserializer);
            let api_arkade_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendaswap_api::lendaswap_init(
                            api_data_dir,
                            api_network,
                            api_api_url,
                            api_arkade_url,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_is_initialized_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_is_initialized",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::lendaswap_api::lendaswap_is_initialized())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_list_swaps_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_list_swaps",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendaswap_api::lendaswap_list_swaps().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_recover_swaps_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_recover_swaps",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::lendaswap_api::lendaswap_recover_swaps().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendaswap_api__lendaswap_refund_vhtlc_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lendaswap_refund_vhtlc",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_swap_id = <String>::sse_decode(&mut deserializer);
            let api_refund_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::lendaswap_api::lendaswap_refund_vhtlc(
                            api_swap_id,
                            api_refund_address,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__load_existing_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_existing_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            let api_network = <String>::sse_decode(&mut deserializer);
            let api_esplora = <String>::sse_decode(&mut deserializer);
            let api_server = <String>::sse_decode(&mut deserializer);
            let api_boltz_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::load_existing_wallet(
                            api_data_dir,
                            api_network,
                            api_esplora,
                            api_server,
                            api_boltz_url,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__moonpay_encrypt_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "moonpay_encrypt_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_url = <String>::sse_decode(&mut deserializer);
            let api_data = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::moonpay_encrypt_data(api_server_url, api_data).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__moonpay_api__moonpay_encrypt_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "moonpay_encrypt_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_url = <String>::sse_decode(&mut deserializer);
            let api_data = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::moonpay_api::moonpay_encrypt_data(api_server_url, api_data)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__moonpay_get_currency_limits_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "moonpay_get_currency_limits",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_url = <String>::sse_decode(&mut deserializer);
            let api_base_currency_code = <String>::sse_decode(&mut deserializer);
            let api_payment_method = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::moonpay_get_currency_limits(
                            api_server_url,
                            api_base_currency_code,
                            api_payment_method,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__moonpay_api__moonpay_get_currency_limits_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "moonpay_get_currency_limits",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_url = <String>::sse_decode(&mut deserializer);
            let api_base_currency_code = <String>::sse_decode(&mut deserializer);
            let api_payment_method = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::moonpay_api::moonpay_get_currency_limits(
                            api_server_url,
                            api_base_currency_code,
                            api_payment_method,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__moonpay_get_quote_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "moonpay_get_quote",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::moonpay_get_quote(api_server_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__moonpay_api__moonpay_get_quote_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "moonpay_get_quote",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::moonpay_api::moonpay_get_quote(api_server_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__npub_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "npub",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::npub(api_data_dir).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__nsec_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "nsec",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::nsec(api_data_dir).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__pay_ln_invoice_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pay_ln_invoice",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_invoice = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::pay_ln_invoice(api_invoice).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lendasat_api__reset_lendasat_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_lendasat_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::lendasat_api::reset_lendasat_state().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__reset_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::reset_wallet(api_data_dir).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__restore_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "restore_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mnemonic_words = <String>::sse_decode(&mut deserializer);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            let api_network = <String>::sse_decode(&mut deserializer);
            let api_esplora = <String>::sse_decode(&mut deserializer);
            let api_server = <String>::sse_decode(&mut deserializer);
            let api_boltz_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::restore_wallet(
                            api_mnemonic_words,
                            api_data_dir,
                            api_network,
                            api_esplora,
                            api_server,
                            api_boltz_url,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            let api_amount_sats = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::ark_api::send(api_address, api_amount_sats).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__settle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "settle",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::settle().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__setup_new_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "setup_new_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            let api_network = <String>::sse_decode(&mut deserializer);
            let api_esplora = <String>::sse_decode(&mut deserializer);
            let api_server = <String>::sse_decode(&mut deserializer);
            let api_boltz_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::setup_new_wallet(
                            api_data_dir,
                            api_network,
                            api_esplora,
                            api_server,
                            api_boltz_url,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__subscribe_mempool_updates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe_mempool_updates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::models::mempool::MempoolWsMessage,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::subscribe_mempool_updates(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_ws__subscribe_mempool_updates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe_mempool_updates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::models::mempool::MempoolWsMessage,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::mempool_ws::subscribe_mempool_updates(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__track_mempool_block_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "track_mempool_block",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_block_index = <u32>::sse_decode(&mut deserializer);
            let api_sink = <StreamSink<
                crate::models::mempool::ProjectedBlockTransactions,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::track_mempool_block(api_block_index, api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mempool_block_tracker__track_mempool_block_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "track_mempool_block",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_block_index = <u32>::sse_decode(&mut deserializer);
            let api_sink = <StreamSink<
                crate::models::mempool::ProjectedBlockTransactions,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::mempool_block_tracker::track_mempool_block(
                            api_block_index,
                            api_sink,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__tx_history_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tx_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::tx_history().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__wait_for_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wait_for_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_ark_address = <Option<String>>::sse_decode(&mut deserializer);
            let api_boarding_address = <Option<String>>::sse_decode(&mut deserializer);
            let api_boltz_swap_id = <Option<String>>::sse_decode(&mut deserializer);
            let api_timeout_seconds = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::wait_for_payment(
                            api_ark_address,
                            api_boarding_address,
                            api_boltz_swap_id,
                            api_timeout_seconds,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ark_api__wallet_exists_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_exists",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::ark_api::wallet_exists(api_data_dir).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for std::collections::HashMap<String, f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, f64)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for StreamSink<crate::logger::LogEntry, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::models::mempool::MempoolWsMessage,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::models::mempool::ProjectedBlockTransactions,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::ark_api::Addresses {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_boarding = <String>::sse_decode(deserializer);
        let mut var_offchain = <String>::sse_decode(deserializer);
        let mut var_bip21 = <String>::sse_decode(deserializer);
        let mut var_lightning = <Option<crate::api::ark_api::BoltzSwap>>::sse_decode(deserializer);
        return crate::api::ark_api::Addresses {
            boarding: var_boarding,
            offchain: var_offchain,
            bip21: var_bip21,
            lightning: var_lightning,
        };
    }
}

impl SseDecode for crate::lendasat::models::ArkClaimPsbtResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_arkPsbt = <String>::sse_decode(deserializer);
        let mut var_checkpointPsbts = <Vec<String>>::sse_decode(deserializer);
        return crate::lendasat::models::ArkClaimPsbtResponse {
            ark_psbt: var_arkPsbt,
            checkpoint_psbts: var_checkpointPsbts,
        };
    }
}

impl SseDecode for crate::api::lendaswap_api::AssetInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tokenId = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_chain = <String>::sse_decode(deserializer);
        let mut var_decimals = <u8>::sse_decode(deserializer);
        return crate::api::lendaswap_api::AssetInfo {
            token_id: var_tokenId,
            symbol: var_symbol,
            name: var_name,
            chain: var_chain,
            decimals: var_decimals,
        };
    }
}

impl SseDecode for crate::api::lendasat_api::AuthResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_userId = <String>::sse_decode(deserializer);
                let mut var_userName = <String>::sse_decode(deserializer);
                let mut var_userEmail = <Option<String>>::sse_decode(deserializer);
                return crate::api::lendasat_api::AuthResult::Success {
                    user_id: var_userId,
                    user_name: var_userName,
                    user_email: var_userEmail,
                };
            }
            1 => {
                let mut var_pubkey = <String>::sse_decode(deserializer);
                return crate::api::lendasat_api::AuthResult::NeedsRegistration {
                    pubkey: var_pubkey,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::ark_api::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_offchain = <crate::api::ark_api::OffchainBalance>::sse_decode(deserializer);
        return crate::api::ark_api::Balance {
            offchain: var_offchain,
        };
    }
}

impl SseDecode for crate::models::mempool::BitcoinTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_locktime = <u32>::sse_decode(deserializer);
        let mut var_size = <u32>::sse_decode(deserializer);
        let mut var_weight = <u32>::sse_decode(deserializer);
        let mut var_fee = <u64>::sse_decode(deserializer);
        let mut var_sigops = <Option<u32>>::sse_decode(deserializer);
        let mut var_status = <crate::models::mempool::TxStatus>::sse_decode(deserializer);
        let mut var_vin = <Vec<crate::models::mempool::TxInput>>::sse_decode(deserializer);
        let mut var_vout = <Vec<crate::models::mempool::TxOutput>>::sse_decode(deserializer);
        return crate::models::mempool::BitcoinTransaction {
            txid: var_txid,
            version: var_version,
            locktime: var_locktime,
            size: var_size,
            weight: var_weight,
            fee: var_fee,
            sigops: var_sigops,
            status: var_status,
            vin: var_vin,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::models::mempool::Block {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_height = <u64>::sse_decode(deserializer);
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_bits = <u32>::sse_decode(deserializer);
        let mut var_nonce = <u32>::sse_decode(deserializer);
        let mut var_difficulty = <f64>::sse_decode(deserializer);
        let mut var_merkleRoot = <String>::sse_decode(deserializer);
        let mut var_txCount = <u32>::sse_decode(deserializer);
        let mut var_size = <u64>::sse_decode(deserializer);
        let mut var_weight = <u64>::sse_decode(deserializer);
        let mut var_previousblockhash = <Option<String>>::sse_decode(deserializer);
        let mut var_mediantime = <Option<u64>>::sse_decode(deserializer);
        let mut var_stale = <Option<bool>>::sse_decode(deserializer);
        let mut var_extras =
            <Option<crate::models::mempool::BlockExtras>>::sse_decode(deserializer);
        return crate::models::mempool::Block {
            id: var_id,
            height: var_height,
            version: var_version,
            timestamp: var_timestamp,
            bits: var_bits,
            nonce: var_nonce,
            difficulty: var_difficulty,
            merkle_root: var_merkleRoot,
            tx_count: var_txCount,
            size: var_size,
            weight: var_weight,
            previousblockhash: var_previousblockhash,
            mediantime: var_mediantime,
            stale: var_stale,
            extras: var_extras,
        };
    }
}

impl SseDecode for crate::models::mempool::BlockExtras {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_medianFee = <Option<f64>>::sse_decode(deserializer);
        let mut var_totalFees = <Option<u64>>::sse_decode(deserializer);
        let mut var_avgFee = <Option<f64>>::sse_decode(deserializer);
        let mut var_avgFeeRate = <Option<f64>>::sse_decode(deserializer);
        let mut var_reward = <Option<u64>>::sse_decode(deserializer);
        let mut var_pool = <Option<crate::models::mempool::MiningPool>>::sse_decode(deserializer);
        let mut var_matchRate = <Option<f64>>::sse_decode(deserializer);
        let mut var_similarity = <Option<f64>>::sse_decode(deserializer);
        return crate::models::mempool::BlockExtras {
            median_fee: var_medianFee,
            total_fees: var_totalFees,
            avg_fee: var_avgFee,
            avg_fee_rate: var_avgFeeRate,
            reward: var_reward,
            pool: var_pool,
            match_rate: var_matchRate,
            similarity: var_similarity,
        };
    }
}

impl SseDecode for crate::api::ark_api::BoardingUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_isConfirmed = <bool>::sse_decode(deserializer);
        return crate::api::ark_api::BoardingUtxo {
            txid: var_txid,
            amount_sats: var_amountSats,
            is_confirmed: var_isConfirmed,
        };
    }
}

impl SseDecode for crate::api::ark_api::BoltzSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapId = <String>::sse_decode(deserializer);
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        return crate::api::ark_api::BoltzSwap {
            swap_id: var_swapId,
            amount_sats: var_amountSats,
            invoice: var_invoice,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::lendaswap_api::BtcToEvmSwapResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapId = <String>::sse_decode(deserializer);
        let mut var_lnInvoice = <String>::sse_decode(deserializer);
        let mut var_arkadeHtlcAddress = <String>::sse_decode(deserializer);
        let mut var_satsToSend = <i64>::sse_decode(deserializer);
        let mut var_targetAmountUsd = <f64>::sse_decode(deserializer);
        let mut var_feeSats = <i64>::sse_decode(deserializer);
        return crate::api::lendaswap_api::BtcToEvmSwapResult {
            swap_id: var_swapId,
            ln_invoice: var_lnInvoice,
            arkade_htlc_address: var_arkadeHtlcAddress,
            sats_to_send: var_satsToSend,
            target_amount_usd: var_targetAmountUsd,
            fee_sats: var_feeSats,
        };
    }
}

impl SseDecode for crate::lendasat::models::ClaimPsbtResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_psbt = <String>::sse_decode(deserializer);
        let mut var_collateralDescriptor = <String>::sse_decode(deserializer);
        let mut var_borrowerPk = <String>::sse_decode(deserializer);
        return crate::lendasat::models::ClaimPsbtResponse {
            psbt: var_psbt,
            collateral_descriptor: var_collateralDescriptor,
            borrower_pk: var_borrowerPk,
        };
    }
}

impl SseDecode for crate::lendasat::models::CollateralAsset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendasat::models::CollateralAsset::BitcoinBtc,
            1 => crate::lendasat::models::CollateralAsset::ArkadeBtc,
            _ => unreachable!("Invalid variant for CollateralAsset: {}", inner),
        };
    }
}

impl SseDecode for crate::lendasat::models::Contract {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_status = <crate::lendasat::models::ContractStatus>::sse_decode(deserializer);
        let mut var_lender = <crate::lendasat::models::LenderStats>::sse_decode(deserializer);
        let mut var_lenderPk = <String>::sse_decode(deserializer);
        let mut var_borrowerPk = <String>::sse_decode(deserializer);
        let mut var_borrowerBtcAddress = <String>::sse_decode(deserializer);
        let mut var_borrowerDerivationPath = <Option<String>>::sse_decode(deserializer);
        let mut var_borrowerLoanAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_loanAsset = <crate::lendasat::models::LoanAsset>::sse_decode(deserializer);
        let mut var_collateralAsset =
            <crate::lendasat::models::CollateralAsset>::sse_decode(deserializer);
        let mut var_loanAmount = <f64>::sse_decode(deserializer);
        let mut var_interest = <f64>::sse_decode(deserializer);
        let mut var_interestRate = <f64>::sse_decode(deserializer);
        let mut var_durationDays = <i32>::sse_decode(deserializer);
        let mut var_expiry = <String>::sse_decode(deserializer);
        let mut var_collateralSats = <i64>::sse_decode(deserializer);
        let mut var_initialCollateralSats = <i64>::sse_decode(deserializer);
        let mut var_depositedSats = <i64>::sse_decode(deserializer);
        let mut var_initialLtv = <f64>::sse_decode(deserializer);
        let mut var_liquidationPrice = <f64>::sse_decode(deserializer);
        let mut var_ltvThresholdMarginCall1 = <f64>::sse_decode(deserializer);
        let mut var_ltvThresholdMarginCall2 = <f64>::sse_decode(deserializer);
        let mut var_ltvThresholdLiquidation = <f64>::sse_decode(deserializer);
        let mut var_balanceOutstanding = <f64>::sse_decode(deserializer);
        let mut var_contractAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_collateralScript = <Option<String>>::sse_decode(deserializer);
        let mut var_loanRepaymentAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_btcLoanRepaymentAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_originationFeeSats = <i64>::sse_decode(deserializer);
        let mut var_installments =
            <Vec<crate::lendasat::models::Installment>>::sse_decode(deserializer);
        let mut var_transactions =
            <Vec<crate::lendasat::models::LoanTransaction>>::sse_decode(deserializer);
        let mut var_canExtend = <bool>::sse_decode(deserializer);
        let mut var_extensionInterestRate = <Option<f64>>::sse_decode(deserializer);
        let mut var_extensionMaxDurationDays = <i32>::sse_decode(deserializer);
        let mut var_extendsContract = <Option<String>>::sse_decode(deserializer);
        let mut var_extendedByContract = <Option<String>>::sse_decode(deserializer);
        let mut var_clientContractId = <Option<String>>::sse_decode(deserializer);
        let mut var_requiresArkSettlement = <Option<bool>>::sse_decode(deserializer);
        let mut var_createdAt = <String>::sse_decode(deserializer);
        let mut var_updatedAt = <String>::sse_decode(deserializer);
        return crate::lendasat::models::Contract {
            id: var_id,
            status: var_status,
            lender: var_lender,
            lender_pk: var_lenderPk,
            borrower_pk: var_borrowerPk,
            borrower_btc_address: var_borrowerBtcAddress,
            borrower_derivation_path: var_borrowerDerivationPath,
            borrower_loan_address: var_borrowerLoanAddress,
            loan_asset: var_loanAsset,
            collateral_asset: var_collateralAsset,
            loan_amount: var_loanAmount,
            interest: var_interest,
            interest_rate: var_interestRate,
            duration_days: var_durationDays,
            expiry: var_expiry,
            collateral_sats: var_collateralSats,
            initial_collateral_sats: var_initialCollateralSats,
            deposited_sats: var_depositedSats,
            initial_ltv: var_initialLtv,
            liquidation_price: var_liquidationPrice,
            ltv_threshold_margin_call_1: var_ltvThresholdMarginCall1,
            ltv_threshold_margin_call_2: var_ltvThresholdMarginCall2,
            ltv_threshold_liquidation: var_ltvThresholdLiquidation,
            balance_outstanding: var_balanceOutstanding,
            contract_address: var_contractAddress,
            collateral_script: var_collateralScript,
            loan_repayment_address: var_loanRepaymentAddress,
            btc_loan_repayment_address: var_btcLoanRepaymentAddress,
            origination_fee_sats: var_originationFeeSats,
            installments: var_installments,
            transactions: var_transactions,
            can_extend: var_canExtend,
            extension_interest_rate: var_extensionInterestRate,
            extension_max_duration_days: var_extensionMaxDurationDays,
            extends_contract: var_extendsContract,
            extended_by_contract: var_extendedByContract,
            client_contract_id: var_clientContractId,
            requires_ark_settlement: var_requiresArkSettlement,
            created_at: var_createdAt,
            updated_at: var_updatedAt,
        };
    }
}

impl SseDecode for crate::lendasat::models::ContractFilters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_page = <Option<i32>>::sse_decode(deserializer);
        let mut var_limit = <Option<i32>>::sse_decode(deserializer);
        let mut var_status =
            <Option<Vec<crate::lendasat::models::ContractStatus>>>::sse_decode(deserializer);
        let mut var_sortBy = <Option<String>>::sse_decode(deserializer);
        let mut var_sortOrder = <Option<String>>::sse_decode(deserializer);
        return crate::lendasat::models::ContractFilters {
            page: var_page,
            limit: var_limit,
            status: var_status,
            sort_by: var_sortBy,
            sort_order: var_sortOrder,
        };
    }
}

impl SseDecode for crate::lendasat::models::ContractStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendasat::models::ContractStatus::Requested,
            1 => crate::lendasat::models::ContractStatus::Approved,
            2 => crate::lendasat::models::ContractStatus::CollateralSeen,
            3 => crate::lendasat::models::ContractStatus::CollateralConfirmed,
            4 => crate::lendasat::models::ContractStatus::PrincipalGiven,
            5 => crate::lendasat::models::ContractStatus::RepaymentProvided,
            6 => crate::lendasat::models::ContractStatus::RepaymentConfirmed,
            7 => crate::lendasat::models::ContractStatus::Undercollateralized,
            8 => crate::lendasat::models::ContractStatus::Defaulted,
            9 => crate::lendasat::models::ContractStatus::ClosingByClaim,
            10 => crate::lendasat::models::ContractStatus::Closed,
            11 => crate::lendasat::models::ContractStatus::Closing,
            12 => crate::lendasat::models::ContractStatus::ClosingByLiquidation,
            13 => crate::lendasat::models::ContractStatus::ClosedByLiquidation,
            14 => crate::lendasat::models::ContractStatus::ClosingByDefaulting,
            15 => crate::lendasat::models::ContractStatus::ClosedByDefaulting,
            16 => crate::lendasat::models::ContractStatus::Extended,
            17 => crate::lendasat::models::ContractStatus::Rejected,
            18 => crate::lendasat::models::ContractStatus::DisputeBorrowerStarted,
            19 => crate::lendasat::models::ContractStatus::DisputeLenderStarted,
            20 => crate::lendasat::models::ContractStatus::Cancelled,
            21 => crate::lendasat::models::ContractStatus::RequestExpired,
            22 => crate::lendasat::models::ContractStatus::ApprovalExpired,
            23 => crate::lendasat::models::ContractStatus::CollateralRecoverable,
            24 => crate::lendasat::models::ContractStatus::ClosingByRecovery,
            25 => crate::lendasat::models::ContractStatus::ClosedByRecovery,
            _ => unreachable!("Invalid variant for ContractStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::models::mempool::Conversions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_time = <u64>::sse_decode(deserializer);
        let mut var_usd = <f64>::sse_decode(deserializer);
        let mut var_eur = <Option<f64>>::sse_decode(deserializer);
        return crate::models::mempool::Conversions {
            time: var_time,
            usd: var_usd,
            eur: var_eur,
        };
    }
}

impl SseDecode for crate::models::moonpay::CurrencyInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <String>::sse_decode(deserializer);
        let mut var_minBuyAmount = <f64>::sse_decode(deserializer);
        let mut var_maxBuyAmount = <f64>::sse_decode(deserializer);
        return crate::models::moonpay::CurrencyInfo {
            code: var_code,
            min_buy_amount: var_minBuyAmount,
            max_buy_amount: var_maxBuyAmount,
        };
    }
}

impl SseDecode for crate::models::mempool::DifficultyAdjustment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_progressPercent = <f64>::sse_decode(deserializer);
        let mut var_difficultyChange = <f64>::sse_decode(deserializer);
        let mut var_estimatedRetargetDate = <u64>::sse_decode(deserializer);
        let mut var_remainingBlocks = <u32>::sse_decode(deserializer);
        let mut var_remainingTime = <u64>::sse_decode(deserializer);
        let mut var_previousRetarget = <Option<f64>>::sse_decode(deserializer);
        let mut var_previousTime = <Option<u64>>::sse_decode(deserializer);
        let mut var_nextRetargetHeight = <u64>::sse_decode(deserializer);
        let mut var_timeAvg = <u64>::sse_decode(deserializer);
        let mut var_adjustedTimeAvg = <Option<u64>>::sse_decode(deserializer);
        let mut var_timeOffset = <i64>::sse_decode(deserializer);
        let mut var_expectedBlocks = <f64>::sse_decode(deserializer);
        return crate::models::mempool::DifficultyAdjustment {
            progress_percent: var_progressPercent,
            difficulty_change: var_difficultyChange,
            estimated_retarget_date: var_estimatedRetargetDate,
            remaining_blocks: var_remainingBlocks,
            remaining_time: var_remainingTime,
            previous_retarget: var_previousRetarget,
            previous_time: var_previousTime,
            next_retarget_height: var_nextRetargetHeight,
            time_avg: var_timeAvg,
            adjusted_time_avg: var_adjustedTimeAvg,
            time_offset: var_timeOffset,
            expected_blocks: var_expectedBlocks,
        };
    }
}

impl SseDecode for crate::models::mempool::DifficultyPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_difficulty = <Option<f64>>::sse_decode(deserializer);
        let mut var_height = <Option<u64>>::sse_decode(deserializer);
        return crate::models::mempool::DifficultyPoint {
            timestamp: var_timestamp,
            difficulty: var_difficulty,
            height: var_height,
        };
    }
}

impl SseDecode for crate::api::lendaswap_api::EvmToBtcSwapResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapId = <String>::sse_decode(deserializer);
        let mut var_evmHtlcAddress = <String>::sse_decode(deserializer);
        let mut var_sourceAmountUsd = <f64>::sse_decode(deserializer);
        let mut var_satsToReceive = <i64>::sse_decode(deserializer);
        let mut var_feeSats = <i64>::sse_decode(deserializer);
        let mut var_sourceTokenAddress = <String>::sse_decode(deserializer);
        let mut var_createSwapTx = <Option<String>>::sse_decode(deserializer);
        let mut var_approveTx = <Option<String>>::sse_decode(deserializer);
        let mut var_gelatoForwarderAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_gelatoUserNonce = <Option<String>>::sse_decode(deserializer);
        let mut var_gelatoUserDeadline = <Option<String>>::sse_decode(deserializer);
        return crate::api::lendaswap_api::EvmToBtcSwapResult {
            swap_id: var_swapId,
            evm_htlc_address: var_evmHtlcAddress,
            source_amount_usd: var_sourceAmountUsd,
            sats_to_receive: var_satsToReceive,
            fee_sats: var_feeSats,
            source_token_address: var_sourceTokenAddress,
            create_swap_tx: var_createSwapTx,
            approve_tx: var_approveTx,
            gelato_forwarder_address: var_gelatoForwarderAddress,
            gelato_user_nonce: var_gelatoUserNonce,
            gelato_user_deadline: var_gelatoUserDeadline,
        };
    }
}

impl SseDecode for crate::models::exchange_rates::ExchangeRates {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_base = <String>::sse_decode(deserializer);
        let mut var_rates = <std::collections::HashMap<String, f64>>::sse_decode(deserializer);
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        return crate::models::exchange_rates::ExchangeRates {
            base: var_base,
            rates: var_rates,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::mempool::FearGreedData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_now =
            <Option<crate::models::mempool::FearGreedValue>>::sse_decode(deserializer);
        let mut var_previousClose =
            <Option<crate::models::mempool::FearGreedValue>>::sse_decode(deserializer);
        let mut var_oneWeekAgo =
            <Option<crate::models::mempool::FearGreedValue>>::sse_decode(deserializer);
        let mut var_oneMonthAgo =
            <Option<crate::models::mempool::FearGreedValue>>::sse_decode(deserializer);
        let mut var_oneYearAgo =
            <Option<crate::models::mempool::FearGreedValue>>::sse_decode(deserializer);
        return crate::models::mempool::FearGreedData {
            now: var_now,
            previous_close: var_previousClose,
            one_week_ago: var_oneWeekAgo,
            one_month_ago: var_oneMonthAgo,
            one_year_ago: var_oneYearAgo,
        };
    }
}

impl SseDecode for crate::models::mempool::FearGreedIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdated =
            <Option<crate::models::mempool::FearGreedLastUpdated>>::sse_decode(deserializer);
        let mut var_fgi = <Option<crate::models::mempool::FearGreedData>>::sse_decode(deserializer);
        return crate::models::mempool::FearGreedIndex {
            last_updated: var_lastUpdated,
            fgi: var_fgi,
        };
    }
}

impl SseDecode for crate::models::mempool::FearGreedLastUpdated {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_epochUnixSeconds = <Option<i64>>::sse_decode(deserializer);
        let mut var_humanDate = <Option<String>>::sse_decode(deserializer);
        return crate::models::mempool::FearGreedLastUpdated {
            epoch_unix_seconds: var_epochUnixSeconds,
            human_date: var_humanDate,
        };
    }
}

impl SseDecode for crate::models::mempool::FearGreedValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <Option<i32>>::sse_decode(deserializer);
        let mut var_valueText = <Option<String>>::sse_decode(deserializer);
        return crate::models::mempool::FearGreedValue {
            value: var_value,
            value_text: var_valueText,
        };
    }
}

impl SseDecode for crate::models::exchange_rates::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::exchange_rates::FiatCurrency::USD,
            1 => crate::models::exchange_rates::FiatCurrency::EUR,
            2 => crate::models::exchange_rates::FiatCurrency::GBP,
            3 => crate::models::exchange_rates::FiatCurrency::JPY,
            4 => crate::models::exchange_rates::FiatCurrency::CAD,
            5 => crate::models::exchange_rates::FiatCurrency::AUD,
            6 => crate::models::exchange_rates::FiatCurrency::CHF,
            7 => crate::models::exchange_rates::FiatCurrency::CNY,
            8 => crate::models::exchange_rates::FiatCurrency::INR,
            9 => crate::models::exchange_rates::FiatCurrency::BRL,
            10 => crate::models::exchange_rates::FiatCurrency::MXN,
            11 => crate::models::exchange_rates::FiatCurrency::KRW,
            _ => unreachable!("Invalid variant for FiatCurrency: {}", inner),
        };
    }
}

impl SseDecode for crate::models::mempool::HashrateData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_currentHashrate = <Option<f64>>::sse_decode(deserializer);
        let mut var_currentDifficulty = <Option<f64>>::sse_decode(deserializer);
        let mut var_hashrates =
            <Vec<crate::models::mempool::HashratePoint>>::sse_decode(deserializer);
        let mut var_difficulty =
            <Vec<crate::models::mempool::DifficultyPoint>>::sse_decode(deserializer);
        return crate::models::mempool::HashrateData {
            current_hashrate: var_currentHashrate,
            current_difficulty: var_currentDifficulty,
            hashrates: var_hashrates,
            difficulty: var_difficulty,
        };
    }
}

impl SseDecode for crate::models::mempool::HashratePoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_avgHashrate = <f64>::sse_decode(deserializer);
        return crate::models::mempool::HashratePoint {
            timestamp: var_timestamp,
            avg_hashrate: var_avgHashrate,
        };
    }
}

impl SseDecode for crate::models::historical_prices::HistoricalPriceData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <String>::sse_decode(deserializer);
        let mut var_price = <String>::sse_decode(deserializer);
        return crate::models::historical_prices::HistoricalPriceData {
            timestamp: var_timestamp,
            price: var_price,
        };
    }
}

impl SseDecode for crate::models::historical_prices::HistoricalPriceResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_prices =
            <Vec<crate::models::historical_prices::HistoricalPriceData>>::sse_decode(deserializer);
        return crate::models::historical_prices::HistoricalPriceResponse { prices: var_prices };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::ark_api::Info {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_serverPk = <String>::sse_decode(deserializer);
        let mut var_network = <String>::sse_decode(deserializer);
        return crate::api::ark_api::Info {
            server_pk: var_serverPk,
            network: var_network,
        };
    }
}

impl SseDecode for crate::lendasat::models::Installment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_dueDate = <String>::sse_decode(deserializer);
        let mut var_principal = <f64>::sse_decode(deserializer);
        let mut var_interest = <f64>::sse_decode(deserializer);
        let mut var_status = <crate::lendasat::models::InstallmentStatus>::sse_decode(deserializer);
        let mut var_paidDate = <Option<String>>::sse_decode(deserializer);
        let mut var_paymentId = <Option<String>>::sse_decode(deserializer);
        return crate::lendasat::models::Installment {
            id: var_id,
            due_date: var_dueDate,
            principal: var_principal,
            interest: var_interest,
            status: var_status,
            paid_date: var_paidDate,
            payment_id: var_paymentId,
        };
    }
}

impl SseDecode for crate::lendasat::models::InstallmentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendasat::models::InstallmentStatus::Pending,
            1 => crate::lendasat::models::InstallmentStatus::Paid,
            2 => crate::lendasat::models::InstallmentStatus::Confirmed,
            3 => crate::lendasat::models::InstallmentStatus::Late,
            4 => crate::lendasat::models::InstallmentStatus::Cancelled,
            _ => unreachable!("Invalid variant for InstallmentStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::lendasat::models::LenderStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_joinedAt = <String>::sse_decode(deserializer);
        let mut var_successfulContracts = <i32>::sse_decode(deserializer);
        let mut var_vetted = <bool>::sse_decode(deserializer);
        let mut var_timezone = <Option<String>>::sse_decode(deserializer);
        return crate::lendasat::models::LenderStats {
            id: var_id,
            name: var_name,
            joined_at: var_joinedAt,
            successful_contracts: var_successfulContracts,
            vetted: var_vetted,
            timezone: var_timezone,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::BitcoinTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::BitcoinTransaction>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::Block> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::Block>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::ark_api::BoardingUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::ark_api::BoardingUtxo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::lendasat::models::Contract> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::lendasat::models::Contract>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::lendasat::models::ContractStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::lendasat::models::ContractStatus>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::DifficultyPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::DifficultyPoint>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::exchange_rates::FiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::exchange_rates::FiatCurrency>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::HashratePoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::HashratePoint>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::historical_prices::HistoricalPriceData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::historical_prices::HistoricalPriceData>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::lendasat::models::Installment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::lendasat::models::Installment>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::lendasat::models::LoanOffer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::lendasat::models::LoanOffer>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::lendasat::models::LoanTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::lendasat::models::LoanTransaction>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::MempoolBlock> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::MempoolBlock>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::lendasat::models::OriginationFee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::lendasat::models::OriginationFee>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::ProjectedTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::ProjectedTransaction>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, f64)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::lendaswap::SwapInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::lendaswap::SwapInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::lendaswap_api::TradingPair> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::lendaswap_api::TradingPair>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::ark_api::Transaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::ark_api::Transaction>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::TxInput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::TxInput>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::mempool::TxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::mempool::TxOutput>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::ark_api::LnPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapId = <String>::sse_decode(deserializer);
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        return crate::api::ark_api::LnPaymentResult {
            swap_id: var_swapId,
            txid: var_txid,
            amount_sats: var_amountSats,
        };
    }
}

impl SseDecode for crate::lendasat::models::LoanAsset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendasat::models::LoanAsset::UsdcPol,
            1 => crate::lendasat::models::LoanAsset::UsdtPol,
            2 => crate::lendasat::models::LoanAsset::UsdcEth,
            3 => crate::lendasat::models::LoanAsset::UsdtEth,
            4 => crate::lendasat::models::LoanAsset::UsdcStrk,
            5 => crate::lendasat::models::LoanAsset::UsdtStrk,
            6 => crate::lendasat::models::LoanAsset::UsdcSol,
            7 => crate::lendasat::models::LoanAsset::UsdtSol,
            8 => crate::lendasat::models::LoanAsset::UsdtLiquid,
            9 => crate::lendasat::models::LoanAsset::Usd,
            10 => crate::lendasat::models::LoanAsset::Eur,
            11 => crate::lendasat::models::LoanAsset::Chf,
            12 => crate::lendasat::models::LoanAsset::Mxn,
            _ => unreachable!("Invalid variant for LoanAsset: {}", inner),
        };
    }
}

impl SseDecode for crate::lendasat::models::LoanOffer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_lender = <crate::lendasat::models::LenderStats>::sse_decode(deserializer);
        let mut var_lenderPk = <String>::sse_decode(deserializer);
        let mut var_loanAsset = <crate::lendasat::models::LoanAsset>::sse_decode(deserializer);
        let mut var_collateralAsset =
            <crate::lendasat::models::CollateralAsset>::sse_decode(deserializer);
        let mut var_loanAmountMin = <f64>::sse_decode(deserializer);
        let mut var_loanAmountMax = <f64>::sse_decode(deserializer);
        let mut var_durationDaysMin = <i32>::sse_decode(deserializer);
        let mut var_durationDaysMax = <i32>::sse_decode(deserializer);
        let mut var_interestRate = <f64>::sse_decode(deserializer);
        let mut var_minLtv = <f64>::sse_decode(deserializer);
        let mut var_loanPayout = <crate::lendasat::models::LoanPayout>::sse_decode(deserializer);
        let mut var_loanRepaymentAddress = <String>::sse_decode(deserializer);
        let mut var_originationFee =
            <Vec<crate::lendasat::models::OriginationFee>>::sse_decode(deserializer);
        let mut var_repaymentPlan =
            <crate::lendasat::models::RepaymentPlan>::sse_decode(deserializer);
        let mut var_status = <crate::lendasat::models::LoanOfferStatus>::sse_decode(deserializer);
        let mut var_kycLink = <Option<String>>::sse_decode(deserializer);
        return crate::lendasat::models::LoanOffer {
            id: var_id,
            name: var_name,
            lender: var_lender,
            lender_pk: var_lenderPk,
            loan_asset: var_loanAsset,
            collateral_asset: var_collateralAsset,
            loan_amount_min: var_loanAmountMin,
            loan_amount_max: var_loanAmountMax,
            duration_days_min: var_durationDaysMin,
            duration_days_max: var_durationDaysMax,
            interest_rate: var_interestRate,
            min_ltv: var_minLtv,
            loan_payout: var_loanPayout,
            loan_repayment_address: var_loanRepaymentAddress,
            origination_fee: var_originationFee,
            repayment_plan: var_repaymentPlan,
            status: var_status,
            kyc_link: var_kycLink,
        };
    }
}

impl SseDecode for crate::lendasat::models::LoanOfferStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendasat::models::LoanOfferStatus::Available,
            1 => crate::lendasat::models::LoanOfferStatus::Unavailable,
            2 => crate::lendasat::models::LoanOfferStatus::Deleted,
            _ => unreachable!("Invalid variant for LoanOfferStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::lendasat::models::LoanPayout {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendasat::models::LoanPayout::Direct,
            1 => crate::lendasat::models::LoanPayout::Indirect,
            2 => crate::lendasat::models::LoanPayout::MoonCardInstant,
            _ => unreachable!("Invalid variant for LoanPayout: {}", inner),
        };
    }
}

impl SseDecode for crate::lendasat::models::LoanTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_contractId = <String>::sse_decode(deserializer);
        let mut var_transactionType = <String>::sse_decode(deserializer);
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_timestamp = <String>::sse_decode(deserializer);
        return crate::lendasat::models::LoanTransaction {
            id: var_id,
            contract_id: var_contractId,
            transaction_type: var_transactionType,
            txid: var_txid,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_msg = <String>::sse_decode(deserializer);
        let mut var_target = <String>::sse_decode(deserializer);
        let mut var_level = <String>::sse_decode(deserializer);
        let mut var_file = <String>::sse_decode(deserializer);
        let mut var_line = <String>::sse_decode(deserializer);
        let mut var_modulePath = <String>::sse_decode(deserializer);
        let mut var_data = <String>::sse_decode(deserializer);
        return crate::logger::LogEntry {
            msg: var_msg,
            target: var_target,
            level: var_level,
            file: var_file,
            line: var_line,
            module_path: var_modulePath,
            data: var_data,
        };
    }
}

impl SseDecode for crate::models::mempool::MempoolBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockSize = <u64>::sse_decode(deserializer);
        let mut var_blockVsize = <f64>::sse_decode(deserializer);
        let mut var_nTx = <u32>::sse_decode(deserializer);
        let mut var_totalFees = <u64>::sse_decode(deserializer);
        let mut var_medianFee = <f64>::sse_decode(deserializer);
        let mut var_feeRange = <Vec<f64>>::sse_decode(deserializer);
        return crate::models::mempool::MempoolBlock {
            block_size: var_blockSize,
            block_vsize: var_blockVsize,
            n_tx: var_nTx,
            total_fees: var_totalFees,
            median_fee: var_medianFee,
            fee_range: var_feeRange,
        };
    }
}

impl SseDecode for crate::models::mempool::MempoolWsMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mempoolBlocks =
            <Option<Vec<crate::models::mempool::MempoolBlock>>>::sse_decode(deserializer);
        let mut var_blocks = <Option<Vec<crate::models::mempool::Block>>>::sse_decode(deserializer);
        let mut var_conversions =
            <Option<crate::models::mempool::Conversions>>::sse_decode(deserializer);
        let mut var_fees =
            <Option<crate::models::mempool::RecommendedFees>>::sse_decode(deserializer);
        let mut var_da =
            <Option<crate::models::mempool::DifficultyAdjustment>>::sse_decode(deserializer);
        return crate::models::mempool::MempoolWsMessage {
            mempool_blocks: var_mempoolBlocks,
            blocks: var_blocks,
            conversions: var_conversions,
            fees: var_fees,
            da: var_da,
        };
    }
}

impl SseDecode for crate::models::mempool::MiningPool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <Option<u32>>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_slug = <Option<String>>::sse_decode(deserializer);
        return crate::models::mempool::MiningPool {
            id: var_id,
            name: var_name,
            slug: var_slug,
        };
    }
}

impl SseDecode for crate::models::moonpay::MoonPayCurrencyLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_quoteCurrency =
            <crate::models::moonpay::CurrencyInfo>::sse_decode(deserializer);
        let mut var_baseCurrency = <crate::models::moonpay::CurrencyInfo>::sse_decode(deserializer);
        return crate::models::moonpay::MoonPayCurrencyLimits {
            quote_currency: var_quoteCurrency,
            base_currency: var_baseCurrency,
        };
    }
}

impl SseDecode for crate::models::moonpay::MoonPayEncryptedData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ciphertext = <String>::sse_decode(deserializer);
        let mut var_iv = <String>::sse_decode(deserializer);
        return crate::models::moonpay::MoonPayEncryptedData {
            ciphertext: var_ciphertext,
            iv: var_iv,
        };
    }
}

impl SseDecode for crate::models::moonpay::MoonPayQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseCurrencyAmount = <f64>::sse_decode(deserializer);
        let mut var_quoteCurrencyAmount = <f64>::sse_decode(deserializer);
        let mut var_baseCurrencyCode = <String>::sse_decode(deserializer);
        let mut var_exchangeRate = <f64>::sse_decode(deserializer);
        let mut var_timestamp = <String>::sse_decode(deserializer);
        return crate::models::moonpay::MoonPayQuote {
            base_currency_amount: var_baseCurrencyAmount,
            quote_currency_amount: var_quoteCurrencyAmount,
            base_currency_code: var_baseCurrencyCode,
            exchange_rate: var_exchangeRate,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::api::ark_api::OffchainBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pendingSats = <u64>::sse_decode(deserializer);
        let mut var_confirmedSats = <u64>::sse_decode(deserializer);
        let mut var_totalSats = <u64>::sse_decode(deserializer);
        return crate::api::ark_api::OffchainBalance {
            pending_sats: var_pendingSats,
            confirmed_sats: var_confirmedSats,
            total_sats: var_totalSats,
        };
    }
}

impl SseDecode for crate::lendasat::models::OfferFilters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_loanType = <Option<String>>::sse_decode(deserializer);
        let mut var_assetType = <Option<String>>::sse_decode(deserializer);
        let mut var_loanAssets = <Option<String>>::sse_decode(deserializer);
        let mut var_kyc = <Option<String>>::sse_decode(deserializer);
        let mut var_minLoanAmount = <Option<f64>>::sse_decode(deserializer);
        let mut var_maxLoanAmount = <Option<f64>>::sse_decode(deserializer);
        let mut var_maxInterestRate = <Option<f64>>::sse_decode(deserializer);
        let mut var_durationMin = <Option<i32>>::sse_decode(deserializer);
        let mut var_durationMax = <Option<i32>>::sse_decode(deserializer);
        let mut var_collateralAssetType = <Option<String>>::sse_decode(deserializer);
        return crate::lendasat::models::OfferFilters {
            loan_type: var_loanType,
            asset_type: var_assetType,
            loan_assets: var_loanAssets,
            kyc: var_kyc,
            min_loan_amount: var_minLoanAmount,
            max_loan_amount: var_maxLoanAmount,
            max_interest_rate: var_maxInterestRate,
            duration_min: var_durationMin,
            duration_max: var_durationMax,
            collateral_asset_type: var_collateralAssetType,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::BlockExtras> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::BlockExtras>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::ark_api::BoltzSwap> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::ark_api::BoltzSwap>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::lendasat::models::ContractFilters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::lendasat::models::ContractFilters>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::Conversions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::Conversions>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::DifficultyAdjustment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::DifficultyAdjustment>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::FearGreedData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::FearGreedData>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::FearGreedLastUpdated> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::FearGreedLastUpdated>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::FearGreedValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::FearGreedValue>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::MiningPool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::MiningPool>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::lendasat::models::OfferFilters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::lendasat::models::OfferFilters>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::RecommendedFees> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::RecommendedFees>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::mempool::TxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::mempool::TxOutput>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::mempool::Block>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::mempool::Block>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::lendasat::models::ContractStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::lendasat::models::ContractStatus>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::mempool::MempoolBlock>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::mempool::MempoolBlock>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::lendasat::models::OriginationFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fee = <f64>::sse_decode(deserializer);
        let mut var_fromDay = <i32>::sse_decode(deserializer);
        return crate::lendasat::models::OriginationFee {
            fee: var_fee,
            from_day: var_fromDay,
        };
    }
}

impl SseDecode for crate::lendasat::models::PaginatedContractsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<crate::lendasat::models::Contract>>::sse_decode(deserializer);
        let mut var_page = <i32>::sse_decode(deserializer);
        let mut var_limit = <i32>::sse_decode(deserializer);
        let mut var_total = <i32>::sse_decode(deserializer);
        let mut var_totalPages = <i32>::sse_decode(deserializer);
        return crate::lendasat::models::PaginatedContractsResponse {
            data: var_data,
            page: var_page,
            limit: var_limit,
            total: var_total,
            total_pages: var_totalPages,
        };
    }
}

impl SseDecode for crate::api::ark_api::PaymentReceived {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_amountSats = <u64>::sse_decode(deserializer);
        return crate::api::ark_api::PaymentReceived {
            txid: var_txid,
            amount_sats: var_amountSats,
        };
    }
}

impl SseDecode for crate::models::mempool::ProjectedBlockTransactions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_index = <u32>::sse_decode(deserializer);
        let mut var_transactions =
            <Vec<crate::models::mempool::ProjectedTransaction>>::sse_decode(deserializer);
        return crate::models::mempool::ProjectedBlockTransactions {
            index: var_index,
            transactions: var_transactions,
        };
    }
}

impl SseDecode for crate::models::mempool::ProjectedTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_vsize = <u32>::sse_decode(deserializer);
        let mut var_feeRate = <f64>::sse_decode(deserializer);
        let mut var_flags = <u32>::sse_decode(deserializer);
        return crate::models::mempool::ProjectedTransaction {
            txid: var_txid,
            value: var_value,
            vsize: var_vsize,
            fee_rate: var_feeRate,
            flags: var_flags,
        };
    }
}

impl SseDecode for crate::models::mempool::RecommendedFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fastestFee = <f64>::sse_decode(deserializer);
        let mut var_halfHourFee = <f64>::sse_decode(deserializer);
        let mut var_hourFee = <f64>::sse_decode(deserializer);
        let mut var_economyFee = <f64>::sse_decode(deserializer);
        let mut var_minimumFee = <f64>::sse_decode(deserializer);
        return crate::models::mempool::RecommendedFees {
            fastest_fee: var_fastestFee,
            half_hour_fee: var_halfHourFee,
            hour_fee: var_hourFee,
            economy_fee: var_economyFee,
            minimum_fee: var_minimumFee,
        };
    }
}

impl SseDecode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <f64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::lendasat::models::RepaymentPlan {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendasat::models::RepaymentPlan::Bullet,
            1 => crate::lendasat::models::RepaymentPlan::InterestOnlyWeekly,
            2 => crate::lendasat::models::RepaymentPlan::InterestOnlyMonthly,
            _ => unreachable!("Invalid variant for RepaymentPlan: {}", inner),
        };
    }
}

impl SseDecode for crate::lendasat::models::SettleArkPsbtResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_intentMessage = <String>::sse_decode(deserializer);
        let mut var_intentProof = <String>::sse_decode(deserializer);
        let mut var_forfeitPsbts = <Vec<String>>::sse_decode(deserializer);
        let mut var_delegateCosignerPk = <String>::sse_decode(deserializer);
        let mut var_userPk = <String>::sse_decode(deserializer);
        let mut var_derivationPath = <Option<String>>::sse_decode(deserializer);
        return crate::lendasat::models::SettleArkPsbtResponse {
            intent_message: var_intentMessage,
            intent_proof: var_intentProof,
            forfeit_psbts: var_forfeitPsbts,
            delegate_cosigner_pk: var_delegateCosignerPk,
            user_pk: var_userPk,
            derivation_path: var_derivationPath,
        };
    }
}

impl SseDecode for crate::lendaswap::SwapInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_status = <crate::lendaswap::SwapStatusSimple>::sse_decode(deserializer);
        let mut var_direction = <String>::sse_decode(deserializer);
        let mut var_sourceToken = <String>::sse_decode(deserializer);
        let mut var_targetToken = <String>::sse_decode(deserializer);
        let mut var_sourceAmountSats = <i64>::sse_decode(deserializer);
        let mut var_targetAmountUsd = <f64>::sse_decode(deserializer);
        let mut var_createdAt = <String>::sse_decode(deserializer);
        let mut var_lnInvoice = <Option<String>>::sse_decode(deserializer);
        let mut var_arkadeHtlcAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_evmHtlcAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_feeSats = <i64>::sse_decode(deserializer);
        let mut var_canClaimGelato = <bool>::sse_decode(deserializer);
        let mut var_canClaimVhtlc = <bool>::sse_decode(deserializer);
        let mut var_canRefund = <bool>::sse_decode(deserializer);
        let mut var_detailedStatus = <String>::sse_decode(deserializer);
        return crate::lendaswap::SwapInfo {
            id: var_id,
            status: var_status,
            direction: var_direction,
            source_token: var_sourceToken,
            target_token: var_targetToken,
            source_amount_sats: var_sourceAmountSats,
            target_amount_usd: var_targetAmountUsd,
            created_at: var_createdAt,
            ln_invoice: var_lnInvoice,
            arkade_htlc_address: var_arkadeHtlcAddress,
            evm_htlc_address: var_evmHtlcAddress,
            fee_sats: var_feeSats,
            can_claim_gelato: var_canClaimGelato,
            can_claim_vhtlc: var_canClaimVhtlc,
            can_refund: var_canRefund,
            detailed_status: var_detailedStatus,
        };
    }
}

impl SseDecode for crate::api::lendaswap_api::SwapQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_exchangeRate = <String>::sse_decode(deserializer);
        let mut var_networkFeeSats = <u64>::sse_decode(deserializer);
        let mut var_protocolFeeSats = <u64>::sse_decode(deserializer);
        let mut var_protocolFeePercent = <f64>::sse_decode(deserializer);
        let mut var_minAmountSats = <u64>::sse_decode(deserializer);
        let mut var_maxAmountSats = <u64>::sse_decode(deserializer);
        return crate::api::lendaswap_api::SwapQuote {
            exchange_rate: var_exchangeRate,
            network_fee_sats: var_networkFeeSats,
            protocol_fee_sats: var_protocolFeeSats,
            protocol_fee_percent: var_protocolFeePercent,
            min_amount_sats: var_minAmountSats,
            max_amount_sats: var_maxAmountSats,
        };
    }
}

impl SseDecode for crate::lendaswap::SwapStatusSimple {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::lendaswap::SwapStatusSimple::WaitingForDeposit,
            1 => crate::lendaswap::SwapStatusSimple::Processing,
            2 => crate::lendaswap::SwapStatusSimple::Completed,
            3 => crate::lendaswap::SwapStatusSimple::Expired,
            4 => crate::lendaswap::SwapStatusSimple::Refundable,
            5 => crate::lendaswap::SwapStatusSimple::Refunded,
            6 => crate::lendaswap::SwapStatusSimple::Failed,
            _ => unreachable!("Invalid variant for SwapStatusSimple: {}", inner),
        };
    }
}

impl SseDecode for crate::api::lendaswap_api::TradingPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_source = <crate::api::lendaswap_api::AssetInfo>::sse_decode(deserializer);
        let mut var_target = <crate::api::lendaswap_api::AssetInfo>::sse_decode(deserializer);
        return crate::api::lendaswap_api::TradingPair {
            source: var_source,
            target: var_target,
        };
    }
}

impl SseDecode for crate::api::ark_api::Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_txid = <String>::sse_decode(deserializer);
                let mut var_amountSats = <u64>::sse_decode(deserializer);
                let mut var_confirmedAt = <Option<i64>>::sse_decode(deserializer);
                return crate::api::ark_api::Transaction::Boarding {
                    txid: var_txid,
                    amount_sats: var_amountSats,
                    confirmed_at: var_confirmedAt,
                };
            }
            1 => {
                let mut var_txid = <String>::sse_decode(deserializer);
                let mut var_amountSats = <i64>::sse_decode(deserializer);
                let mut var_createdAt = <i64>::sse_decode(deserializer);
                return crate::api::ark_api::Transaction::Round {
                    txid: var_txid,
                    amount_sats: var_amountSats,
                    created_at: var_createdAt,
                };
            }
            2 => {
                let mut var_txid = <String>::sse_decode(deserializer);
                let mut var_amountSats = <i64>::sse_decode(deserializer);
                let mut var_isSettled = <bool>::sse_decode(deserializer);
                let mut var_createdAt = <i64>::sse_decode(deserializer);
                return crate::api::ark_api::Transaction::Redeem {
                    txid: var_txid,
                    amount_sats: var_amountSats,
                    is_settled: var_isSettled,
                    created_at: var_createdAt,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::mempool::TxInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        let mut var_prevout = <Option<crate::models::mempool::TxOutput>>::sse_decode(deserializer);
        let mut var_scriptsig = <String>::sse_decode(deserializer);
        let mut var_scriptsigAsm = <String>::sse_decode(deserializer);
        let mut var_witness = <Option<Vec<String>>>::sse_decode(deserializer);
        let mut var_isCoinbase = <bool>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        return crate::models::mempool::TxInput {
            txid: var_txid,
            vout: var_vout,
            prevout: var_prevout,
            scriptsig: var_scriptsig,
            scriptsig_asm: var_scriptsigAsm,
            witness: var_witness,
            is_coinbase: var_isCoinbase,
            sequence: var_sequence,
        };
    }
}

impl SseDecode for crate::models::mempool::TxOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_scriptpubkey = <String>::sse_decode(deserializer);
        let mut var_scriptpubkeyAsm = <String>::sse_decode(deserializer);
        let mut var_scriptpubkeyType = <String>::sse_decode(deserializer);
        let mut var_scriptpubkeyAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_value = <u64>::sse_decode(deserializer);
        return crate::models::mempool::TxOutput {
            scriptpubkey: var_scriptpubkey,
            scriptpubkey_asm: var_scriptpubkeyAsm,
            scriptpubkey_type: var_scriptpubkeyType,
            scriptpubkey_address: var_scriptpubkeyAddress,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::mempool::TxStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_confirmed = <bool>::sse_decode(deserializer);
        let mut var_blockHeight = <Option<u64>>::sse_decode(deserializer);
        let mut var_blockHash = <Option<String>>::sse_decode(deserializer);
        let mut var_blockTime = <Option<u64>>::sse_decode(deserializer);
        return crate::models::mempool::TxStatus {
            confirmed: var_confirmed,
            block_height: var_blockHeight,
            block_hash: var_blockHash,
            block_time: var_blockTime,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__ark_api__address_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__ark_api__balance_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__fetch_exchange_rates_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__bitcoin_api__fetch_historical_prices_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire__crate__api__get_block_by_hash_impl(port, ptr, rust_vec_len, data_len),
        7 => {
            wire__crate__api__mempool_api__get_block_by_hash_impl(port, ptr, rust_vec_len, data_len)
        }
        8 => wire__crate__api__get_block_transactions_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__mempool_api__get_block_transactions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => wire__crate__api__get_blocks_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__mempool_api__get_blocks_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__get_blocks_at_height_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__mempool_api__get_blocks_at_height_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__api__ark_api__get_boarding_utxos_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__api__mempool_api__get_fear_greed_index_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        16 => wire__crate__api__get_hashrate_data_impl(port, ptr, rust_vec_len, data_len),
        17 => {
            wire__crate__api__mempool_api__get_hashrate_data_impl(port, ptr, rust_vec_len, data_len)
        }
        18 => wire__crate__api__ark_api__get_mnemonic_impl(port, ptr, rust_vec_len, data_len),
        19 => {
            wire__crate__api__ark_api__get_pending_balance_impl(port, ptr, rust_vec_len, data_len)
        }
        20 => wire__crate__api__get_recommended_fees_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__mempool_api__get_recommended_fees_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        23 => wire__crate__api__get_transaction_impl(port, ptr, rust_vec_len, data_len),
        24 => {
            wire__crate__api__mempool_api__get_transaction_impl(port, ptr, rust_vec_len, data_len)
        }
        25 => wire__crate__api__ark_api__information_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__init_app_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__init_logging_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__lendasat_api__lendasat_authenticate_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        29 => wire__crate__api__lendasat_api__lendasat_broadcast_claim_ark_tx_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        30 => wire__crate__api__lendasat_api__lendasat_broadcast_claim_tx_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        31 => wire__crate__api__lendasat_api__lendasat_broadcast_recover_tx_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        32 => wire__crate__api__lendasat_api__lendasat_cancel_contract_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        33 => wire__crate__api__lendasat_api__lendasat_create_contract_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        34 => wire__crate__api__lendasat_api__lendasat_finish_settle_ark_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        35 => wire__crate__api__lendasat_api__lendasat_get_claim_ark_psbt_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        36 => wire__crate__api__lendasat_api__lendasat_get_claim_psbt_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        37 => wire__crate__api__lendasat_api__lendasat_get_contract_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        38 => wire__crate__api__lendasat_api__lendasat_get_contracts_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        39 => wire__crate__api__lendasat_api__lendasat_get_derivation_path_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        40 => wire__crate__api__lendasat_api__lendasat_get_offer_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        41 => wire__crate__api__lendasat_api__lendasat_get_offers_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        42 => wire__crate__api__lendasat_api__lendasat_get_public_key_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        43 => wire__crate__api__lendasat_api__lendasat_get_recover_psbt_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        44 => wire__crate__api__lendasat_api__lendasat_get_settle_ark_psbt_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        45 => wire__crate__api__lendasat_api__lendasat_init_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__lendasat_api__lendasat_is_authenticated_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        47 => wire__crate__api__lendasat_api__lendasat_is_initialized_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        48 => {
            wire__crate__api__lendasat_api__lendasat_logout_impl(port, ptr, rust_vec_len, data_len)
        }
        49 => wire__crate__api__lendasat_api__lendasat_mark_installment_paid_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        50 => wire__crate__api__lendasat_api__lendasat_register_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        51 => wire__crate__api__lendasat_api__lendasat_sign_psbt_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        52 => wire__crate__api__lendaswap_api__lendaswap_claim_gelato_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        53 => wire__crate__api__lendaswap_api__lendaswap_claim_vhtlc_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        54 => wire__crate__api__lendaswap_api__lendaswap_create_btc_to_evm_swap_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        55 => wire__crate__api__lendaswap_api__lendaswap_create_evm_to_btc_swap_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        56 => wire__crate__api__lendaswap_api__lendaswap_create_evm_to_lightning_swap_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        57 => wire__crate__api__lendaswap_api__lendaswap_delete_swap_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        58 => wire__crate__api__lendaswap_api__lendaswap_get_asset_pairs_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        59 => wire__crate__api__lendaswap_api__lendaswap_get_quote_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        60 => wire__crate__api__lendaswap_api__lendaswap_get_swap_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        61 => {
            wire__crate__api__lendaswap_api__lendaswap_init_impl(port, ptr, rust_vec_len, data_len)
        }
        63 => wire__crate__api__lendaswap_api__lendaswap_list_swaps_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        64 => wire__crate__api__lendaswap_api__lendaswap_recover_swaps_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        65 => wire__crate__api__lendaswap_api__lendaswap_refund_vhtlc_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        66 => {
            wire__crate__api__ark_api__load_existing_wallet_impl(port, ptr, rust_vec_len, data_len)
        }
        67 => wire__crate__api__moonpay_encrypt_data_impl(port, ptr, rust_vec_len, data_len),
        68 => wire__crate__api__moonpay_api__moonpay_encrypt_data_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        69 => wire__crate__api__moonpay_get_currency_limits_impl(port, ptr, rust_vec_len, data_len),
        70 => wire__crate__api__moonpay_api__moonpay_get_currency_limits_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        71 => wire__crate__api__moonpay_get_quote_impl(port, ptr, rust_vec_len, data_len),
        72 => {
            wire__crate__api__moonpay_api__moonpay_get_quote_impl(port, ptr, rust_vec_len, data_len)
        }
        73 => wire__crate__api__ark_api__npub_impl(port, ptr, rust_vec_len, data_len),
        74 => wire__crate__api__ark_api__nsec_impl(port, ptr, rust_vec_len, data_len),
        75 => wire__crate__api__ark_api__pay_ln_invoice_impl(port, ptr, rust_vec_len, data_len),
        76 => wire__crate__api__lendasat_api__reset_lendasat_state_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        77 => wire__crate__api__ark_api__reset_wallet_impl(port, ptr, rust_vec_len, data_len),
        78 => wire__crate__api__ark_api__restore_wallet_impl(port, ptr, rust_vec_len, data_len),
        79 => wire__crate__api__ark_api__send_impl(port, ptr, rust_vec_len, data_len),
        80 => wire__crate__api__ark_api__settle_impl(port, ptr, rust_vec_len, data_len),
        81 => wire__crate__api__ark_api__setup_new_wallet_impl(port, ptr, rust_vec_len, data_len),
        82 => wire__crate__api__subscribe_mempool_updates_impl(port, ptr, rust_vec_len, data_len),
        83 => wire__crate__api__mempool_ws__subscribe_mempool_updates_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        84 => wire__crate__api__track_mempool_block_impl(port, ptr, rust_vec_len, data_len),
        85 => wire__crate__api__mempool_block_tracker__track_mempool_block_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        86 => wire__crate__api__ark_api__tx_history_impl(port, ptr, rust_vec_len, data_len),
        87 => wire__crate__api__ark_api__wait_for_payment_impl(port, ptr, rust_vec_len, data_len),
        88 => wire__crate__api__ark_api__wallet_exists_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        3 => wire__crate__api__currency_code_impl(ptr, rust_vec_len, data_len),
        22 => wire__crate__api__get_supported_currencies_impl(ptr, rust_vec_len, data_len),
        62 => wire__crate__api__lendaswap_api__lendaswap_is_initialized_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::Addresses {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.boarding.into_into_dart().into_dart(),
            self.offchain.into_into_dart().into_dart(),
            self.bip21.into_into_dart().into_dart(),
            self.lightning.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ark_api::Addresses
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::Addresses>
    for crate::api::ark_api::Addresses
{
    fn into_into_dart(self) -> crate::api::ark_api::Addresses {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::ArkClaimPsbtResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ark_psbt.into_into_dart().into_dart(),
            self.checkpoint_psbts.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::ArkClaimPsbtResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::ArkClaimPsbtResponse>
    for crate::lendasat::models::ArkClaimPsbtResponse
{
    fn into_into_dart(self) -> crate::lendasat::models::ArkClaimPsbtResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lendaswap_api::AssetInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.token_id.into_into_dart().into_dart(),
            self.symbol.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.chain.into_into_dart().into_dart(),
            self.decimals.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lendaswap_api::AssetInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lendaswap_api::AssetInfo>
    for crate::api::lendaswap_api::AssetInfo
{
    fn into_into_dart(self) -> crate::api::lendaswap_api::AssetInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lendasat_api::AuthResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::lendasat_api::AuthResult::Success {
                user_id,
                user_name,
                user_email,
            } => [
                0.into_dart(),
                user_id.into_into_dart().into_dart(),
                user_name.into_into_dart().into_dart(),
                user_email.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::lendasat_api::AuthResult::NeedsRegistration { pubkey } => {
                [1.into_dart(), pubkey.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lendasat_api::AuthResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lendasat_api::AuthResult>
    for crate::api::lendasat_api::AuthResult
{
    fn into_into_dart(self) -> crate::api::lendasat_api::AuthResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::Balance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.offchain.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::ark_api::Balance {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::Balance>
    for crate::api::ark_api::Balance
{
    fn into_into_dart(self) -> crate::api::ark_api::Balance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::BitcoinTransaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
            self.locktime.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.weight.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.sigops.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.vin.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::BitcoinTransaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::BitcoinTransaction>
    for crate::models::mempool::BitcoinTransaction
{
    fn into_into_dart(self) -> crate::models::mempool::BitcoinTransaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::Block {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.bits.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
            self.difficulty.into_into_dart().into_dart(),
            self.merkle_root.into_into_dart().into_dart(),
            self.tx_count.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.weight.into_into_dart().into_dart(),
            self.previousblockhash.into_into_dart().into_dart(),
            self.mediantime.into_into_dart().into_dart(),
            self.stale.into_into_dart().into_dart(),
            self.extras.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::mempool::Block {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::Block>
    for crate::models::mempool::Block
{
    fn into_into_dart(self) -> crate::models::mempool::Block {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::BlockExtras {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.median_fee.into_into_dart().into_dart(),
            self.total_fees.into_into_dart().into_dart(),
            self.avg_fee.into_into_dart().into_dart(),
            self.avg_fee_rate.into_into_dart().into_dart(),
            self.reward.into_into_dart().into_dart(),
            self.pool.into_into_dart().into_dart(),
            self.match_rate.into_into_dart().into_dart(),
            self.similarity.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::BlockExtras
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::BlockExtras>
    for crate::models::mempool::BlockExtras
{
    fn into_into_dart(self) -> crate::models::mempool::BlockExtras {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::BoardingUtxo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.amount_sats.into_into_dart().into_dart(),
            self.is_confirmed.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ark_api::BoardingUtxo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::BoardingUtxo>
    for crate::api::ark_api::BoardingUtxo
{
    fn into_into_dart(self) -> crate::api::ark_api::BoardingUtxo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::BoltzSwap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_id.into_into_dart().into_dart(),
            self.amount_sats.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ark_api::BoltzSwap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::BoltzSwap>
    for crate::api::ark_api::BoltzSwap
{
    fn into_into_dart(self) -> crate::api::ark_api::BoltzSwap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lendaswap_api::BtcToEvmSwapResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_id.into_into_dart().into_dart(),
            self.ln_invoice.into_into_dart().into_dart(),
            self.arkade_htlc_address.into_into_dart().into_dart(),
            self.sats_to_send.into_into_dart().into_dart(),
            self.target_amount_usd.into_into_dart().into_dart(),
            self.fee_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lendaswap_api::BtcToEvmSwapResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lendaswap_api::BtcToEvmSwapResult>
    for crate::api::lendaswap_api::BtcToEvmSwapResult
{
    fn into_into_dart(self) -> crate::api::lendaswap_api::BtcToEvmSwapResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::ClaimPsbtResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.psbt.into_into_dart().into_dart(),
            self.collateral_descriptor.into_into_dart().into_dart(),
            self.borrower_pk.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::ClaimPsbtResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::ClaimPsbtResponse>
    for crate::lendasat::models::ClaimPsbtResponse
{
    fn into_into_dart(self) -> crate::lendasat::models::ClaimPsbtResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::CollateralAsset {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::BitcoinBtc => 0.into_dart(),
            Self::ArkadeBtc => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::CollateralAsset
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::CollateralAsset>
    for crate::lendasat::models::CollateralAsset
{
    fn into_into_dart(self) -> crate::lendasat::models::CollateralAsset {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::Contract {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.lender.into_into_dart().into_dart(),
            self.lender_pk.into_into_dart().into_dart(),
            self.borrower_pk.into_into_dart().into_dart(),
            self.borrower_btc_address.into_into_dart().into_dart(),
            self.borrower_derivation_path.into_into_dart().into_dart(),
            self.borrower_loan_address.into_into_dart().into_dart(),
            self.loan_asset.into_into_dart().into_dart(),
            self.collateral_asset.into_into_dart().into_dart(),
            self.loan_amount.into_into_dart().into_dart(),
            self.interest.into_into_dart().into_dart(),
            self.interest_rate.into_into_dart().into_dart(),
            self.duration_days.into_into_dart().into_dart(),
            self.expiry.into_into_dart().into_dart(),
            self.collateral_sats.into_into_dart().into_dart(),
            self.initial_collateral_sats.into_into_dart().into_dart(),
            self.deposited_sats.into_into_dart().into_dart(),
            self.initial_ltv.into_into_dart().into_dart(),
            self.liquidation_price.into_into_dart().into_dart(),
            self.ltv_threshold_margin_call_1
                .into_into_dart()
                .into_dart(),
            self.ltv_threshold_margin_call_2
                .into_into_dart()
                .into_dart(),
            self.ltv_threshold_liquidation.into_into_dart().into_dart(),
            self.balance_outstanding.into_into_dart().into_dart(),
            self.contract_address.into_into_dart().into_dart(),
            self.collateral_script.into_into_dart().into_dart(),
            self.loan_repayment_address.into_into_dart().into_dart(),
            self.btc_loan_repayment_address.into_into_dart().into_dart(),
            self.origination_fee_sats.into_into_dart().into_dart(),
            self.installments.into_into_dart().into_dart(),
            self.transactions.into_into_dart().into_dart(),
            self.can_extend.into_into_dart().into_dart(),
            self.extension_interest_rate.into_into_dart().into_dart(),
            self.extension_max_duration_days
                .into_into_dart()
                .into_dart(),
            self.extends_contract.into_into_dart().into_dart(),
            self.extended_by_contract.into_into_dart().into_dart(),
            self.client_contract_id.into_into_dart().into_dart(),
            self.requires_ark_settlement.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.updated_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::Contract
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::Contract>
    for crate::lendasat::models::Contract
{
    fn into_into_dart(self) -> crate::lendasat::models::Contract {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::ContractFilters {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.page.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.sort_by.into_into_dart().into_dart(),
            self.sort_order.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::ContractFilters
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::ContractFilters>
    for crate::lendasat::models::ContractFilters
{
    fn into_into_dart(self) -> crate::lendasat::models::ContractFilters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::ContractStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Requested => 0.into_dart(),
            Self::Approved => 1.into_dart(),
            Self::CollateralSeen => 2.into_dart(),
            Self::CollateralConfirmed => 3.into_dart(),
            Self::PrincipalGiven => 4.into_dart(),
            Self::RepaymentProvided => 5.into_dart(),
            Self::RepaymentConfirmed => 6.into_dart(),
            Self::Undercollateralized => 7.into_dart(),
            Self::Defaulted => 8.into_dart(),
            Self::ClosingByClaim => 9.into_dart(),
            Self::Closed => 10.into_dart(),
            Self::Closing => 11.into_dart(),
            Self::ClosingByLiquidation => 12.into_dart(),
            Self::ClosedByLiquidation => 13.into_dart(),
            Self::ClosingByDefaulting => 14.into_dart(),
            Self::ClosedByDefaulting => 15.into_dart(),
            Self::Extended => 16.into_dart(),
            Self::Rejected => 17.into_dart(),
            Self::DisputeBorrowerStarted => 18.into_dart(),
            Self::DisputeLenderStarted => 19.into_dart(),
            Self::Cancelled => 20.into_dart(),
            Self::RequestExpired => 21.into_dart(),
            Self::ApprovalExpired => 22.into_dart(),
            Self::CollateralRecoverable => 23.into_dart(),
            Self::ClosingByRecovery => 24.into_dart(),
            Self::ClosedByRecovery => 25.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::ContractStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::ContractStatus>
    for crate::lendasat::models::ContractStatus
{
    fn into_into_dart(self) -> crate::lendasat::models::ContractStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::Conversions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.time.into_into_dart().into_dart(),
            self.usd.into_into_dart().into_dart(),
            self.eur.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::Conversions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::Conversions>
    for crate::models::mempool::Conversions
{
    fn into_into_dart(self) -> crate::models::mempool::Conversions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::moonpay::CurrencyInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.code.into_into_dart().into_dart(),
            self.min_buy_amount.into_into_dart().into_dart(),
            self.max_buy_amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::moonpay::CurrencyInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::moonpay::CurrencyInfo>
    for crate::models::moonpay::CurrencyInfo
{
    fn into_into_dart(self) -> crate::models::moonpay::CurrencyInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::DifficultyAdjustment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.progress_percent.into_into_dart().into_dart(),
            self.difficulty_change.into_into_dart().into_dart(),
            self.estimated_retarget_date.into_into_dart().into_dart(),
            self.remaining_blocks.into_into_dart().into_dart(),
            self.remaining_time.into_into_dart().into_dart(),
            self.previous_retarget.into_into_dart().into_dart(),
            self.previous_time.into_into_dart().into_dart(),
            self.next_retarget_height.into_into_dart().into_dart(),
            self.time_avg.into_into_dart().into_dart(),
            self.adjusted_time_avg.into_into_dart().into_dart(),
            self.time_offset.into_into_dart().into_dart(),
            self.expected_blocks.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::DifficultyAdjustment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::DifficultyAdjustment>
    for crate::models::mempool::DifficultyAdjustment
{
    fn into_into_dart(self) -> crate::models::mempool::DifficultyAdjustment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::DifficultyPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.difficulty.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::DifficultyPoint
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::DifficultyPoint>
    for crate::models::mempool::DifficultyPoint
{
    fn into_into_dart(self) -> crate::models::mempool::DifficultyPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lendaswap_api::EvmToBtcSwapResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_id.into_into_dart().into_dart(),
            self.evm_htlc_address.into_into_dart().into_dart(),
            self.source_amount_usd.into_into_dart().into_dart(),
            self.sats_to_receive.into_into_dart().into_dart(),
            self.fee_sats.into_into_dart().into_dart(),
            self.source_token_address.into_into_dart().into_dart(),
            self.create_swap_tx.into_into_dart().into_dart(),
            self.approve_tx.into_into_dart().into_dart(),
            self.gelato_forwarder_address.into_into_dart().into_dart(),
            self.gelato_user_nonce.into_into_dart().into_dart(),
            self.gelato_user_deadline.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lendaswap_api::EvmToBtcSwapResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lendaswap_api::EvmToBtcSwapResult>
    for crate::api::lendaswap_api::EvmToBtcSwapResult
{
    fn into_into_dart(self) -> crate::api::lendaswap_api::EvmToBtcSwapResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::exchange_rates::ExchangeRates {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.base.into_into_dart().into_dart(),
            self.rates.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::exchange_rates::ExchangeRates
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::exchange_rates::ExchangeRates>
    for crate::models::exchange_rates::ExchangeRates
{
    fn into_into_dart(self) -> crate::models::exchange_rates::ExchangeRates {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::FearGreedData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.now.into_into_dart().into_dart(),
            self.previous_close.into_into_dart().into_dart(),
            self.one_week_ago.into_into_dart().into_dart(),
            self.one_month_ago.into_into_dart().into_dart(),
            self.one_year_ago.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::FearGreedData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::FearGreedData>
    for crate::models::mempool::FearGreedData
{
    fn into_into_dart(self) -> crate::models::mempool::FearGreedData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::FearGreedIndex {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.last_updated.into_into_dart().into_dart(),
            self.fgi.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::FearGreedIndex
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::FearGreedIndex>
    for crate::models::mempool::FearGreedIndex
{
    fn into_into_dart(self) -> crate::models::mempool::FearGreedIndex {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::FearGreedLastUpdated {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.epoch_unix_seconds.into_into_dart().into_dart(),
            self.human_date.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::FearGreedLastUpdated
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::FearGreedLastUpdated>
    for crate::models::mempool::FearGreedLastUpdated
{
    fn into_into_dart(self) -> crate::models::mempool::FearGreedLastUpdated {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::FearGreedValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.value_text.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::FearGreedValue
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::FearGreedValue>
    for crate::models::mempool::FearGreedValue
{
    fn into_into_dart(self) -> crate::models::mempool::FearGreedValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::exchange_rates::FiatCurrency {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::USD => 0.into_dart(),
            Self::EUR => 1.into_dart(),
            Self::GBP => 2.into_dart(),
            Self::JPY => 3.into_dart(),
            Self::CAD => 4.into_dart(),
            Self::AUD => 5.into_dart(),
            Self::CHF => 6.into_dart(),
            Self::CNY => 7.into_dart(),
            Self::INR => 8.into_dart(),
            Self::BRL => 9.into_dart(),
            Self::MXN => 10.into_dart(),
            Self::KRW => 11.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::exchange_rates::FiatCurrency
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::exchange_rates::FiatCurrency>
    for crate::models::exchange_rates::FiatCurrency
{
    fn into_into_dart(self) -> crate::models::exchange_rates::FiatCurrency {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::HashrateData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.current_hashrate.into_into_dart().into_dart(),
            self.current_difficulty.into_into_dart().into_dart(),
            self.hashrates.into_into_dart().into_dart(),
            self.difficulty.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::HashrateData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::HashrateData>
    for crate::models::mempool::HashrateData
{
    fn into_into_dart(self) -> crate::models::mempool::HashrateData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::HashratePoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.avg_hashrate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::HashratePoint
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::HashratePoint>
    for crate::models::mempool::HashratePoint
{
    fn into_into_dart(self) -> crate::models::mempool::HashratePoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::historical_prices::HistoricalPriceData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.price.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::historical_prices::HistoricalPriceData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::historical_prices::HistoricalPriceData>
    for crate::models::historical_prices::HistoricalPriceData
{
    fn into_into_dart(self) -> crate::models::historical_prices::HistoricalPriceData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::historical_prices::HistoricalPriceResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.prices.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::historical_prices::HistoricalPriceResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::historical_prices::HistoricalPriceResponse>
    for crate::models::historical_prices::HistoricalPriceResponse
{
    fn into_into_dart(self) -> crate::models::historical_prices::HistoricalPriceResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::Info {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.server_pk.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::ark_api::Info {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::Info> for crate::api::ark_api::Info {
    fn into_into_dart(self) -> crate::api::ark_api::Info {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::Installment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.due_date.into_into_dart().into_dart(),
            self.principal.into_into_dart().into_dart(),
            self.interest.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.paid_date.into_into_dart().into_dart(),
            self.payment_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::Installment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::Installment>
    for crate::lendasat::models::Installment
{
    fn into_into_dart(self) -> crate::lendasat::models::Installment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::InstallmentStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Paid => 1.into_dart(),
            Self::Confirmed => 2.into_dart(),
            Self::Late => 3.into_dart(),
            Self::Cancelled => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::InstallmentStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::InstallmentStatus>
    for crate::lendasat::models::InstallmentStatus
{
    fn into_into_dart(self) -> crate::lendasat::models::InstallmentStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::LenderStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.joined_at.into_into_dart().into_dart(),
            self.successful_contracts.into_into_dart().into_dart(),
            self.vetted.into_into_dart().into_dart(),
            self.timezone.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::LenderStats
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::LenderStats>
    for crate::lendasat::models::LenderStats
{
    fn into_into_dart(self) -> crate::lendasat::models::LenderStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::LnPaymentResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_id.into_into_dart().into_dart(),
            self.txid.into_into_dart().into_dart(),
            self.amount_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ark_api::LnPaymentResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::LnPaymentResult>
    for crate::api::ark_api::LnPaymentResult
{
    fn into_into_dart(self) -> crate::api::ark_api::LnPaymentResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::LoanAsset {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::UsdcPol => 0.into_dart(),
            Self::UsdtPol => 1.into_dart(),
            Self::UsdcEth => 2.into_dart(),
            Self::UsdtEth => 3.into_dart(),
            Self::UsdcStrk => 4.into_dart(),
            Self::UsdtStrk => 5.into_dart(),
            Self::UsdcSol => 6.into_dart(),
            Self::UsdtSol => 7.into_dart(),
            Self::UsdtLiquid => 8.into_dart(),
            Self::Usd => 9.into_dart(),
            Self::Eur => 10.into_dart(),
            Self::Chf => 11.into_dart(),
            Self::Mxn => 12.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::LoanAsset
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::LoanAsset>
    for crate::lendasat::models::LoanAsset
{
    fn into_into_dart(self) -> crate::lendasat::models::LoanAsset {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::LoanOffer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.lender.into_into_dart().into_dart(),
            self.lender_pk.into_into_dart().into_dart(),
            self.loan_asset.into_into_dart().into_dart(),
            self.collateral_asset.into_into_dart().into_dart(),
            self.loan_amount_min.into_into_dart().into_dart(),
            self.loan_amount_max.into_into_dart().into_dart(),
            self.duration_days_min.into_into_dart().into_dart(),
            self.duration_days_max.into_into_dart().into_dart(),
            self.interest_rate.into_into_dart().into_dart(),
            self.min_ltv.into_into_dart().into_dart(),
            self.loan_payout.into_into_dart().into_dart(),
            self.loan_repayment_address.into_into_dart().into_dart(),
            self.origination_fee.into_into_dart().into_dart(),
            self.repayment_plan.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.kyc_link.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::LoanOffer
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::LoanOffer>
    for crate::lendasat::models::LoanOffer
{
    fn into_into_dart(self) -> crate::lendasat::models::LoanOffer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::LoanOfferStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Available => 0.into_dart(),
            Self::Unavailable => 1.into_dart(),
            Self::Deleted => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::LoanOfferStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::LoanOfferStatus>
    for crate::lendasat::models::LoanOfferStatus
{
    fn into_into_dart(self) -> crate::lendasat::models::LoanOfferStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::LoanPayout {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Direct => 0.into_dart(),
            Self::Indirect => 1.into_dart(),
            Self::MoonCardInstant => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::LoanPayout
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::LoanPayout>
    for crate::lendasat::models::LoanPayout
{
    fn into_into_dart(self) -> crate::lendasat::models::LoanPayout {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::LoanTransaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.contract_id.into_into_dart().into_dart(),
            self.transaction_type.into_into_dart().into_dart(),
            self.txid.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::LoanTransaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::LoanTransaction>
    for crate::lendasat::models::LoanTransaction
{
    fn into_into_dart(self) -> crate::lendasat::models::LoanTransaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::logger::LogEntry {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.msg.into_into_dart().into_dart(),
            self.target.into_into_dart().into_dart(),
            self.level.into_into_dart().into_dart(),
            self.file.into_into_dart().into_dart(),
            self.line.into_into_dart().into_dart(),
            self.module_path.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::logger::LogEntry {}
impl flutter_rust_bridge::IntoIntoDart<crate::logger::LogEntry> for crate::logger::LogEntry {
    fn into_into_dart(self) -> crate::logger::LogEntry {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::MempoolBlock {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.block_size.into_into_dart().into_dart(),
            self.block_vsize.into_into_dart().into_dart(),
            self.n_tx.into_into_dart().into_dart(),
            self.total_fees.into_into_dart().into_dart(),
            self.median_fee.into_into_dart().into_dart(),
            self.fee_range.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::MempoolBlock
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::MempoolBlock>
    for crate::models::mempool::MempoolBlock
{
    fn into_into_dart(self) -> crate::models::mempool::MempoolBlock {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::MempoolWsMessage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.mempool_blocks.into_into_dart().into_dart(),
            self.blocks.into_into_dart().into_dart(),
            self.conversions.into_into_dart().into_dart(),
            self.fees.into_into_dart().into_dart(),
            self.da.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::MempoolWsMessage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::MempoolWsMessage>
    for crate::models::mempool::MempoolWsMessage
{
    fn into_into_dart(self) -> crate::models::mempool::MempoolWsMessage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::MiningPool {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.slug.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::MiningPool
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::MiningPool>
    for crate::models::mempool::MiningPool
{
    fn into_into_dart(self) -> crate::models::mempool::MiningPool {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::moonpay::MoonPayCurrencyLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.quote_currency.into_into_dart().into_dart(),
            self.base_currency.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::moonpay::MoonPayCurrencyLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::moonpay::MoonPayCurrencyLimits>
    for crate::models::moonpay::MoonPayCurrencyLimits
{
    fn into_into_dart(self) -> crate::models::moonpay::MoonPayCurrencyLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::moonpay::MoonPayEncryptedData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ciphertext.into_into_dart().into_dart(),
            self.iv.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::moonpay::MoonPayEncryptedData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::moonpay::MoonPayEncryptedData>
    for crate::models::moonpay::MoonPayEncryptedData
{
    fn into_into_dart(self) -> crate::models::moonpay::MoonPayEncryptedData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::moonpay::MoonPayQuote {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.base_currency_amount.into_into_dart().into_dart(),
            self.quote_currency_amount.into_into_dart().into_dart(),
            self.base_currency_code.into_into_dart().into_dart(),
            self.exchange_rate.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::moonpay::MoonPayQuote
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::moonpay::MoonPayQuote>
    for crate::models::moonpay::MoonPayQuote
{
    fn into_into_dart(self) -> crate::models::moonpay::MoonPayQuote {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::OffchainBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pending_sats.into_into_dart().into_dart(),
            self.confirmed_sats.into_into_dart().into_dart(),
            self.total_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ark_api::OffchainBalance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::OffchainBalance>
    for crate::api::ark_api::OffchainBalance
{
    fn into_into_dart(self) -> crate::api::ark_api::OffchainBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::OfferFilters {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.loan_type.into_into_dart().into_dart(),
            self.asset_type.into_into_dart().into_dart(),
            self.loan_assets.into_into_dart().into_dart(),
            self.kyc.into_into_dart().into_dart(),
            self.min_loan_amount.into_into_dart().into_dart(),
            self.max_loan_amount.into_into_dart().into_dart(),
            self.max_interest_rate.into_into_dart().into_dart(),
            self.duration_min.into_into_dart().into_dart(),
            self.duration_max.into_into_dart().into_dart(),
            self.collateral_asset_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::OfferFilters
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::OfferFilters>
    for crate::lendasat::models::OfferFilters
{
    fn into_into_dart(self) -> crate::lendasat::models::OfferFilters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::OriginationFee {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.fee.into_into_dart().into_dart(),
            self.from_day.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::OriginationFee
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::OriginationFee>
    for crate::lendasat::models::OriginationFee
{
    fn into_into_dart(self) -> crate::lendasat::models::OriginationFee {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::PaginatedContractsResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.data.into_into_dart().into_dart(),
            self.page.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.total_pages.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::PaginatedContractsResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::PaginatedContractsResponse>
    for crate::lendasat::models::PaginatedContractsResponse
{
    fn into_into_dart(self) -> crate::lendasat::models::PaginatedContractsResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::PaymentReceived {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.amount_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ark_api::PaymentReceived
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::PaymentReceived>
    for crate::api::ark_api::PaymentReceived
{
    fn into_into_dart(self) -> crate::api::ark_api::PaymentReceived {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::ProjectedBlockTransactions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.index.into_into_dart().into_dart(),
            self.transactions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::ProjectedBlockTransactions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::ProjectedBlockTransactions>
    for crate::models::mempool::ProjectedBlockTransactions
{
    fn into_into_dart(self) -> crate::models::mempool::ProjectedBlockTransactions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::ProjectedTransaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.vsize.into_into_dart().into_dart(),
            self.fee_rate.into_into_dart().into_dart(),
            self.flags.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::ProjectedTransaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::ProjectedTransaction>
    for crate::models::mempool::ProjectedTransaction
{
    fn into_into_dart(self) -> crate::models::mempool::ProjectedTransaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::RecommendedFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.fastest_fee.into_into_dart().into_dart(),
            self.half_hour_fee.into_into_dart().into_dart(),
            self.hour_fee.into_into_dart().into_dart(),
            self.economy_fee.into_into_dart().into_dart(),
            self.minimum_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::RecommendedFees
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::RecommendedFees>
    for crate::models::mempool::RecommendedFees
{
    fn into_into_dart(self) -> crate::models::mempool::RecommendedFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::RepaymentPlan {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bullet => 0.into_dart(),
            Self::InterestOnlyWeekly => 1.into_dart(),
            Self::InterestOnlyMonthly => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::RepaymentPlan
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::RepaymentPlan>
    for crate::lendasat::models::RepaymentPlan
{
    fn into_into_dart(self) -> crate::lendasat::models::RepaymentPlan {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendasat::models::SettleArkPsbtResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.intent_message.into_into_dart().into_dart(),
            self.intent_proof.into_into_dart().into_dart(),
            self.forfeit_psbts.into_into_dart().into_dart(),
            self.delegate_cosigner_pk.into_into_dart().into_dart(),
            self.user_pk.into_into_dart().into_dart(),
            self.derivation_path.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendasat::models::SettleArkPsbtResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendasat::models::SettleArkPsbtResponse>
    for crate::lendasat::models::SettleArkPsbtResponse
{
    fn into_into_dart(self) -> crate::lendasat::models::SettleArkPsbtResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendaswap::SwapInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.source_token.into_into_dart().into_dart(),
            self.target_token.into_into_dart().into_dart(),
            self.source_amount_sats.into_into_dart().into_dart(),
            self.target_amount_usd.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.ln_invoice.into_into_dart().into_dart(),
            self.arkade_htlc_address.into_into_dart().into_dart(),
            self.evm_htlc_address.into_into_dart().into_dart(),
            self.fee_sats.into_into_dart().into_dart(),
            self.can_claim_gelato.into_into_dart().into_dart(),
            self.can_claim_vhtlc.into_into_dart().into_dart(),
            self.can_refund.into_into_dart().into_dart(),
            self.detailed_status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::lendaswap::SwapInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::lendaswap::SwapInfo> for crate::lendaswap::SwapInfo {
    fn into_into_dart(self) -> crate::lendaswap::SwapInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lendaswap_api::SwapQuote {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.exchange_rate.into_into_dart().into_dart(),
            self.network_fee_sats.into_into_dart().into_dart(),
            self.protocol_fee_sats.into_into_dart().into_dart(),
            self.protocol_fee_percent.into_into_dart().into_dart(),
            self.min_amount_sats.into_into_dart().into_dart(),
            self.max_amount_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lendaswap_api::SwapQuote
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lendaswap_api::SwapQuote>
    for crate::api::lendaswap_api::SwapQuote
{
    fn into_into_dart(self) -> crate::api::lendaswap_api::SwapQuote {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::lendaswap::SwapStatusSimple {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::WaitingForDeposit => 0.into_dart(),
            Self::Processing => 1.into_dart(),
            Self::Completed => 2.into_dart(),
            Self::Expired => 3.into_dart(),
            Self::Refundable => 4.into_dart(),
            Self::Refunded => 5.into_dart(),
            Self::Failed => 6.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::lendaswap::SwapStatusSimple
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::lendaswap::SwapStatusSimple>
    for crate::lendaswap::SwapStatusSimple
{
    fn into_into_dart(self) -> crate::lendaswap::SwapStatusSimple {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lendaswap_api::TradingPair {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.source.into_into_dart().into_dart(),
            self.target.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lendaswap_api::TradingPair
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lendaswap_api::TradingPair>
    for crate::api::lendaswap_api::TradingPair
{
    fn into_into_dart(self) -> crate::api::lendaswap_api::TradingPair {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ark_api::Transaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::ark_api::Transaction::Boarding {
                txid,
                amount_sats,
                confirmed_at,
            } => [
                0.into_dart(),
                txid.into_into_dart().into_dart(),
                amount_sats.into_into_dart().into_dart(),
                confirmed_at.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::ark_api::Transaction::Round {
                txid,
                amount_sats,
                created_at,
            } => [
                1.into_dart(),
                txid.into_into_dart().into_dart(),
                amount_sats.into_into_dart().into_dart(),
                created_at.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::ark_api::Transaction::Redeem {
                txid,
                amount_sats,
                is_settled,
                created_at,
            } => [
                2.into_dart(),
                txid.into_into_dart().into_dart(),
                amount_sats.into_into_dart().into_dart(),
                is_settled.into_into_dart().into_dart(),
                created_at.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ark_api::Transaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ark_api::Transaction>
    for crate::api::ark_api::Transaction
{
    fn into_into_dart(self) -> crate::api::ark_api::Transaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::TxInput {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
            self.prevout.into_into_dart().into_dart(),
            self.scriptsig.into_into_dart().into_dart(),
            self.scriptsig_asm.into_into_dart().into_dart(),
            self.witness.into_into_dart().into_dart(),
            self.is_coinbase.into_into_dart().into_dart(),
            self.sequence.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::TxInput
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::TxInput>
    for crate::models::mempool::TxInput
{
    fn into_into_dart(self) -> crate::models::mempool::TxInput {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::TxOutput {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.scriptpubkey.into_into_dart().into_dart(),
            self.scriptpubkey_asm.into_into_dart().into_dart(),
            self.scriptpubkey_type.into_into_dart().into_dart(),
            self.scriptpubkey_address.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::TxOutput
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::TxOutput>
    for crate::models::mempool::TxOutput
{
    fn into_into_dart(self) -> crate::models::mempool::TxOutput {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::mempool::TxStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.confirmed.into_into_dart().into_dart(),
            self.block_height.into_into_dart().into_dart(),
            self.block_hash.into_into_dart().into_dart(),
            self.block_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::mempool::TxStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::mempool::TxStatus>
    for crate::models::mempool::TxStatus
{
    fn into_into_dart(self) -> crate::models::mempool::TxStatus {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, f64)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for StreamSink<crate::logger::LogEntry, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::models::mempool::MempoolWsMessage,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::models::mempool::ProjectedBlockTransactions,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::ark_api::Addresses {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.boarding, serializer);
        <String>::sse_encode(self.offchain, serializer);
        <String>::sse_encode(self.bip21, serializer);
        <Option<crate::api::ark_api::BoltzSwap>>::sse_encode(self.lightning, serializer);
    }
}

impl SseEncode for crate::lendasat::models::ArkClaimPsbtResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ark_psbt, serializer);
        <Vec<String>>::sse_encode(self.checkpoint_psbts, serializer);
    }
}

impl SseEncode for crate::api::lendaswap_api::AssetInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.token_id, serializer);
        <String>::sse_encode(self.symbol, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.chain, serializer);
        <u8>::sse_encode(self.decimals, serializer);
    }
}

impl SseEncode for crate::api::lendasat_api::AuthResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::lendasat_api::AuthResult::Success {
                user_id,
                user_name,
                user_email,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(user_id, serializer);
                <String>::sse_encode(user_name, serializer);
                <Option<String>>::sse_encode(user_email, serializer);
            }
            crate::api::lendasat_api::AuthResult::NeedsRegistration { pubkey } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(pubkey, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::ark_api::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::ark_api::OffchainBalance>::sse_encode(self.offchain, serializer);
    }
}

impl SseEncode for crate::models::mempool::BitcoinTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.version, serializer);
        <u32>::sse_encode(self.locktime, serializer);
        <u32>::sse_encode(self.size, serializer);
        <u32>::sse_encode(self.weight, serializer);
        <u64>::sse_encode(self.fee, serializer);
        <Option<u32>>::sse_encode(self.sigops, serializer);
        <crate::models::mempool::TxStatus>::sse_encode(self.status, serializer);
        <Vec<crate::models::mempool::TxInput>>::sse_encode(self.vin, serializer);
        <Vec<crate::models::mempool::TxOutput>>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::models::mempool::Block {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u64>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.version, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
        <u32>::sse_encode(self.bits, serializer);
        <u32>::sse_encode(self.nonce, serializer);
        <f64>::sse_encode(self.difficulty, serializer);
        <String>::sse_encode(self.merkle_root, serializer);
        <u32>::sse_encode(self.tx_count, serializer);
        <u64>::sse_encode(self.size, serializer);
        <u64>::sse_encode(self.weight, serializer);
        <Option<String>>::sse_encode(self.previousblockhash, serializer);
        <Option<u64>>::sse_encode(self.mediantime, serializer);
        <Option<bool>>::sse_encode(self.stale, serializer);
        <Option<crate::models::mempool::BlockExtras>>::sse_encode(self.extras, serializer);
    }
}

impl SseEncode for crate::models::mempool::BlockExtras {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<f64>>::sse_encode(self.median_fee, serializer);
        <Option<u64>>::sse_encode(self.total_fees, serializer);
        <Option<f64>>::sse_encode(self.avg_fee, serializer);
        <Option<f64>>::sse_encode(self.avg_fee_rate, serializer);
        <Option<u64>>::sse_encode(self.reward, serializer);
        <Option<crate::models::mempool::MiningPool>>::sse_encode(self.pool, serializer);
        <Option<f64>>::sse_encode(self.match_rate, serializer);
        <Option<f64>>::sse_encode(self.similarity, serializer);
    }
}

impl SseEncode for crate::api::ark_api::BoardingUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u64>::sse_encode(self.amount_sats, serializer);
        <bool>::sse_encode(self.is_confirmed, serializer);
    }
}

impl SseEncode for crate::api::ark_api::BoltzSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.swap_id, serializer);
        <u64>::sse_encode(self.amount_sats, serializer);
        <String>::sse_encode(self.invoice, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::lendaswap_api::BtcToEvmSwapResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.swap_id, serializer);
        <String>::sse_encode(self.ln_invoice, serializer);
        <String>::sse_encode(self.arkade_htlc_address, serializer);
        <i64>::sse_encode(self.sats_to_send, serializer);
        <f64>::sse_encode(self.target_amount_usd, serializer);
        <i64>::sse_encode(self.fee_sats, serializer);
    }
}

impl SseEncode for crate::lendasat::models::ClaimPsbtResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.psbt, serializer);
        <String>::sse_encode(self.collateral_descriptor, serializer);
        <String>::sse_encode(self.borrower_pk, serializer);
    }
}

impl SseEncode for crate::lendasat::models::CollateralAsset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendasat::models::CollateralAsset::BitcoinBtc => 0,
                crate::lendasat::models::CollateralAsset::ArkadeBtc => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::lendasat::models::Contract {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::lendasat::models::ContractStatus>::sse_encode(self.status, serializer);
        <crate::lendasat::models::LenderStats>::sse_encode(self.lender, serializer);
        <String>::sse_encode(self.lender_pk, serializer);
        <String>::sse_encode(self.borrower_pk, serializer);
        <String>::sse_encode(self.borrower_btc_address, serializer);
        <Option<String>>::sse_encode(self.borrower_derivation_path, serializer);
        <Option<String>>::sse_encode(self.borrower_loan_address, serializer);
        <crate::lendasat::models::LoanAsset>::sse_encode(self.loan_asset, serializer);
        <crate::lendasat::models::CollateralAsset>::sse_encode(self.collateral_asset, serializer);
        <f64>::sse_encode(self.loan_amount, serializer);
        <f64>::sse_encode(self.interest, serializer);
        <f64>::sse_encode(self.interest_rate, serializer);
        <i32>::sse_encode(self.duration_days, serializer);
        <String>::sse_encode(self.expiry, serializer);
        <i64>::sse_encode(self.collateral_sats, serializer);
        <i64>::sse_encode(self.initial_collateral_sats, serializer);
        <i64>::sse_encode(self.deposited_sats, serializer);
        <f64>::sse_encode(self.initial_ltv, serializer);
        <f64>::sse_encode(self.liquidation_price, serializer);
        <f64>::sse_encode(self.ltv_threshold_margin_call_1, serializer);
        <f64>::sse_encode(self.ltv_threshold_margin_call_2, serializer);
        <f64>::sse_encode(self.ltv_threshold_liquidation, serializer);
        <f64>::sse_encode(self.balance_outstanding, serializer);
        <Option<String>>::sse_encode(self.contract_address, serializer);
        <Option<String>>::sse_encode(self.collateral_script, serializer);
        <Option<String>>::sse_encode(self.loan_repayment_address, serializer);
        <Option<String>>::sse_encode(self.btc_loan_repayment_address, serializer);
        <i64>::sse_encode(self.origination_fee_sats, serializer);
        <Vec<crate::lendasat::models::Installment>>::sse_encode(self.installments, serializer);
        <Vec<crate::lendasat::models::LoanTransaction>>::sse_encode(self.transactions, serializer);
        <bool>::sse_encode(self.can_extend, serializer);
        <Option<f64>>::sse_encode(self.extension_interest_rate, serializer);
        <i32>::sse_encode(self.extension_max_duration_days, serializer);
        <Option<String>>::sse_encode(self.extends_contract, serializer);
        <Option<String>>::sse_encode(self.extended_by_contract, serializer);
        <Option<String>>::sse_encode(self.client_contract_id, serializer);
        <Option<bool>>::sse_encode(self.requires_ark_settlement, serializer);
        <String>::sse_encode(self.created_at, serializer);
        <String>::sse_encode(self.updated_at, serializer);
    }
}

impl SseEncode for crate::lendasat::models::ContractFilters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.page, serializer);
        <Option<i32>>::sse_encode(self.limit, serializer);
        <Option<Vec<crate::lendasat::models::ContractStatus>>>::sse_encode(self.status, serializer);
        <Option<String>>::sse_encode(self.sort_by, serializer);
        <Option<String>>::sse_encode(self.sort_order, serializer);
    }
}

impl SseEncode for crate::lendasat::models::ContractStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendasat::models::ContractStatus::Requested => 0,
                crate::lendasat::models::ContractStatus::Approved => 1,
                crate::lendasat::models::ContractStatus::CollateralSeen => 2,
                crate::lendasat::models::ContractStatus::CollateralConfirmed => 3,
                crate::lendasat::models::ContractStatus::PrincipalGiven => 4,
                crate::lendasat::models::ContractStatus::RepaymentProvided => 5,
                crate::lendasat::models::ContractStatus::RepaymentConfirmed => 6,
                crate::lendasat::models::ContractStatus::Undercollateralized => 7,
                crate::lendasat::models::ContractStatus::Defaulted => 8,
                crate::lendasat::models::ContractStatus::ClosingByClaim => 9,
                crate::lendasat::models::ContractStatus::Closed => 10,
                crate::lendasat::models::ContractStatus::Closing => 11,
                crate::lendasat::models::ContractStatus::ClosingByLiquidation => 12,
                crate::lendasat::models::ContractStatus::ClosedByLiquidation => 13,
                crate::lendasat::models::ContractStatus::ClosingByDefaulting => 14,
                crate::lendasat::models::ContractStatus::ClosedByDefaulting => 15,
                crate::lendasat::models::ContractStatus::Extended => 16,
                crate::lendasat::models::ContractStatus::Rejected => 17,
                crate::lendasat::models::ContractStatus::DisputeBorrowerStarted => 18,
                crate::lendasat::models::ContractStatus::DisputeLenderStarted => 19,
                crate::lendasat::models::ContractStatus::Cancelled => 20,
                crate::lendasat::models::ContractStatus::RequestExpired => 21,
                crate::lendasat::models::ContractStatus::ApprovalExpired => 22,
                crate::lendasat::models::ContractStatus::CollateralRecoverable => 23,
                crate::lendasat::models::ContractStatus::ClosingByRecovery => 24,
                crate::lendasat::models::ContractStatus::ClosedByRecovery => 25,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::mempool::Conversions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.time, serializer);
        <f64>::sse_encode(self.usd, serializer);
        <Option<f64>>::sse_encode(self.eur, serializer);
    }
}

impl SseEncode for crate::models::moonpay::CurrencyInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.code, serializer);
        <f64>::sse_encode(self.min_buy_amount, serializer);
        <f64>::sse_encode(self.max_buy_amount, serializer);
    }
}

impl SseEncode for crate::models::mempool::DifficultyAdjustment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.progress_percent, serializer);
        <f64>::sse_encode(self.difficulty_change, serializer);
        <u64>::sse_encode(self.estimated_retarget_date, serializer);
        <u32>::sse_encode(self.remaining_blocks, serializer);
        <u64>::sse_encode(self.remaining_time, serializer);
        <Option<f64>>::sse_encode(self.previous_retarget, serializer);
        <Option<u64>>::sse_encode(self.previous_time, serializer);
        <u64>::sse_encode(self.next_retarget_height, serializer);
        <u64>::sse_encode(self.time_avg, serializer);
        <Option<u64>>::sse_encode(self.adjusted_time_avg, serializer);
        <i64>::sse_encode(self.time_offset, serializer);
        <f64>::sse_encode(self.expected_blocks, serializer);
    }
}

impl SseEncode for crate::models::mempool::DifficultyPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.timestamp, serializer);
        <Option<f64>>::sse_encode(self.difficulty, serializer);
        <Option<u64>>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for crate::api::lendaswap_api::EvmToBtcSwapResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.swap_id, serializer);
        <String>::sse_encode(self.evm_htlc_address, serializer);
        <f64>::sse_encode(self.source_amount_usd, serializer);
        <i64>::sse_encode(self.sats_to_receive, serializer);
        <i64>::sse_encode(self.fee_sats, serializer);
        <String>::sse_encode(self.source_token_address, serializer);
        <Option<String>>::sse_encode(self.create_swap_tx, serializer);
        <Option<String>>::sse_encode(self.approve_tx, serializer);
        <Option<String>>::sse_encode(self.gelato_forwarder_address, serializer);
        <Option<String>>::sse_encode(self.gelato_user_nonce, serializer);
        <Option<String>>::sse_encode(self.gelato_user_deadline, serializer);
    }
}

impl SseEncode for crate::models::exchange_rates::ExchangeRates {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.base, serializer);
        <std::collections::HashMap<String, f64>>::sse_encode(self.rates, serializer);
        <i64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::mempool::FearGreedData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::models::mempool::FearGreedValue>>::sse_encode(self.now, serializer);
        <Option<crate::models::mempool::FearGreedValue>>::sse_encode(
            self.previous_close,
            serializer,
        );
        <Option<crate::models::mempool::FearGreedValue>>::sse_encode(self.one_week_ago, serializer);
        <Option<crate::models::mempool::FearGreedValue>>::sse_encode(
            self.one_month_ago,
            serializer,
        );
        <Option<crate::models::mempool::FearGreedValue>>::sse_encode(self.one_year_ago, serializer);
    }
}

impl SseEncode for crate::models::mempool::FearGreedIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::models::mempool::FearGreedLastUpdated>>::sse_encode(
            self.last_updated,
            serializer,
        );
        <Option<crate::models::mempool::FearGreedData>>::sse_encode(self.fgi, serializer);
    }
}

impl SseEncode for crate::models::mempool::FearGreedLastUpdated {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i64>>::sse_encode(self.epoch_unix_seconds, serializer);
        <Option<String>>::sse_encode(self.human_date, serializer);
    }
}

impl SseEncode for crate::models::mempool::FearGreedValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.value, serializer);
        <Option<String>>::sse_encode(self.value_text, serializer);
    }
}

impl SseEncode for crate::models::exchange_rates::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::exchange_rates::FiatCurrency::USD => 0,
                crate::models::exchange_rates::FiatCurrency::EUR => 1,
                crate::models::exchange_rates::FiatCurrency::GBP => 2,
                crate::models::exchange_rates::FiatCurrency::JPY => 3,
                crate::models::exchange_rates::FiatCurrency::CAD => 4,
                crate::models::exchange_rates::FiatCurrency::AUD => 5,
                crate::models::exchange_rates::FiatCurrency::CHF => 6,
                crate::models::exchange_rates::FiatCurrency::CNY => 7,
                crate::models::exchange_rates::FiatCurrency::INR => 8,
                crate::models::exchange_rates::FiatCurrency::BRL => 9,
                crate::models::exchange_rates::FiatCurrency::MXN => 10,
                crate::models::exchange_rates::FiatCurrency::KRW => 11,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::mempool::HashrateData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<f64>>::sse_encode(self.current_hashrate, serializer);
        <Option<f64>>::sse_encode(self.current_difficulty, serializer);
        <Vec<crate::models::mempool::HashratePoint>>::sse_encode(self.hashrates, serializer);
        <Vec<crate::models::mempool::DifficultyPoint>>::sse_encode(self.difficulty, serializer);
    }
}

impl SseEncode for crate::models::mempool::HashratePoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.timestamp, serializer);
        <f64>::sse_encode(self.avg_hashrate, serializer);
    }
}

impl SseEncode for crate::models::historical_prices::HistoricalPriceData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.timestamp, serializer);
        <String>::sse_encode(self.price, serializer);
    }
}

impl SseEncode for crate::models::historical_prices::HistoricalPriceResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::historical_prices::HistoricalPriceData>>::sse_encode(
            self.prices,
            serializer,
        );
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::ark_api::Info {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.server_pk, serializer);
        <String>::sse_encode(self.network, serializer);
    }
}

impl SseEncode for crate::lendasat::models::Installment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.due_date, serializer);
        <f64>::sse_encode(self.principal, serializer);
        <f64>::sse_encode(self.interest, serializer);
        <crate::lendasat::models::InstallmentStatus>::sse_encode(self.status, serializer);
        <Option<String>>::sse_encode(self.paid_date, serializer);
        <Option<String>>::sse_encode(self.payment_id, serializer);
    }
}

impl SseEncode for crate::lendasat::models::InstallmentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendasat::models::InstallmentStatus::Pending => 0,
                crate::lendasat::models::InstallmentStatus::Paid => 1,
                crate::lendasat::models::InstallmentStatus::Confirmed => 2,
                crate::lendasat::models::InstallmentStatus::Late => 3,
                crate::lendasat::models::InstallmentStatus::Cancelled => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::lendasat::models::LenderStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.joined_at, serializer);
        <i32>::sse_encode(self.successful_contracts, serializer);
        <bool>::sse_encode(self.vetted, serializer);
        <Option<String>>::sse_encode(self.timezone, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::BitcoinTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::BitcoinTransaction>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::Block> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::Block>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::ark_api::BoardingUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::ark_api::BoardingUtxo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::lendasat::models::Contract> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::lendasat::models::Contract>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::lendasat::models::ContractStatus> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::lendasat::models::ContractStatus>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::DifficultyPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::DifficultyPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::exchange_rates::FiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::exchange_rates::FiatCurrency>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::HashratePoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::HashratePoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::historical_prices::HistoricalPriceData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::historical_prices::HistoricalPriceData>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::lendasat::models::Installment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::lendasat::models::Installment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::lendasat::models::LoanOffer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::lendasat::models::LoanOffer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::lendasat::models::LoanTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::lendasat::models::LoanTransaction>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::MempoolBlock> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::MempoolBlock>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::lendasat::models::OriginationFee> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::lendasat::models::OriginationFee>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::ProjectedTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::ProjectedTransaction>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, f64)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::lendaswap::SwapInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::lendaswap::SwapInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::lendaswap_api::TradingPair> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::lendaswap_api::TradingPair>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::ark_api::Transaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::ark_api::Transaction>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::TxInput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::TxInput>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::mempool::TxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::mempool::TxOutput>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::ark_api::LnPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.swap_id, serializer);
        <String>::sse_encode(self.txid, serializer);
        <u64>::sse_encode(self.amount_sats, serializer);
    }
}

impl SseEncode for crate::lendasat::models::LoanAsset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendasat::models::LoanAsset::UsdcPol => 0,
                crate::lendasat::models::LoanAsset::UsdtPol => 1,
                crate::lendasat::models::LoanAsset::UsdcEth => 2,
                crate::lendasat::models::LoanAsset::UsdtEth => 3,
                crate::lendasat::models::LoanAsset::UsdcStrk => 4,
                crate::lendasat::models::LoanAsset::UsdtStrk => 5,
                crate::lendasat::models::LoanAsset::UsdcSol => 6,
                crate::lendasat::models::LoanAsset::UsdtSol => 7,
                crate::lendasat::models::LoanAsset::UsdtLiquid => 8,
                crate::lendasat::models::LoanAsset::Usd => 9,
                crate::lendasat::models::LoanAsset::Eur => 10,
                crate::lendasat::models::LoanAsset::Chf => 11,
                crate::lendasat::models::LoanAsset::Mxn => 12,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::lendasat::models::LoanOffer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <crate::lendasat::models::LenderStats>::sse_encode(self.lender, serializer);
        <String>::sse_encode(self.lender_pk, serializer);
        <crate::lendasat::models::LoanAsset>::sse_encode(self.loan_asset, serializer);
        <crate::lendasat::models::CollateralAsset>::sse_encode(self.collateral_asset, serializer);
        <f64>::sse_encode(self.loan_amount_min, serializer);
        <f64>::sse_encode(self.loan_amount_max, serializer);
        <i32>::sse_encode(self.duration_days_min, serializer);
        <i32>::sse_encode(self.duration_days_max, serializer);
        <f64>::sse_encode(self.interest_rate, serializer);
        <f64>::sse_encode(self.min_ltv, serializer);
        <crate::lendasat::models::LoanPayout>::sse_encode(self.loan_payout, serializer);
        <String>::sse_encode(self.loan_repayment_address, serializer);
        <Vec<crate::lendasat::models::OriginationFee>>::sse_encode(
            self.origination_fee,
            serializer,
        );
        <crate::lendasat::models::RepaymentPlan>::sse_encode(self.repayment_plan, serializer);
        <crate::lendasat::models::LoanOfferStatus>::sse_encode(self.status, serializer);
        <Option<String>>::sse_encode(self.kyc_link, serializer);
    }
}

impl SseEncode for crate::lendasat::models::LoanOfferStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendasat::models::LoanOfferStatus::Available => 0,
                crate::lendasat::models::LoanOfferStatus::Unavailable => 1,
                crate::lendasat::models::LoanOfferStatus::Deleted => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::lendasat::models::LoanPayout {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendasat::models::LoanPayout::Direct => 0,
                crate::lendasat::models::LoanPayout::Indirect => 1,
                crate::lendasat::models::LoanPayout::MoonCardInstant => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::lendasat::models::LoanTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.contract_id, serializer);
        <String>::sse_encode(self.transaction_type, serializer);
        <String>::sse_encode(self.txid, serializer);
        <String>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for crate::logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.msg, serializer);
        <String>::sse_encode(self.target, serializer);
        <String>::sse_encode(self.level, serializer);
        <String>::sse_encode(self.file, serializer);
        <String>::sse_encode(self.line, serializer);
        <String>::sse_encode(self.module_path, serializer);
        <String>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::models::mempool::MempoolBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.block_size, serializer);
        <f64>::sse_encode(self.block_vsize, serializer);
        <u32>::sse_encode(self.n_tx, serializer);
        <u64>::sse_encode(self.total_fees, serializer);
        <f64>::sse_encode(self.median_fee, serializer);
        <Vec<f64>>::sse_encode(self.fee_range, serializer);
    }
}

impl SseEncode for crate::models::mempool::MempoolWsMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<Vec<crate::models::mempool::MempoolBlock>>>::sse_encode(
            self.mempool_blocks,
            serializer,
        );
        <Option<Vec<crate::models::mempool::Block>>>::sse_encode(self.blocks, serializer);
        <Option<crate::models::mempool::Conversions>>::sse_encode(self.conversions, serializer);
        <Option<crate::models::mempool::RecommendedFees>>::sse_encode(self.fees, serializer);
        <Option<crate::models::mempool::DifficultyAdjustment>>::sse_encode(self.da, serializer);
    }
}

impl SseEncode for crate::models::mempool::MiningPool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u32>>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.slug, serializer);
    }
}

impl SseEncode for crate::models::moonpay::MoonPayCurrencyLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::moonpay::CurrencyInfo>::sse_encode(self.quote_currency, serializer);
        <crate::models::moonpay::CurrencyInfo>::sse_encode(self.base_currency, serializer);
    }
}

impl SseEncode for crate::models::moonpay::MoonPayEncryptedData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ciphertext, serializer);
        <String>::sse_encode(self.iv, serializer);
    }
}

impl SseEncode for crate::models::moonpay::MoonPayQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.base_currency_amount, serializer);
        <f64>::sse_encode(self.quote_currency_amount, serializer);
        <String>::sse_encode(self.base_currency_code, serializer);
        <f64>::sse_encode(self.exchange_rate, serializer);
        <String>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for crate::api::ark_api::OffchainBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.pending_sats, serializer);
        <u64>::sse_encode(self.confirmed_sats, serializer);
        <u64>::sse_encode(self.total_sats, serializer);
    }
}

impl SseEncode for crate::lendasat::models::OfferFilters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.loan_type, serializer);
        <Option<String>>::sse_encode(self.asset_type, serializer);
        <Option<String>>::sse_encode(self.loan_assets, serializer);
        <Option<String>>::sse_encode(self.kyc, serializer);
        <Option<f64>>::sse_encode(self.min_loan_amount, serializer);
        <Option<f64>>::sse_encode(self.max_loan_amount, serializer);
        <Option<f64>>::sse_encode(self.max_interest_rate, serializer);
        <Option<i32>>::sse_encode(self.duration_min, serializer);
        <Option<i32>>::sse_encode(self.duration_max, serializer);
        <Option<String>>::sse_encode(self.collateral_asset_type, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::BlockExtras> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::BlockExtras>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::ark_api::BoltzSwap> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::ark_api::BoltzSwap>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::lendasat::models::ContractFilters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::lendasat::models::ContractFilters>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::Conversions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::Conversions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::DifficultyAdjustment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::DifficultyAdjustment>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::FearGreedData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::FearGreedData>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::FearGreedLastUpdated> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::FearGreedLastUpdated>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::FearGreedValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::FearGreedValue>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::MiningPool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::MiningPool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::lendasat::models::OfferFilters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::lendasat::models::OfferFilters>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::RecommendedFees> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::RecommendedFees>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::mempool::TxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::mempool::TxOutput>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::mempool::Block>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::mempool::Block>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::lendasat::models::ContractStatus>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::lendasat::models::ContractStatus>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::mempool::MempoolBlock>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::mempool::MempoolBlock>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::lendasat::models::OriginationFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.fee, serializer);
        <i32>::sse_encode(self.from_day, serializer);
    }
}

impl SseEncode for crate::lendasat::models::PaginatedContractsResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::lendasat::models::Contract>>::sse_encode(self.data, serializer);
        <i32>::sse_encode(self.page, serializer);
        <i32>::sse_encode(self.limit, serializer);
        <i32>::sse_encode(self.total, serializer);
        <i32>::sse_encode(self.total_pages, serializer);
    }
}

impl SseEncode for crate::api::ark_api::PaymentReceived {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u64>::sse_encode(self.amount_sats, serializer);
    }
}

impl SseEncode for crate::models::mempool::ProjectedBlockTransactions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.index, serializer);
        <Vec<crate::models::mempool::ProjectedTransaction>>::sse_encode(
            self.transactions,
            serializer,
        );
    }
}

impl SseEncode for crate::models::mempool::ProjectedTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u64>::sse_encode(self.value, serializer);
        <u32>::sse_encode(self.vsize, serializer);
        <f64>::sse_encode(self.fee_rate, serializer);
        <u32>::sse_encode(self.flags, serializer);
    }
}

impl SseEncode for crate::models::mempool::RecommendedFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.fastest_fee, serializer);
        <f64>::sse_encode(self.half_hour_fee, serializer);
        <f64>::sse_encode(self.hour_fee, serializer);
        <f64>::sse_encode(self.economy_fee, serializer);
        <f64>::sse_encode(self.minimum_fee, serializer);
    }
}

impl SseEncode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <f64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::lendasat::models::RepaymentPlan {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendasat::models::RepaymentPlan::Bullet => 0,
                crate::lendasat::models::RepaymentPlan::InterestOnlyWeekly => 1,
                crate::lendasat::models::RepaymentPlan::InterestOnlyMonthly => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::lendasat::models::SettleArkPsbtResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.intent_message, serializer);
        <String>::sse_encode(self.intent_proof, serializer);
        <Vec<String>>::sse_encode(self.forfeit_psbts, serializer);
        <String>::sse_encode(self.delegate_cosigner_pk, serializer);
        <String>::sse_encode(self.user_pk, serializer);
        <Option<String>>::sse_encode(self.derivation_path, serializer);
    }
}

impl SseEncode for crate::lendaswap::SwapInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::lendaswap::SwapStatusSimple>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.direction, serializer);
        <String>::sse_encode(self.source_token, serializer);
        <String>::sse_encode(self.target_token, serializer);
        <i64>::sse_encode(self.source_amount_sats, serializer);
        <f64>::sse_encode(self.target_amount_usd, serializer);
        <String>::sse_encode(self.created_at, serializer);
        <Option<String>>::sse_encode(self.ln_invoice, serializer);
        <Option<String>>::sse_encode(self.arkade_htlc_address, serializer);
        <Option<String>>::sse_encode(self.evm_htlc_address, serializer);
        <i64>::sse_encode(self.fee_sats, serializer);
        <bool>::sse_encode(self.can_claim_gelato, serializer);
        <bool>::sse_encode(self.can_claim_vhtlc, serializer);
        <bool>::sse_encode(self.can_refund, serializer);
        <String>::sse_encode(self.detailed_status, serializer);
    }
}

impl SseEncode for crate::api::lendaswap_api::SwapQuote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.exchange_rate, serializer);
        <u64>::sse_encode(self.network_fee_sats, serializer);
        <u64>::sse_encode(self.protocol_fee_sats, serializer);
        <f64>::sse_encode(self.protocol_fee_percent, serializer);
        <u64>::sse_encode(self.min_amount_sats, serializer);
        <u64>::sse_encode(self.max_amount_sats, serializer);
    }
}

impl SseEncode for crate::lendaswap::SwapStatusSimple {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::lendaswap::SwapStatusSimple::WaitingForDeposit => 0,
                crate::lendaswap::SwapStatusSimple::Processing => 1,
                crate::lendaswap::SwapStatusSimple::Completed => 2,
                crate::lendaswap::SwapStatusSimple::Expired => 3,
                crate::lendaswap::SwapStatusSimple::Refundable => 4,
                crate::lendaswap::SwapStatusSimple::Refunded => 5,
                crate::lendaswap::SwapStatusSimple::Failed => 6,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::lendaswap_api::TradingPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::lendaswap_api::AssetInfo>::sse_encode(self.source, serializer);
        <crate::api::lendaswap_api::AssetInfo>::sse_encode(self.target, serializer);
    }
}

impl SseEncode for crate::api::ark_api::Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::ark_api::Transaction::Boarding {
                txid,
                amount_sats,
                confirmed_at,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(txid, serializer);
                <u64>::sse_encode(amount_sats, serializer);
                <Option<i64>>::sse_encode(confirmed_at, serializer);
            }
            crate::api::ark_api::Transaction::Round {
                txid,
                amount_sats,
                created_at,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(txid, serializer);
                <i64>::sse_encode(amount_sats, serializer);
                <i64>::sse_encode(created_at, serializer);
            }
            crate::api::ark_api::Transaction::Redeem {
                txid,
                amount_sats,
                is_settled,
                created_at,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(txid, serializer);
                <i64>::sse_encode(amount_sats, serializer);
                <bool>::sse_encode(is_settled, serializer);
                <i64>::sse_encode(created_at, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::mempool::TxInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
        <Option<crate::models::mempool::TxOutput>>::sse_encode(self.prevout, serializer);
        <String>::sse_encode(self.scriptsig, serializer);
        <String>::sse_encode(self.scriptsig_asm, serializer);
        <Option<Vec<String>>>::sse_encode(self.witness, serializer);
        <bool>::sse_encode(self.is_coinbase, serializer);
        <u32>::sse_encode(self.sequence, serializer);
    }
}

impl SseEncode for crate::models::mempool::TxOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.scriptpubkey, serializer);
        <String>::sse_encode(self.scriptpubkey_asm, serializer);
        <String>::sse_encode(self.scriptpubkey_type, serializer);
        <Option<String>>::sse_encode(self.scriptpubkey_address, serializer);
        <u64>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::mempool::TxStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.confirmed, serializer);
        <Option<u64>>::sse_encode(self.block_height, serializer);
        <Option<String>>::sse_encode(self.block_hash, serializer);
        <Option<u64>>::sse_encode(self.block_time, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;
