// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'api/ark_api.dart';
import 'api/bitcoin_api.dart';
import 'api/lendasat_api.dart';
import 'api/lendaswap_api.dart';
import 'api/mempool_api.dart';
import 'api/mempool_block_tracker.dart';
import 'api/mempool_ws.dart';
import 'api/moonpay_api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lendasat/models.dart';
import 'lendaswap.dart';
import 'logger.dart';
import 'models/exchange_rates.dart';
import 'models/historical_prices.dart';
import 'models/mempool.dart';
import 'models/moonpay.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


                /// Main entrypoint of the Rust API
                class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
                  @internal
                  static final instance = RustLib._();

                  RustLib._();

                  /// Initialize flutter_rust_bridge
                  static Future<void> init({
                    RustLibApi? api,
                    BaseHandler? handler,
                    ExternalLibrary? externalLibrary,
                    bool forceSameCodegenVersion = true,
                  }) async {
                    await instance.initImpl(
                      api: api,
                      handler: handler,
                      externalLibrary: externalLibrary,
                      forceSameCodegenVersion: forceSameCodegenVersion,
                    );
                  }

                  /// Initialize flutter_rust_bridge in mock mode.
                  /// No libraries for FFI are loaded.
                  static void initMock({
                    required RustLibApi api,
                  }) {
                    instance.initMockImpl(
                      api: api,
                    );
                  }

                  /// Dispose flutter_rust_bridge
                  ///
                  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
                  /// is automatically disposed when the app stops.
                  static void dispose() => instance.disposeImpl();

                  @override
                  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

                  @override
                  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

                  @override
                  Future<void> executeRustInitializers() async {
                    await api.crateApiInitApp();

                  }

                  @override
                  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

                  @override
                  String get codegenVersion => '2.11.1';

                  @override
                  int get rustContentHash => 34272460;

                  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
                    stem: 'rust_lib_ark_flutter',
                    ioDirectory: 'rust/target/release/',
                    webPrefix: 'pkg/',
                  );
                }
                

                abstract class RustLibApi extends BaseApi {
                  Future<Addresses> crateApiArkApiAddress({BigInt? amount });

Future<Balance> crateApiArkApiBalance();

String crateApiCurrencyCode({required FiatCurrency currency });

Future<ExchangeRates> crateApiFetchExchangeRates();

Future<HistoricalPriceResponse> crateApiBitcoinApiFetchHistoricalPrices({required String serverUrl , required String timeRange });

Future<Block> crateApiGetBlockByHash({required String hash });

Future<Block> crateApiMempoolApiGetBlockByHash({required String hash });

Future<List<BitcoinTransaction>> crateApiGetBlockTransactions({required String hash , required int startIndex });

Future<List<BitcoinTransaction>> crateApiMempoolApiGetBlockTransactions({required String hash , required int startIndex });

Future<List<Block>> crateApiGetBlocks();

Future<List<Block>> crateApiMempoolApiGetBlocks();

Future<List<Block>> crateApiGetBlocksAtHeight({required BigInt height });

Future<List<Block>> crateApiMempoolApiGetBlocksAtHeight({required BigInt height });

Future<FearGreedIndex> crateApiMempoolApiGetFearGreedIndex({required String apiKey });

Future<HashrateData> crateApiGetHashrateData({required String period });

Future<HashrateData> crateApiMempoolApiGetHashrateData({required String period });

Future<String> crateApiArkApiGetMnemonic({required String dataDir });

Future<RecommendedFees> crateApiGetRecommendedFees();

Future<RecommendedFees> crateApiMempoolApiGetRecommendedFees();

List<FiatCurrency> crateApiGetSupportedCurrencies();

Future<BitcoinTransaction> crateApiGetTransaction({required String txid });

Future<BitcoinTransaction> crateApiMempoolApiGetTransaction({required String txid , required String baseUrl });

Future<Info> crateApiArkApiInformation();

Future<void> crateApiInitApp();

Stream<LogEntry> crateApiInitLogging();

Future<AuthResult> crateApiLendasatApiLendasatAuthenticate();

Future<String> crateApiLendasatApiLendasatBroadcastClaimArkTx({required String contractId , required String signedArkPsbt , required List<String> signedCheckpointPsbts });

Future<String> crateApiLendasatApiLendasatBroadcastClaimTx({required String contractId , required String signedTx });

Future<String> crateApiLendasatApiLendasatBroadcastRecoverTx({required String contractId , required String signedTx });

Future<void> crateApiLendasatApiLendasatCancelContract({required String contractId });

Future<Contract> crateApiLendasatApiLendasatCreateContract({required String offerId , required double loanAmount , required int durationDays , String? borrowerLoanAddress });

Future<String> crateApiLendasatApiLendasatFinishSettleArk({required String contractId , required String signedIntentPsbt , required List<String> signedForfeitPsbts });

Future<ArkClaimPsbtResponse> crateApiLendasatApiLendasatGetClaimArkPsbt({required String contractId });

Future<ClaimPsbtResponse> crateApiLendasatApiLendasatGetClaimPsbt({required String contractId , required int feeRate });

Future<Contract> crateApiLendasatApiLendasatGetContract({required String contractId });

Future<PaginatedContractsResponse> crateApiLendasatApiLendasatGetContracts({ContractFilters? filters });

Future<String> crateApiLendasatApiLendasatGetDerivationPath();

Future<LoanOffer> crateApiLendasatApiLendasatGetOffer({required String offerId });

Future<List<LoanOffer>> crateApiLendasatApiLendasatGetOffers({OfferFilters? filters });

Future<String> crateApiLendasatApiLendasatGetPublicKey();

Future<ClaimPsbtResponse> crateApiLendasatApiLendasatGetRecoverPsbt({required String contractId , required int feeRate });

Future<SettleArkPsbtResponse> crateApiLendasatApiLendasatGetSettleArkPsbt({required String contractId });

Future<void> crateApiLendasatApiLendasatInit({required String dataDir , required String apiUrl , required String network , String? apiKey });

Future<bool> crateApiLendasatApiLendasatIsAuthenticated();

Future<bool> crateApiLendasatApiLendasatIsInitialized();

Future<void> crateApiLendasatApiLendasatLogout();

Future<void> crateApiLendasatApiLendasatMarkInstallmentPaid({required String contractId , required String installmentId , required String paymentTxid });

Future<String> crateApiLendasatApiLendasatRegister({required String email , required String name , String? inviteCode });

Future<String> crateApiLendasatApiLendasatSignPsbt({required String psbtHex , required String collateralDescriptor , required String borrowerPk });

Future<void> crateApiLendaswapApiLendaswapClaimGelato({required String swapId });

Future<String> crateApiLendaswapApiLendaswapClaimVhtlc({required String swapId });

Future<BtcToEvmSwapResult> crateApiLendaswapApiLendaswapCreateBtcToEvmSwap({required String targetEvmAddress , required double targetAmountUsd , required String targetToken , required String targetChain , String? referralCode });

Future<EvmToBtcSwapResult> crateApiLendaswapApiLendaswapCreateEvmToBtcSwap({required String targetArkAddress , required String userEvmAddress , required double sourceAmountUsd , required String sourceToken , required String sourceChain , String? referralCode });

Future<EvmToBtcSwapResult> crateApiLendaswapApiLendaswapCreateEvmToLightningSwap({required String bolt11Invoice , required String userEvmAddress , required String sourceToken , required String sourceChain , String? referralCode });

Future<void> crateApiLendaswapApiLendaswapDeleteSwap({required String swapId });

Future<List<TradingPair>> crateApiLendaswapApiLendaswapGetAssetPairs();

Future<SwapQuote> crateApiLendaswapApiLendaswapGetQuote({required String fromToken , required String toToken , required BigInt amountSats });

Future<SwapInfo> crateApiLendaswapApiLendaswapGetSwap({required String swapId });

Future<void> crateApiLendaswapApiLendaswapInit({required String dataDir , required String network , required String apiUrl , required String arkadeUrl });

bool crateApiLendaswapApiLendaswapIsInitialized();

Future<List<SwapInfo>> crateApiLendaswapApiLendaswapListSwaps();

Future<List<SwapInfo>> crateApiLendaswapApiLendaswapRecoverSwaps();

Future<String> crateApiLendaswapApiLendaswapRefundVhtlc({required String swapId , required String refundAddress });

Future<String> crateApiArkApiLoadExistingWallet({required String dataDir , required String network , required String esplora , required String server , required String boltzUrl });

Future<MoonPayEncryptedData> crateApiMoonpayEncryptData({required String serverUrl , required String data });

Future<MoonPayEncryptedData> crateApiMoonpayApiMoonpayEncryptData({required String serverUrl , required String data });

Future<MoonPayCurrencyLimits> crateApiMoonpayGetCurrencyLimits({required String serverUrl , required String baseCurrencyCode , required String paymentMethod });

Future<MoonPayCurrencyLimits> crateApiMoonpayApiMoonpayGetCurrencyLimits({required String serverUrl , required String baseCurrencyCode , required String paymentMethod });

Future<MoonPayQuote> crateApiMoonpayGetQuote({required String serverUrl });

Future<MoonPayQuote> crateApiMoonpayApiMoonpayGetQuote({required String serverUrl });

Future<String> crateApiArkApiNpub({required String dataDir });

Future<String> crateApiArkApiNsec({required String dataDir });

Future<LnPaymentResult> crateApiArkApiPayLnInvoice({required String invoice });

Future<void> crateApiLendasatApiResetLendasatState();

Future<void> crateApiArkApiResetWallet({required String dataDir });

Future<String> crateApiArkApiRestoreWallet({required String mnemonicWords , required String dataDir , required String network , required String esplora , required String server , required String boltzUrl });

Future<String> crateApiArkApiSend({required String address , required BigInt amountSats });

Future<void> crateApiArkApiSettle();

Future<String> crateApiArkApiSetupNewWallet({required String dataDir , required String network , required String esplora , required String server , required String boltzUrl });

Stream<MempoolWsMessage> crateApiSubscribeMempoolUpdates();

Stream<MempoolWsMessage> crateApiMempoolWsSubscribeMempoolUpdates();

Stream<ProjectedBlockTransactions> crateApiTrackMempoolBlock({required int blockIndex });

Stream<ProjectedBlockTransactions> crateApiMempoolBlockTrackerTrackMempoolBlock({required int blockIndex });

Future<List<Transaction>> crateApiArkApiTxHistory();

Future<PaymentReceived> crateApiArkApiWaitForPayment({String? arkAddress , String? boardingAddress , String? boltzSwapId , required BigInt timeoutSeconds });

Future<bool> crateApiArkApiWalletExists({required String dataDir });


                }
                

                class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
                  RustLibApiImpl({
                    required super.handler,
                    required super.wire,
                    required super.generalizedFrbRustBinding,
                    required super.portManager,
                  });

                  @override Future<Addresses> crateApiArkApiAddress({BigInt? amount })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_opt_box_autoadd_u_64(amount, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_addresses,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiAddressConstMeta,
            argValues: [amount],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiAddressConstMeta => const TaskConstMeta(
            debugName: "address",
            argNames: ["amount"],
        );
        

@override Future<Balance> crateApiArkApiBalance()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_balance,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiBalanceConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiBalanceConstMeta => const TaskConstMeta(
            debugName: "balance",
            argNames: [],
        );
        

@override String crateApiCurrencyCode({required FiatCurrency currency })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_fiat_currency(currency, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiCurrencyCodeConstMeta,
            argValues: [currency],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCurrencyCodeConstMeta => const TaskConstMeta(
            debugName: "currency_code",
            argNames: ["currency"],
        );
        

@override Future<ExchangeRates> crateApiFetchExchangeRates()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_exchange_rates,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiFetchExchangeRatesConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiFetchExchangeRatesConstMeta => const TaskConstMeta(
            debugName: "fetch_exchange_rates",
            argNames: [],
        );
        

@override Future<HistoricalPriceResponse> crateApiBitcoinApiFetchHistoricalPrices({required String serverUrl , required String timeRange })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(serverUrl, serializer);
sse_encode_String(timeRange, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_historical_price_response,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiBitcoinApiFetchHistoricalPricesConstMeta,
            argValues: [serverUrl, timeRange],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiBitcoinApiFetchHistoricalPricesConstMeta => const TaskConstMeta(
            debugName: "fetch_historical_prices",
            argNames: ["serverUrl", "timeRange"],
        );
        

@override Future<Block> crateApiGetBlockByHash({required String hash })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(hash, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_block,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiGetBlockByHashConstMeta,
            argValues: [hash],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetBlockByHashConstMeta => const TaskConstMeta(
            debugName: "get_block_by_hash",
            argNames: ["hash"],
        );
        

@override Future<Block> crateApiMempoolApiGetBlockByHash({required String hash })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(hash, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_block,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetBlockByHashConstMeta,
            argValues: [hash],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetBlockByHashConstMeta => const TaskConstMeta(
            debugName: "get_block_by_hash",
            argNames: ["hash"],
        );
        

@override Future<List<BitcoinTransaction>> crateApiGetBlockTransactions({required String hash , required int startIndex })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(hash, serializer);
sse_encode_u_32(startIndex, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_bitcoin_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiGetBlockTransactionsConstMeta,
            argValues: [hash, startIndex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetBlockTransactionsConstMeta => const TaskConstMeta(
            debugName: "get_block_transactions",
            argNames: ["hash", "startIndex"],
        );
        

@override Future<List<BitcoinTransaction>> crateApiMempoolApiGetBlockTransactions({required String hash , required int startIndex })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(hash, serializer);
sse_encode_u_32(startIndex, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_bitcoin_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetBlockTransactionsConstMeta,
            argValues: [hash, startIndex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetBlockTransactionsConstMeta => const TaskConstMeta(
            debugName: "get_block_transactions",
            argNames: ["hash", "startIndex"],
        );
        

@override Future<List<Block>> crateApiGetBlocks()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_block,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiGetBlocksConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetBlocksConstMeta => const TaskConstMeta(
            debugName: "get_blocks",
            argNames: [],
        );
        

@override Future<List<Block>> crateApiMempoolApiGetBlocks()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_block,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetBlocksConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetBlocksConstMeta => const TaskConstMeta(
            debugName: "get_blocks",
            argNames: [],
        );
        

@override Future<List<Block>> crateApiGetBlocksAtHeight({required BigInt height })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(height, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_block,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiGetBlocksAtHeightConstMeta,
            argValues: [height],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetBlocksAtHeightConstMeta => const TaskConstMeta(
            debugName: "get_blocks_at_height",
            argNames: ["height"],
        );
        

@override Future<List<Block>> crateApiMempoolApiGetBlocksAtHeight({required BigInt height })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(height, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_block,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetBlocksAtHeightConstMeta,
            argValues: [height],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetBlocksAtHeightConstMeta => const TaskConstMeta(
            debugName: "get_blocks_at_height",
            argNames: ["height"],
        );
        

@override Future<FearGreedIndex> crateApiMempoolApiGetFearGreedIndex({required String apiKey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(apiKey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_fear_greed_index,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetFearGreedIndexConstMeta,
            argValues: [apiKey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetFearGreedIndexConstMeta => const TaskConstMeta(
            debugName: "get_fear_greed_index",
            argNames: ["apiKey"],
        );
        

@override Future<HashrateData> crateApiGetHashrateData({required String period })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(period, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_hashrate_data,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiGetHashrateDataConstMeta,
            argValues: [period],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetHashrateDataConstMeta => const TaskConstMeta(
            debugName: "get_hashrate_data",
            argNames: ["period"],
        );
        

@override Future<HashrateData> crateApiMempoolApiGetHashrateData({required String period })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(period, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_hashrate_data,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetHashrateDataConstMeta,
            argValues: [period],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetHashrateDataConstMeta => const TaskConstMeta(
            debugName: "get_hashrate_data",
            argNames: ["period"],
        );
        

@override Future<String> crateApiArkApiGetMnemonic({required String dataDir })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiGetMnemonicConstMeta,
            argValues: [dataDir],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiGetMnemonicConstMeta => const TaskConstMeta(
            debugName: "get_mnemonic",
            argNames: ["dataDir"],
        );
        

@override Future<RecommendedFees> crateApiGetRecommendedFees()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_recommended_fees,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiGetRecommendedFeesConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetRecommendedFeesConstMeta => const TaskConstMeta(
            debugName: "get_recommended_fees",
            argNames: [],
        );
        

@override Future<RecommendedFees> crateApiMempoolApiGetRecommendedFees()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_recommended_fees,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetRecommendedFeesConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetRecommendedFeesConstMeta => const TaskConstMeta(
            debugName: "get_recommended_fees",
            argNames: [],
        );
        

@override List<FiatCurrency> crateApiGetSupportedCurrencies()  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_fiat_currency,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiGetSupportedCurrenciesConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetSupportedCurrenciesConstMeta => const TaskConstMeta(
            debugName: "get_supported_currencies",
            argNames: [],
        );
        

@override Future<BitcoinTransaction> crateApiGetTransaction({required String txid })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(txid, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bitcoin_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiGetTransactionConstMeta,
            argValues: [txid],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiGetTransactionConstMeta => const TaskConstMeta(
            debugName: "get_transaction",
            argNames: ["txid"],
        );
        

@override Future<BitcoinTransaction> crateApiMempoolApiGetTransaction({required String txid , required String baseUrl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(txid, serializer);
sse_encode_String(baseUrl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bitcoin_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolApiGetTransactionConstMeta,
            argValues: [txid, baseUrl],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMempoolApiGetTransactionConstMeta => const TaskConstMeta(
            debugName: "get_transaction",
            argNames: ["txid", "baseUrl"],
        );
        

@override Future<Info> crateApiArkApiInformation()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_info,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiInformationConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiInformationConstMeta => const TaskConstMeta(
            debugName: "information",
            argNames: [],
        );
        

@override Future<void> crateApiInitApp()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiInitAppConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiInitAppConstMeta => const TaskConstMeta(
            debugName: "init_app",
            argNames: [],
        );
        

@override Stream<LogEntry> crateApiInitLogging()  { 
            final sink = RustStreamSink<LogEntry>();
            unawaited(handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_StreamSink_log_entry_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiInitLoggingConstMeta,
            argValues: [sink],
            apiImpl: this,
        )));
            return sink.stream;
             }


        TaskConstMeta get kCrateApiInitLoggingConstMeta => const TaskConstMeta(
            debugName: "init_logging",
            argNames: ["sink"],
        );
        

@override Future<AuthResult> crateApiLendasatApiLendasatAuthenticate()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_auth_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatAuthenticateConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatAuthenticateConstMeta => const TaskConstMeta(
            debugName: "lendasat_authenticate",
            argNames: [],
        );
        

@override Future<String> crateApiLendasatApiLendasatBroadcastClaimArkTx({required String contractId , required String signedArkPsbt , required List<String> signedCheckpointPsbts })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
sse_encode_String(signedArkPsbt, serializer);
sse_encode_list_String(signedCheckpointPsbts, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatBroadcastClaimArkTxConstMeta,
            argValues: [contractId, signedArkPsbt, signedCheckpointPsbts],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatBroadcastClaimArkTxConstMeta => const TaskConstMeta(
            debugName: "lendasat_broadcast_claim_ark_tx",
            argNames: ["contractId", "signedArkPsbt", "signedCheckpointPsbts"],
        );
        

@override Future<String> crateApiLendasatApiLendasatBroadcastClaimTx({required String contractId , required String signedTx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
sse_encode_String(signedTx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatBroadcastClaimTxConstMeta,
            argValues: [contractId, signedTx],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatBroadcastClaimTxConstMeta => const TaskConstMeta(
            debugName: "lendasat_broadcast_claim_tx",
            argNames: ["contractId", "signedTx"],
        );
        

@override Future<String> crateApiLendasatApiLendasatBroadcastRecoverTx({required String contractId , required String signedTx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
sse_encode_String(signedTx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatBroadcastRecoverTxConstMeta,
            argValues: [contractId, signedTx],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatBroadcastRecoverTxConstMeta => const TaskConstMeta(
            debugName: "lendasat_broadcast_recover_tx",
            argNames: ["contractId", "signedTx"],
        );
        

@override Future<void> crateApiLendasatApiLendasatCancelContract({required String contractId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatCancelContractConstMeta,
            argValues: [contractId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatCancelContractConstMeta => const TaskConstMeta(
            debugName: "lendasat_cancel_contract",
            argNames: ["contractId"],
        );
        

@override Future<Contract> crateApiLendasatApiLendasatCreateContract({required String offerId , required double loanAmount , required int durationDays , String? borrowerLoanAddress })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(offerId, serializer);
sse_encode_f_64(loanAmount, serializer);
sse_encode_i_32(durationDays, serializer);
sse_encode_opt_String(borrowerLoanAddress, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_contract,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatCreateContractConstMeta,
            argValues: [offerId, loanAmount, durationDays, borrowerLoanAddress],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatCreateContractConstMeta => const TaskConstMeta(
            debugName: "lendasat_create_contract",
            argNames: ["offerId", "loanAmount", "durationDays", "borrowerLoanAddress"],
        );
        

@override Future<String> crateApiLendasatApiLendasatFinishSettleArk({required String contractId , required String signedIntentPsbt , required List<String> signedForfeitPsbts })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
sse_encode_String(signedIntentPsbt, serializer);
sse_encode_list_String(signedForfeitPsbts, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatFinishSettleArkConstMeta,
            argValues: [contractId, signedIntentPsbt, signedForfeitPsbts],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatFinishSettleArkConstMeta => const TaskConstMeta(
            debugName: "lendasat_finish_settle_ark",
            argNames: ["contractId", "signedIntentPsbt", "signedForfeitPsbts"],
        );
        

@override Future<ArkClaimPsbtResponse> crateApiLendasatApiLendasatGetClaimArkPsbt({required String contractId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_ark_claim_psbt_response,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetClaimArkPsbtConstMeta,
            argValues: [contractId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetClaimArkPsbtConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_claim_ark_psbt",
            argNames: ["contractId"],
        );
        

@override Future<ClaimPsbtResponse> crateApiLendasatApiLendasatGetClaimPsbt({required String contractId , required int feeRate })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
sse_encode_u_32(feeRate, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_claim_psbt_response,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetClaimPsbtConstMeta,
            argValues: [contractId, feeRate],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetClaimPsbtConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_claim_psbt",
            argNames: ["contractId", "feeRate"],
        );
        

@override Future<Contract> crateApiLendasatApiLendasatGetContract({required String contractId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_contract,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetContractConstMeta,
            argValues: [contractId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetContractConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_contract",
            argNames: ["contractId"],
        );
        

@override Future<PaginatedContractsResponse> crateApiLendasatApiLendasatGetContracts({ContractFilters? filters })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_opt_box_autoadd_contract_filters(filters, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_paginated_contracts_response,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetContractsConstMeta,
            argValues: [filters],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetContractsConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_contracts",
            argNames: ["filters"],
        );
        

@override Future<String> crateApiLendasatApiLendasatGetDerivationPath()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetDerivationPathConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetDerivationPathConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_derivation_path",
            argNames: [],
        );
        

@override Future<LoanOffer> crateApiLendasatApiLendasatGetOffer({required String offerId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(offerId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_loan_offer,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetOfferConstMeta,
            argValues: [offerId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetOfferConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_offer",
            argNames: ["offerId"],
        );
        

@override Future<List<LoanOffer>> crateApiLendasatApiLendasatGetOffers({OfferFilters? filters })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_opt_box_autoadd_offer_filters(filters, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_loan_offer,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetOffersConstMeta,
            argValues: [filters],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetOffersConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_offers",
            argNames: ["filters"],
        );
        

@override Future<String> crateApiLendasatApiLendasatGetPublicKey()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetPublicKeyConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetPublicKeyConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_public_key",
            argNames: [],
        );
        

@override Future<ClaimPsbtResponse> crateApiLendasatApiLendasatGetRecoverPsbt({required String contractId , required int feeRate })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
sse_encode_u_32(feeRate, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_claim_psbt_response,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetRecoverPsbtConstMeta,
            argValues: [contractId, feeRate],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetRecoverPsbtConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_recover_psbt",
            argNames: ["contractId", "feeRate"],
        );
        

@override Future<SettleArkPsbtResponse> crateApiLendasatApiLendasatGetSettleArkPsbt({required String contractId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_settle_ark_psbt_response,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatGetSettleArkPsbtConstMeta,
            argValues: [contractId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatGetSettleArkPsbtConstMeta => const TaskConstMeta(
            debugName: "lendasat_get_settle_ark_psbt",
            argNames: ["contractId"],
        );
        

@override Future<void> crateApiLendasatApiLendasatInit({required String dataDir , required String apiUrl , required String network , String? apiKey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
sse_encode_String(apiUrl, serializer);
sse_encode_String(network, serializer);
sse_encode_opt_String(apiKey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatInitConstMeta,
            argValues: [dataDir, apiUrl, network, apiKey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatInitConstMeta => const TaskConstMeta(
            debugName: "lendasat_init",
            argNames: ["dataDir", "apiUrl", "network", "apiKey"],
        );
        

@override Future<bool> crateApiLendasatApiLendasatIsAuthenticated()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatIsAuthenticatedConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatIsAuthenticatedConstMeta => const TaskConstMeta(
            debugName: "lendasat_is_authenticated",
            argNames: [],
        );
        

@override Future<bool> crateApiLendasatApiLendasatIsInitialized()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatIsInitializedConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatIsInitializedConstMeta => const TaskConstMeta(
            debugName: "lendasat_is_initialized",
            argNames: [],
        );
        

@override Future<void> crateApiLendasatApiLendasatLogout()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatLogoutConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatLogoutConstMeta => const TaskConstMeta(
            debugName: "lendasat_logout",
            argNames: [],
        );
        

@override Future<void> crateApiLendasatApiLendasatMarkInstallmentPaid({required String contractId , required String installmentId , required String paymentTxid })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(contractId, serializer);
sse_encode_String(installmentId, serializer);
sse_encode_String(paymentTxid, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatMarkInstallmentPaidConstMeta,
            argValues: [contractId, installmentId, paymentTxid],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatMarkInstallmentPaidConstMeta => const TaskConstMeta(
            debugName: "lendasat_mark_installment_paid",
            argNames: ["contractId", "installmentId", "paymentTxid"],
        );
        

@override Future<String> crateApiLendasatApiLendasatRegister({required String email , required String name , String? inviteCode })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(email, serializer);
sse_encode_String(name, serializer);
sse_encode_opt_String(inviteCode, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatRegisterConstMeta,
            argValues: [email, name, inviteCode],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatRegisterConstMeta => const TaskConstMeta(
            debugName: "lendasat_register",
            argNames: ["email", "name", "inviteCode"],
        );
        

@override Future<String> crateApiLendasatApiLendasatSignPsbt({required String psbtHex , required String collateralDescriptor , required String borrowerPk })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(psbtHex, serializer);
sse_encode_String(collateralDescriptor, serializer);
sse_encode_String(borrowerPk, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendasatApiLendasatSignPsbtConstMeta,
            argValues: [psbtHex, collateralDescriptor, borrowerPk],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiLendasatSignPsbtConstMeta => const TaskConstMeta(
            debugName: "lendasat_sign_psbt",
            argNames: ["psbtHex", "collateralDescriptor", "borrowerPk"],
        );
        

@override Future<void> crateApiLendaswapApiLendaswapClaimGelato({required String swapId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(swapId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapClaimGelatoConstMeta,
            argValues: [swapId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapClaimGelatoConstMeta => const TaskConstMeta(
            debugName: "lendaswap_claim_gelato",
            argNames: ["swapId"],
        );
        

@override Future<String> crateApiLendaswapApiLendaswapClaimVhtlc({required String swapId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(swapId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapClaimVhtlcConstMeta,
            argValues: [swapId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapClaimVhtlcConstMeta => const TaskConstMeta(
            debugName: "lendaswap_claim_vhtlc",
            argNames: ["swapId"],
        );
        

@override Future<BtcToEvmSwapResult> crateApiLendaswapApiLendaswapCreateBtcToEvmSwap({required String targetEvmAddress , required double targetAmountUsd , required String targetToken , required String targetChain , String? referralCode })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(targetEvmAddress, serializer);
sse_encode_f_64(targetAmountUsd, serializer);
sse_encode_String(targetToken, serializer);
sse_encode_String(targetChain, serializer);
sse_encode_opt_String(referralCode, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_btc_to_evm_swap_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapCreateBtcToEvmSwapConstMeta,
            argValues: [targetEvmAddress, targetAmountUsd, targetToken, targetChain, referralCode],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapCreateBtcToEvmSwapConstMeta => const TaskConstMeta(
            debugName: "lendaswap_create_btc_to_evm_swap",
            argNames: ["targetEvmAddress", "targetAmountUsd", "targetToken", "targetChain", "referralCode"],
        );
        

@override Future<EvmToBtcSwapResult> crateApiLendaswapApiLendaswapCreateEvmToBtcSwap({required String targetArkAddress , required String userEvmAddress , required double sourceAmountUsd , required String sourceToken , required String sourceChain , String? referralCode })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(targetArkAddress, serializer);
sse_encode_String(userEvmAddress, serializer);
sse_encode_f_64(sourceAmountUsd, serializer);
sse_encode_String(sourceToken, serializer);
sse_encode_String(sourceChain, serializer);
sse_encode_opt_String(referralCode, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 53, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_evm_to_btc_swap_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapCreateEvmToBtcSwapConstMeta,
            argValues: [targetArkAddress, userEvmAddress, sourceAmountUsd, sourceToken, sourceChain, referralCode],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapCreateEvmToBtcSwapConstMeta => const TaskConstMeta(
            debugName: "lendaswap_create_evm_to_btc_swap",
            argNames: ["targetArkAddress", "userEvmAddress", "sourceAmountUsd", "sourceToken", "sourceChain", "referralCode"],
        );
        

@override Future<EvmToBtcSwapResult> crateApiLendaswapApiLendaswapCreateEvmToLightningSwap({required String bolt11Invoice , required String userEvmAddress , required String sourceToken , required String sourceChain , String? referralCode })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(bolt11Invoice, serializer);
sse_encode_String(userEvmAddress, serializer);
sse_encode_String(sourceToken, serializer);
sse_encode_String(sourceChain, serializer);
sse_encode_opt_String(referralCode, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_evm_to_btc_swap_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapCreateEvmToLightningSwapConstMeta,
            argValues: [bolt11Invoice, userEvmAddress, sourceToken, sourceChain, referralCode],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapCreateEvmToLightningSwapConstMeta => const TaskConstMeta(
            debugName: "lendaswap_create_evm_to_lightning_swap",
            argNames: ["bolt11Invoice", "userEvmAddress", "sourceToken", "sourceChain", "referralCode"],
        );
        

@override Future<void> crateApiLendaswapApiLendaswapDeleteSwap({required String swapId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(swapId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapDeleteSwapConstMeta,
            argValues: [swapId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapDeleteSwapConstMeta => const TaskConstMeta(
            debugName: "lendaswap_delete_swap",
            argNames: ["swapId"],
        );
        

@override Future<List<TradingPair>> crateApiLendaswapApiLendaswapGetAssetPairs()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 56, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_trading_pair,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapGetAssetPairsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapGetAssetPairsConstMeta => const TaskConstMeta(
            debugName: "lendaswap_get_asset_pairs",
            argNames: [],
        );
        

@override Future<SwapQuote> crateApiLendaswapApiLendaswapGetQuote({required String fromToken , required String toToken , required BigInt amountSats })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(fromToken, serializer);
sse_encode_String(toToken, serializer);
sse_encode_u_64(amountSats, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 57, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_swap_quote,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapGetQuoteConstMeta,
            argValues: [fromToken, toToken, amountSats],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapGetQuoteConstMeta => const TaskConstMeta(
            debugName: "lendaswap_get_quote",
            argNames: ["fromToken", "toToken", "amountSats"],
        );
        

@override Future<SwapInfo> crateApiLendaswapApiLendaswapGetSwap({required String swapId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(swapId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_swap_info,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapGetSwapConstMeta,
            argValues: [swapId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapGetSwapConstMeta => const TaskConstMeta(
            debugName: "lendaswap_get_swap",
            argNames: ["swapId"],
        );
        

@override Future<void> crateApiLendaswapApiLendaswapInit({required String dataDir , required String network , required String apiUrl , required String arkadeUrl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
sse_encode_String(network, serializer);
sse_encode_String(apiUrl, serializer);
sse_encode_String(arkadeUrl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 59, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapInitConstMeta,
            argValues: [dataDir, network, apiUrl, arkadeUrl],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapInitConstMeta => const TaskConstMeta(
            debugName: "lendaswap_init",
            argNames: ["dataDir", "network", "apiUrl", "arkadeUrl"],
        );
        

@override bool crateApiLendaswapApiLendaswapIsInitialized()  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 60)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapIsInitializedConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapIsInitializedConstMeta => const TaskConstMeta(
            debugName: "lendaswap_is_initialized",
            argNames: [],
        );
        

@override Future<List<SwapInfo>> crateApiLendaswapApiLendaswapListSwaps()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_swap_info,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapListSwapsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapListSwapsConstMeta => const TaskConstMeta(
            debugName: "lendaswap_list_swaps",
            argNames: [],
        );
        

@override Future<List<SwapInfo>> crateApiLendaswapApiLendaswapRecoverSwaps()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 62, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_swap_info,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapRecoverSwapsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapRecoverSwapsConstMeta => const TaskConstMeta(
            debugName: "lendaswap_recover_swaps",
            argNames: [],
        );
        

@override Future<String> crateApiLendaswapApiLendaswapRefundVhtlc({required String swapId , required String refundAddress })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(swapId, serializer);
sse_encode_String(refundAddress, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiLendaswapApiLendaswapRefundVhtlcConstMeta,
            argValues: [swapId, refundAddress],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendaswapApiLendaswapRefundVhtlcConstMeta => const TaskConstMeta(
            debugName: "lendaswap_refund_vhtlc",
            argNames: ["swapId", "refundAddress"],
        );
        

@override Future<String> crateApiArkApiLoadExistingWallet({required String dataDir , required String network , required String esplora , required String server , required String boltzUrl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
sse_encode_String(network, serializer);
sse_encode_String(esplora, serializer);
sse_encode_String(server, serializer);
sse_encode_String(boltzUrl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiLoadExistingWalletConstMeta,
            argValues: [dataDir, network, esplora, server, boltzUrl],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiLoadExistingWalletConstMeta => const TaskConstMeta(
            debugName: "load_existing_wallet",
            argNames: ["dataDir", "network", "esplora", "server", "boltzUrl"],
        );
        

@override Future<MoonPayEncryptedData> crateApiMoonpayEncryptData({required String serverUrl , required String data })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(serverUrl, serializer);
sse_encode_String(data, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_moon_pay_encrypted_data,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMoonpayEncryptDataConstMeta,
            argValues: [serverUrl, data],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMoonpayEncryptDataConstMeta => const TaskConstMeta(
            debugName: "moonpay_encrypt_data",
            argNames: ["serverUrl", "data"],
        );
        

@override Future<MoonPayEncryptedData> crateApiMoonpayApiMoonpayEncryptData({required String serverUrl , required String data })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(serverUrl, serializer);
sse_encode_String(data, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_moon_pay_encrypted_data,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMoonpayApiMoonpayEncryptDataConstMeta,
            argValues: [serverUrl, data],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMoonpayApiMoonpayEncryptDataConstMeta => const TaskConstMeta(
            debugName: "moonpay_encrypt_data",
            argNames: ["serverUrl", "data"],
        );
        

@override Future<MoonPayCurrencyLimits> crateApiMoonpayGetCurrencyLimits({required String serverUrl , required String baseCurrencyCode , required String paymentMethod })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(serverUrl, serializer);
sse_encode_String(baseCurrencyCode, serializer);
sse_encode_String(paymentMethod, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_moon_pay_currency_limits,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMoonpayGetCurrencyLimitsConstMeta,
            argValues: [serverUrl, baseCurrencyCode, paymentMethod],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMoonpayGetCurrencyLimitsConstMeta => const TaskConstMeta(
            debugName: "moonpay_get_currency_limits",
            argNames: ["serverUrl", "baseCurrencyCode", "paymentMethod"],
        );
        

@override Future<MoonPayCurrencyLimits> crateApiMoonpayApiMoonpayGetCurrencyLimits({required String serverUrl , required String baseCurrencyCode , required String paymentMethod })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(serverUrl, serializer);
sse_encode_String(baseCurrencyCode, serializer);
sse_encode_String(paymentMethod, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_moon_pay_currency_limits,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMoonpayApiMoonpayGetCurrencyLimitsConstMeta,
            argValues: [serverUrl, baseCurrencyCode, paymentMethod],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMoonpayApiMoonpayGetCurrencyLimitsConstMeta => const TaskConstMeta(
            debugName: "moonpay_get_currency_limits",
            argNames: ["serverUrl", "baseCurrencyCode", "paymentMethod"],
        );
        

@override Future<MoonPayQuote> crateApiMoonpayGetQuote({required String serverUrl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(serverUrl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 69, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_moon_pay_quote,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMoonpayGetQuoteConstMeta,
            argValues: [serverUrl],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMoonpayGetQuoteConstMeta => const TaskConstMeta(
            debugName: "moonpay_get_quote",
            argNames: ["serverUrl"],
        );
        

@override Future<MoonPayQuote> crateApiMoonpayApiMoonpayGetQuote({required String serverUrl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(serverUrl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 70, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_moon_pay_quote,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMoonpayApiMoonpayGetQuoteConstMeta,
            argValues: [serverUrl],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMoonpayApiMoonpayGetQuoteConstMeta => const TaskConstMeta(
            debugName: "moonpay_get_quote",
            argNames: ["serverUrl"],
        );
        

@override Future<String> crateApiArkApiNpub({required String dataDir })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiNpubConstMeta,
            argValues: [dataDir],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiNpubConstMeta => const TaskConstMeta(
            debugName: "npub",
            argNames: ["dataDir"],
        );
        

@override Future<String> crateApiArkApiNsec({required String dataDir })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 72, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiNsecConstMeta,
            argValues: [dataDir],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiNsecConstMeta => const TaskConstMeta(
            debugName: "nsec",
            argNames: ["dataDir"],
        );
        

@override Future<LnPaymentResult> crateApiArkApiPayLnInvoice({required String invoice })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(invoice, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_ln_payment_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiPayLnInvoiceConstMeta,
            argValues: [invoice],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiPayLnInvoiceConstMeta => const TaskConstMeta(
            debugName: "pay_ln_invoice",
            argNames: ["invoice"],
        );
        

@override Future<void> crateApiLendasatApiResetLendasatState()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 74, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiLendasatApiResetLendasatStateConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiLendasatApiResetLendasatStateConstMeta => const TaskConstMeta(
            debugName: "reset_lendasat_state",
            argNames: [],
        );
        

@override Future<void> crateApiArkApiResetWallet({required String dataDir })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 75, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiResetWalletConstMeta,
            argValues: [dataDir],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiResetWalletConstMeta => const TaskConstMeta(
            debugName: "reset_wallet",
            argNames: ["dataDir"],
        );
        

@override Future<String> crateApiArkApiRestoreWallet({required String mnemonicWords , required String dataDir , required String network , required String esplora , required String server , required String boltzUrl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mnemonicWords, serializer);
sse_encode_String(dataDir, serializer);
sse_encode_String(network, serializer);
sse_encode_String(esplora, serializer);
sse_encode_String(server, serializer);
sse_encode_String(boltzUrl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 76, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiRestoreWalletConstMeta,
            argValues: [mnemonicWords, dataDir, network, esplora, server, boltzUrl],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiRestoreWalletConstMeta => const TaskConstMeta(
            debugName: "restore_wallet",
            argNames: ["mnemonicWords", "dataDir", "network", "esplora", "server", "boltzUrl"],
        );
        

@override Future<String> crateApiArkApiSend({required String address , required BigInt amountSats })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(address, serializer);
sse_encode_u_64(amountSats, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 77, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiSendConstMeta,
            argValues: [address, amountSats],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiSendConstMeta => const TaskConstMeta(
            debugName: "send",
            argNames: ["address", "amountSats"],
        );
        

@override Future<void> crateApiArkApiSettle()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 78, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiSettleConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiSettleConstMeta => const TaskConstMeta(
            debugName: "settle",
            argNames: [],
        );
        

@override Future<String> crateApiArkApiSetupNewWallet({required String dataDir , required String network , required String esplora , required String server , required String boltzUrl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
sse_encode_String(network, serializer);
sse_encode_String(esplora, serializer);
sse_encode_String(server, serializer);
sse_encode_String(boltzUrl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiSetupNewWalletConstMeta,
            argValues: [dataDir, network, esplora, server, boltzUrl],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiSetupNewWalletConstMeta => const TaskConstMeta(
            debugName: "setup_new_wallet",
            argNames: ["dataDir", "network", "esplora", "server", "boltzUrl"],
        );
        

@override Stream<MempoolWsMessage> crateApiSubscribeMempoolUpdates()  { 
            final sink = RustStreamSink<MempoolWsMessage>();
            unawaited(handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_StreamSink_mempool_ws_message_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 80, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSubscribeMempoolUpdatesConstMeta,
            argValues: [sink],
            apiImpl: this,
        )));
            return sink.stream;
             }


        TaskConstMeta get kCrateApiSubscribeMempoolUpdatesConstMeta => const TaskConstMeta(
            debugName: "subscribe_mempool_updates",
            argNames: ["sink"],
        );
        

@override Stream<MempoolWsMessage> crateApiMempoolWsSubscribeMempoolUpdates()  { 
            final sink = RustStreamSink<MempoolWsMessage>();
            unawaited(handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_StreamSink_mempool_ws_message_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 81, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolWsSubscribeMempoolUpdatesConstMeta,
            argValues: [sink],
            apiImpl: this,
        )));
            return sink.stream;
             }


        TaskConstMeta get kCrateApiMempoolWsSubscribeMempoolUpdatesConstMeta => const TaskConstMeta(
            debugName: "subscribe_mempool_updates",
            argNames: ["sink"],
        );
        

@override Stream<ProjectedBlockTransactions> crateApiTrackMempoolBlock({required int blockIndex })  { 
            final sink = RustStreamSink<ProjectedBlockTransactions>();
            unawaited(handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_32(blockIndex, serializer);
sse_encode_StreamSink_projected_block_transactions_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 82, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiTrackMempoolBlockConstMeta,
            argValues: [blockIndex, sink],
            apiImpl: this,
        )));
            return sink.stream;
             }


        TaskConstMeta get kCrateApiTrackMempoolBlockConstMeta => const TaskConstMeta(
            debugName: "track_mempool_block",
            argNames: ["blockIndex", "sink"],
        );
        

@override Stream<ProjectedBlockTransactions> crateApiMempoolBlockTrackerTrackMempoolBlock({required int blockIndex })  { 
            final sink = RustStreamSink<ProjectedBlockTransactions>();
            unawaited(handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_32(blockIndex, serializer);
sse_encode_StreamSink_projected_block_transactions_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 83, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMempoolBlockTrackerTrackMempoolBlockConstMeta,
            argValues: [blockIndex, sink],
            apiImpl: this,
        )));
            return sink.stream;
             }


        TaskConstMeta get kCrateApiMempoolBlockTrackerTrackMempoolBlockConstMeta => const TaskConstMeta(
            debugName: "track_mempool_block",
            argNames: ["blockIndex", "sink"],
        );
        

@override Future<List<Transaction>> crateApiArkApiTxHistory()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 84, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiTxHistoryConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiTxHistoryConstMeta => const TaskConstMeta(
            debugName: "tx_history",
            argNames: [],
        );
        

@override Future<PaymentReceived> crateApiArkApiWaitForPayment({String? arkAddress , String? boardingAddress , String? boltzSwapId , required BigInt timeoutSeconds })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_opt_String(arkAddress, serializer);
sse_encode_opt_String(boardingAddress, serializer);
sse_encode_opt_String(boltzSwapId, serializer);
sse_encode_u_64(timeoutSeconds, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 85, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_payment_received,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiWaitForPaymentConstMeta,
            argValues: [arkAddress, boardingAddress, boltzSwapId, timeoutSeconds],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiWaitForPaymentConstMeta => const TaskConstMeta(
            debugName: "wait_for_payment",
            argNames: ["arkAddress", "boardingAddress", "boltzSwapId", "timeoutSeconds"],
        );
        

@override Future<bool> crateApiArkApiWalletExists({required String dataDir })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dataDir, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 86, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiArkApiWalletExistsConstMeta,
            argValues: [dataDir],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiArkApiWalletExistsConstMeta => const TaskConstMeta(
            debugName: "wallet_exists",
            argNames: ["dataDir"],
        );
        



                  @protected AnyhowException dco_decode_AnyhowException(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AnyhowException(raw as String); }

@protected Map<String, double> dco_decode_Map_String_f_64_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_f_64(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Sse(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected RustStreamSink<MempoolWsMessage> dco_decode_StreamSink_mempool_ws_message_Sse(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected RustStreamSink<ProjectedBlockTransactions> dco_decode_StreamSink_projected_block_transactions_Sse(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected String dco_decode_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as String; }

@protected Addresses dco_decode_addresses(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return Addresses(boarding: dco_decode_String(arr[0]),
offchain: dco_decode_String(arr[1]),
bip21: dco_decode_String(arr[2]),
lightning: dco_decode_opt_box_autoadd_boltz_swap(arr[3]),); }

@protected ArkClaimPsbtResponse dco_decode_ark_claim_psbt_response(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return ArkClaimPsbtResponse(arkPsbt: dco_decode_String(arr[0]),
checkpointPsbts: dco_decode_list_String(arr[1]),); }

@protected AssetInfo dco_decode_asset_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return AssetInfo(tokenId: dco_decode_String(arr[0]),
symbol: dco_decode_String(arr[1]),
name: dco_decode_String(arr[2]),
chain: dco_decode_String(arr[3]),
decimals: dco_decode_u_8(arr[4]),); }

@protected AuthResult dco_decode_auth_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
switch (raw[0]) {
                case 0: return AuthResult_Success(userId: dco_decode_String(raw[1]),userName: dco_decode_String(raw[2]),userEmail: dco_decode_opt_String(raw[3]),);
case 1: return AuthResult_NeedsRegistration(pubkey: dco_decode_String(raw[1]),);
                default: throw Exception("unreachable");
            } }

@protected Balance dco_decode_balance(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
                return Balance(offchain: dco_decode_offchain_balance(arr[0]),); }

@protected BitcoinTransaction dco_decode_bitcoin_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 10) throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
                return BitcoinTransaction(txid: dco_decode_String(arr[0]),
version: dco_decode_u_32(arr[1]),
locktime: dco_decode_u_32(arr[2]),
size: dco_decode_u_32(arr[3]),
weight: dco_decode_u_32(arr[4]),
fee: dco_decode_u_64(arr[5]),
sigops: dco_decode_opt_box_autoadd_u_32(arr[6]),
status: dco_decode_tx_status(arr[7]),
vin: dco_decode_list_tx_input(arr[8]),
vout: dco_decode_list_tx_output(arr[9]),); }

@protected Block dco_decode_block(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 15) throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
                return Block(id: dco_decode_String(arr[0]),
height: dco_decode_u_64(arr[1]),
version: dco_decode_u_32(arr[2]),
timestamp: dco_decode_u_64(arr[3]),
bits: dco_decode_u_32(arr[4]),
nonce: dco_decode_u_32(arr[5]),
difficulty: dco_decode_f_64(arr[6]),
merkleRoot: dco_decode_String(arr[7]),
txCount: dco_decode_u_32(arr[8]),
size: dco_decode_u_64(arr[9]),
weight: dco_decode_u_64(arr[10]),
previousblockhash: dco_decode_opt_String(arr[11]),
mediantime: dco_decode_opt_box_autoadd_u_64(arr[12]),
stale: dco_decode_opt_box_autoadd_bool(arr[13]),
extras: dco_decode_opt_box_autoadd_block_extras(arr[14]),); }

@protected BlockExtras dco_decode_block_extras(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 8) throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
                return BlockExtras(medianFee: dco_decode_opt_box_autoadd_f_64(arr[0]),
totalFees: dco_decode_opt_box_autoadd_u_64(arr[1]),
avgFee: dco_decode_opt_box_autoadd_f_64(arr[2]),
avgFeeRate: dco_decode_opt_box_autoadd_f_64(arr[3]),
reward: dco_decode_opt_box_autoadd_u_64(arr[4]),
pool: dco_decode_opt_box_autoadd_mining_pool(arr[5]),
matchRate: dco_decode_opt_box_autoadd_f_64(arr[6]),
similarity: dco_decode_opt_box_autoadd_f_64(arr[7]),); }

@protected BoltzSwap dco_decode_boltz_swap(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return BoltzSwap(swapId: dco_decode_String(arr[0]),
amountSats: dco_decode_u_64(arr[1]),
invoice: dco_decode_String(arr[2]),); }

@protected bool dco_decode_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as bool; }

@protected BlockExtras dco_decode_box_autoadd_block_extras(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_block_extras(raw); }

@protected BoltzSwap dco_decode_box_autoadd_boltz_swap(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_boltz_swap(raw); }

@protected bool dco_decode_box_autoadd_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as bool; }

@protected ContractFilters dco_decode_box_autoadd_contract_filters(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_contract_filters(raw); }

@protected Conversions dco_decode_box_autoadd_conversions(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_conversions(raw); }

@protected DifficultyAdjustment dco_decode_box_autoadd_difficulty_adjustment(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_difficulty_adjustment(raw); }

@protected double dco_decode_box_autoadd_f_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as double; }

@protected FearGreedData dco_decode_box_autoadd_fear_greed_data(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_fear_greed_data(raw); }

@protected FearGreedLastUpdated dco_decode_box_autoadd_fear_greed_last_updated(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_fear_greed_last_updated(raw); }

@protected FearGreedValue dco_decode_box_autoadd_fear_greed_value(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_fear_greed_value(raw); }

@protected int dco_decode_box_autoadd_i_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_i_64(raw); }

@protected MiningPool dco_decode_box_autoadd_mining_pool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_mining_pool(raw); }

@protected OfferFilters dco_decode_box_autoadd_offer_filters(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_offer_filters(raw); }

@protected RecommendedFees dco_decode_box_autoadd_recommended_fees(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_recommended_fees(raw); }

@protected TxOutput dco_decode_box_autoadd_tx_output(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_tx_output(raw); }

@protected int dco_decode_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected BigInt dco_decode_box_autoadd_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_u_64(raw); }

@protected BtcToEvmSwapResult dco_decode_btc_to_evm_swap_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
                return BtcToEvmSwapResult(swapId: dco_decode_String(arr[0]),
lnInvoice: dco_decode_String(arr[1]),
arkadeHtlcAddress: dco_decode_String(arr[2]),
satsToSend: dco_decode_i_64(arr[3]),
targetAmountUsd: dco_decode_f_64(arr[4]),
feeSats: dco_decode_i_64(arr[5]),); }

@protected ClaimPsbtResponse dco_decode_claim_psbt_response(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return ClaimPsbtResponse(psbt: dco_decode_String(arr[0]),
collateralDescriptor: dco_decode_String(arr[1]),
borrowerPk: dco_decode_String(arr[2]),); }

@protected CollateralAsset dco_decode_collateral_asset(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CollateralAsset.values[raw as int]; }

@protected Contract dco_decode_contract(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 40) throw Exception('unexpected arr length: expect 40 but see ${arr.length}');
                return Contract(id: dco_decode_String(arr[0]),
status: dco_decode_contract_status(arr[1]),
lender: dco_decode_lender_stats(arr[2]),
lenderPk: dco_decode_String(arr[3]),
borrowerPk: dco_decode_String(arr[4]),
borrowerBtcAddress: dco_decode_String(arr[5]),
borrowerDerivationPath: dco_decode_opt_String(arr[6]),
borrowerLoanAddress: dco_decode_opt_String(arr[7]),
loanAsset: dco_decode_loan_asset(arr[8]),
collateralAsset: dco_decode_collateral_asset(arr[9]),
loanAmount: dco_decode_f_64(arr[10]),
interest: dco_decode_f_64(arr[11]),
interestRate: dco_decode_f_64(arr[12]),
durationDays: dco_decode_i_32(arr[13]),
expiry: dco_decode_String(arr[14]),
collateralSats: dco_decode_i_64(arr[15]),
initialCollateralSats: dco_decode_i_64(arr[16]),
depositedSats: dco_decode_i_64(arr[17]),
initialLtv: dco_decode_f_64(arr[18]),
liquidationPrice: dco_decode_f_64(arr[19]),
ltvThresholdMarginCall1: dco_decode_f_64(arr[20]),
ltvThresholdMarginCall2: dco_decode_f_64(arr[21]),
ltvThresholdLiquidation: dco_decode_f_64(arr[22]),
balanceOutstanding: dco_decode_f_64(arr[23]),
contractAddress: dco_decode_opt_String(arr[24]),
collateralScript: dco_decode_opt_String(arr[25]),
loanRepaymentAddress: dco_decode_opt_String(arr[26]),
btcLoanRepaymentAddress: dco_decode_opt_String(arr[27]),
originationFeeSats: dco_decode_i_64(arr[28]),
installments: dco_decode_list_installment(arr[29]),
transactions: dco_decode_list_loan_transaction(arr[30]),
canExtend: dco_decode_bool(arr[31]),
extensionInterestRate: dco_decode_opt_box_autoadd_f_64(arr[32]),
extensionMaxDurationDays: dco_decode_i_32(arr[33]),
extendsContract: dco_decode_opt_String(arr[34]),
extendedByContract: dco_decode_opt_String(arr[35]),
clientContractId: dco_decode_opt_String(arr[36]),
requiresArkSettlement: dco_decode_opt_box_autoadd_bool(arr[37]),
createdAt: dco_decode_String(arr[38]),
updatedAt: dco_decode_String(arr[39]),); }

@protected ContractFilters dco_decode_contract_filters(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return ContractFilters(page: dco_decode_opt_box_autoadd_i_32(arr[0]),
limit: dco_decode_opt_box_autoadd_i_32(arr[1]),
status: dco_decode_opt_list_contract_status(arr[2]),
sortBy: dco_decode_opt_String(arr[3]),
sortOrder: dco_decode_opt_String(arr[4]),); }

@protected ContractStatus dco_decode_contract_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ContractStatus.values[raw as int]; }

@protected Conversions dco_decode_conversions(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return Conversions(time: dco_decode_u_64(arr[0]),
usd: dco_decode_f_64(arr[1]),
eur: dco_decode_opt_box_autoadd_f_64(arr[2]),); }

@protected CurrencyInfo dco_decode_currency_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return CurrencyInfo(code: dco_decode_String(arr[0]),
minBuyAmount: dco_decode_f_64(arr[1]),
maxBuyAmount: dco_decode_f_64(arr[2]),); }

@protected DifficultyAdjustment dco_decode_difficulty_adjustment(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 12) throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
                return DifficultyAdjustment(progressPercent: dco_decode_f_64(arr[0]),
difficultyChange: dco_decode_f_64(arr[1]),
estimatedRetargetDate: dco_decode_u_64(arr[2]),
remainingBlocks: dco_decode_u_32(arr[3]),
remainingTime: dco_decode_u_64(arr[4]),
previousRetarget: dco_decode_opt_box_autoadd_f_64(arr[5]),
previousTime: dco_decode_opt_box_autoadd_u_64(arr[6]),
nextRetargetHeight: dco_decode_u_64(arr[7]),
timeAvg: dco_decode_u_64(arr[8]),
adjustedTimeAvg: dco_decode_opt_box_autoadd_u_64(arr[9]),
timeOffset: dco_decode_i_64(arr[10]),
expectedBlocks: dco_decode_f_64(arr[11]),); }

@protected DifficultyPoint dco_decode_difficulty_point(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return DifficultyPoint(timestamp: dco_decode_opt_box_autoadd_u_64(arr[0]),
difficulty: dco_decode_opt_box_autoadd_f_64(arr[1]),
height: dco_decode_opt_box_autoadd_u_64(arr[2]),); }

@protected EvmToBtcSwapResult dco_decode_evm_to_btc_swap_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
                return EvmToBtcSwapResult(swapId: dco_decode_String(arr[0]),
evmHtlcAddress: dco_decode_String(arr[1]),
sourceAmountUsd: dco_decode_f_64(arr[2]),
satsToReceive: dco_decode_i_64(arr[3]),
feeSats: dco_decode_i_64(arr[4]),
sourceTokenAddress: dco_decode_String(arr[5]),
createSwapTx: dco_decode_opt_String(arr[6]),
approveTx: dco_decode_opt_String(arr[7]),
gelatoForwarderAddress: dco_decode_opt_String(arr[8]),
gelatoUserNonce: dco_decode_opt_String(arr[9]),
gelatoUserDeadline: dco_decode_opt_String(arr[10]),); }

@protected ExchangeRates dco_decode_exchange_rates(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return ExchangeRates(base: dco_decode_String(arr[0]),
rates: dco_decode_Map_String_f_64_None(arr[1]),
timestamp: dco_decode_i_64(arr[2]),); }

@protected double dco_decode_f_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as double; }

@protected FearGreedData dco_decode_fear_greed_data(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return FearGreedData(now: dco_decode_opt_box_autoadd_fear_greed_value(arr[0]),
previousClose: dco_decode_opt_box_autoadd_fear_greed_value(arr[1]),
oneWeekAgo: dco_decode_opt_box_autoadd_fear_greed_value(arr[2]),
oneMonthAgo: dco_decode_opt_box_autoadd_fear_greed_value(arr[3]),
oneYearAgo: dco_decode_opt_box_autoadd_fear_greed_value(arr[4]),); }

@protected FearGreedIndex dco_decode_fear_greed_index(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return FearGreedIndex(lastUpdated: dco_decode_opt_box_autoadd_fear_greed_last_updated(arr[0]),
fgi: dco_decode_opt_box_autoadd_fear_greed_data(arr[1]),); }

@protected FearGreedLastUpdated dco_decode_fear_greed_last_updated(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return FearGreedLastUpdated(epochUnixSeconds: dco_decode_opt_box_autoadd_i_64(arr[0]),
humanDate: dco_decode_opt_String(arr[1]),); }

@protected FearGreedValue dco_decode_fear_greed_value(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return FearGreedValue(value: dco_decode_opt_box_autoadd_i_32(arr[0]),
valueText: dco_decode_opt_String(arr[1]),); }

@protected FiatCurrency dco_decode_fiat_currency(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FiatCurrency.values[raw as int]; }

@protected HashrateData dco_decode_hashrate_data(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return HashrateData(currentHashrate: dco_decode_opt_box_autoadd_f_64(arr[0]),
currentDifficulty: dco_decode_opt_box_autoadd_f_64(arr[1]),
hashrates: dco_decode_list_hashrate_point(arr[2]),
difficulty: dco_decode_list_difficulty_point(arr[3]),); }

@protected HashratePoint dco_decode_hashrate_point(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return HashratePoint(timestamp: dco_decode_u_64(arr[0]),
avgHashrate: dco_decode_f_64(arr[1]),); }

@protected HistoricalPriceData dco_decode_historical_price_data(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return HistoricalPriceData(timestamp: dco_decode_String(arr[0]),
price: dco_decode_String(arr[1]),); }

@protected HistoricalPriceResponse dco_decode_historical_price_response(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
                return HistoricalPriceResponse(prices: dco_decode_list_historical_price_data(arr[0]),); }

@protected int dco_decode_i_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected PlatformInt64 dco_decode_i_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeI64(raw); }

@protected Info dco_decode_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return Info(serverPk: dco_decode_String(arr[0]),
network: dco_decode_String(arr[1]),); }

@protected Installment dco_decode_installment(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
                return Installment(id: dco_decode_String(arr[0]),
dueDate: dco_decode_String(arr[1]),
principal: dco_decode_f_64(arr[2]),
interest: dco_decode_f_64(arr[3]),
status: dco_decode_installment_status(arr[4]),
paidDate: dco_decode_opt_String(arr[5]),
paymentId: dco_decode_opt_String(arr[6]),); }

@protected InstallmentStatus dco_decode_installment_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return InstallmentStatus.values[raw as int]; }

@protected LenderStats dco_decode_lender_stats(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
                return LenderStats(id: dco_decode_String(arr[0]),
name: dco_decode_String(arr[1]),
joinedAt: dco_decode_String(arr[2]),
successfulContracts: dco_decode_i_32(arr[3]),
vetted: dco_decode_bool(arr[4]),
timezone: dco_decode_opt_String(arr[5]),); }

@protected List<String> dco_decode_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_String).toList(); }

@protected List<BitcoinTransaction> dco_decode_list_bitcoin_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_bitcoin_transaction).toList(); }

@protected List<Block> dco_decode_list_block(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_block).toList(); }

@protected List<Contract> dco_decode_list_contract(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_contract).toList(); }

@protected List<ContractStatus> dco_decode_list_contract_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_contract_status).toList(); }

@protected List<DifficultyPoint> dco_decode_list_difficulty_point(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_difficulty_point).toList(); }

@protected List<FiatCurrency> dco_decode_list_fiat_currency(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_fiat_currency).toList(); }

@protected List<HashratePoint> dco_decode_list_hashrate_point(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_hashrate_point).toList(); }

@protected List<HistoricalPriceData> dco_decode_list_historical_price_data(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_historical_price_data).toList(); }

@protected List<Installment> dco_decode_list_installment(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_installment).toList(); }

@protected List<LoanOffer> dco_decode_list_loan_offer(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_loan_offer).toList(); }

@protected List<LoanTransaction> dco_decode_list_loan_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_loan_transaction).toList(); }

@protected List<MempoolBlock> dco_decode_list_mempool_block(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_mempool_block).toList(); }

@protected List<OriginationFee> dco_decode_list_origination_fee(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_origination_fee).toList(); }

@protected Float64List dco_decode_list_prim_f_64_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Float64List; }

@protected Uint8List dco_decode_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Uint8List; }

@protected List<ProjectedTransaction> dco_decode_list_projected_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_projected_transaction).toList(); }

@protected List<(String,double)> dco_decode_list_record_string_f_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_f_64).toList(); }

@protected List<SwapInfo> dco_decode_list_swap_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_swap_info).toList(); }

@protected List<TradingPair> dco_decode_list_trading_pair(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_trading_pair).toList(); }

@protected List<Transaction> dco_decode_list_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_transaction).toList(); }

@protected List<TxInput> dco_decode_list_tx_input(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_tx_input).toList(); }

@protected List<TxOutput> dco_decode_list_tx_output(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_tx_output).toList(); }

@protected LnPaymentResult dco_decode_ln_payment_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return LnPaymentResult(swapId: dco_decode_String(arr[0]),
txid: dco_decode_String(arr[1]),
amountSats: dco_decode_u_64(arr[2]),); }

@protected LoanAsset dco_decode_loan_asset(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LoanAsset.values[raw as int]; }

@protected LoanOffer dco_decode_loan_offer(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 18) throw Exception('unexpected arr length: expect 18 but see ${arr.length}');
                return LoanOffer(id: dco_decode_String(arr[0]),
name: dco_decode_String(arr[1]),
lender: dco_decode_lender_stats(arr[2]),
lenderPk: dco_decode_String(arr[3]),
loanAsset: dco_decode_loan_asset(arr[4]),
collateralAsset: dco_decode_collateral_asset(arr[5]),
loanAmountMin: dco_decode_f_64(arr[6]),
loanAmountMax: dco_decode_f_64(arr[7]),
durationDaysMin: dco_decode_i_32(arr[8]),
durationDaysMax: dco_decode_i_32(arr[9]),
interestRate: dco_decode_f_64(arr[10]),
minLtv: dco_decode_f_64(arr[11]),
loanPayout: dco_decode_loan_payout(arr[12]),
loanRepaymentAddress: dco_decode_String(arr[13]),
originationFee: dco_decode_list_origination_fee(arr[14]),
repaymentPlan: dco_decode_repayment_plan(arr[15]),
status: dco_decode_loan_offer_status(arr[16]),
kycLink: dco_decode_opt_String(arr[17]),); }

@protected LoanOfferStatus dco_decode_loan_offer_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LoanOfferStatus.values[raw as int]; }

@protected LoanPayout dco_decode_loan_payout(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LoanPayout.values[raw as int]; }

@protected LoanTransaction dco_decode_loan_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return LoanTransaction(id: dco_decode_i_64(arr[0]),
contractId: dco_decode_String(arr[1]),
transactionType: dco_decode_String(arr[2]),
txid: dco_decode_String(arr[3]),
timestamp: dco_decode_String(arr[4]),); }

@protected LogEntry dco_decode_log_entry(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
                return LogEntry(msg: dco_decode_String(arr[0]),
target: dco_decode_String(arr[1]),
level: dco_decode_String(arr[2]),
file: dco_decode_String(arr[3]),
line: dco_decode_String(arr[4]),
modulePath: dco_decode_String(arr[5]),
data: dco_decode_String(arr[6]),); }

@protected MempoolBlock dco_decode_mempool_block(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
                return MempoolBlock(blockSize: dco_decode_u_64(arr[0]),
blockVsize: dco_decode_f_64(arr[1]),
nTx: dco_decode_u_32(arr[2]),
totalFees: dco_decode_u_64(arr[3]),
medianFee: dco_decode_f_64(arr[4]),
feeRange: dco_decode_list_prim_f_64_strict(arr[5]),); }

@protected MempoolWsMessage dco_decode_mempool_ws_message(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return MempoolWsMessage(mempoolBlocks: dco_decode_opt_list_mempool_block(arr[0]),
blocks: dco_decode_opt_list_block(arr[1]),
conversions: dco_decode_opt_box_autoadd_conversions(arr[2]),
fees: dco_decode_opt_box_autoadd_recommended_fees(arr[3]),
da: dco_decode_opt_box_autoadd_difficulty_adjustment(arr[4]),); }

@protected MiningPool dco_decode_mining_pool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return MiningPool(id: dco_decode_opt_box_autoadd_u_32(arr[0]),
name: dco_decode_String(arr[1]),
slug: dco_decode_opt_String(arr[2]),); }

@protected MoonPayCurrencyLimits dco_decode_moon_pay_currency_limits(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return MoonPayCurrencyLimits(quoteCurrency: dco_decode_currency_info(arr[0]),
baseCurrency: dco_decode_currency_info(arr[1]),); }

@protected MoonPayEncryptedData dco_decode_moon_pay_encrypted_data(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return MoonPayEncryptedData(ciphertext: dco_decode_String(arr[0]),
iv: dco_decode_String(arr[1]),); }

@protected MoonPayQuote dco_decode_moon_pay_quote(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return MoonPayQuote(baseCurrencyAmount: dco_decode_f_64(arr[0]),
quoteCurrencyAmount: dco_decode_f_64(arr[1]),
baseCurrencyCode: dco_decode_String(arr[2]),
exchangeRate: dco_decode_f_64(arr[3]),
timestamp: dco_decode_String(arr[4]),); }

@protected OffchainBalance dco_decode_offchain_balance(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return OffchainBalance(pendingSats: dco_decode_u_64(arr[0]),
confirmedSats: dco_decode_u_64(arr[1]),
totalSats: dco_decode_u_64(arr[2]),); }

@protected OfferFilters dco_decode_offer_filters(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 10) throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
                return OfferFilters(loanType: dco_decode_opt_String(arr[0]),
assetType: dco_decode_opt_String(arr[1]),
loanAssets: dco_decode_opt_String(arr[2]),
kyc: dco_decode_opt_String(arr[3]),
minLoanAmount: dco_decode_opt_box_autoadd_f_64(arr[4]),
maxLoanAmount: dco_decode_opt_box_autoadd_f_64(arr[5]),
maxInterestRate: dco_decode_opt_box_autoadd_f_64(arr[6]),
durationMin: dco_decode_opt_box_autoadd_i_32(arr[7]),
durationMax: dco_decode_opt_box_autoadd_i_32(arr[8]),
collateralAssetType: dco_decode_opt_String(arr[9]),); }

@protected String? dco_decode_opt_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_String(raw); }

@protected BlockExtras? dco_decode_opt_box_autoadd_block_extras(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_block_extras(raw); }

@protected BoltzSwap? dco_decode_opt_box_autoadd_boltz_swap(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_boltz_swap(raw); }

@protected bool? dco_decode_opt_box_autoadd_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_bool(raw); }

@protected ContractFilters? dco_decode_opt_box_autoadd_contract_filters(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_contract_filters(raw); }

@protected Conversions? dco_decode_opt_box_autoadd_conversions(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_conversions(raw); }

@protected DifficultyAdjustment? dco_decode_opt_box_autoadd_difficulty_adjustment(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_difficulty_adjustment(raw); }

@protected double? dco_decode_opt_box_autoadd_f_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_f_64(raw); }

@protected FearGreedData? dco_decode_opt_box_autoadd_fear_greed_data(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_fear_greed_data(raw); }

@protected FearGreedLastUpdated? dco_decode_opt_box_autoadd_fear_greed_last_updated(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_fear_greed_last_updated(raw); }

@protected FearGreedValue? dco_decode_opt_box_autoadd_fear_greed_value(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_fear_greed_value(raw); }

@protected int? dco_decode_opt_box_autoadd_i_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_i_32(raw); }

@protected PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_i_64(raw); }

@protected MiningPool? dco_decode_opt_box_autoadd_mining_pool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_mining_pool(raw); }

@protected OfferFilters? dco_decode_opt_box_autoadd_offer_filters(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_offer_filters(raw); }

@protected RecommendedFees? dco_decode_opt_box_autoadd_recommended_fees(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_recommended_fees(raw); }

@protected TxOutput? dco_decode_opt_box_autoadd_tx_output(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_tx_output(raw); }

@protected int? dco_decode_opt_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_u_32(raw); }

@protected BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_u_64(raw); }

@protected List<String>? dco_decode_opt_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_String(raw); }

@protected List<Block>? dco_decode_opt_list_block(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_block(raw); }

@protected List<ContractStatus>? dco_decode_opt_list_contract_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_contract_status(raw); }

@protected List<MempoolBlock>? dco_decode_opt_list_mempool_block(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_mempool_block(raw); }

@protected OriginationFee dco_decode_origination_fee(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return OriginationFee(fee: dco_decode_f_64(arr[0]),
fromDay: dco_decode_i_32(arr[1]),); }

@protected PaginatedContractsResponse dco_decode_paginated_contracts_response(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return PaginatedContractsResponse(data: dco_decode_list_contract(arr[0]),
page: dco_decode_i_32(arr[1]),
limit: dco_decode_i_32(arr[2]),
total: dco_decode_i_32(arr[3]),
totalPages: dco_decode_i_32(arr[4]),); }

@protected PaymentReceived dco_decode_payment_received(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return PaymentReceived(txid: dco_decode_String(arr[0]),
amountSats: dco_decode_u_64(arr[1]),); }

@protected ProjectedBlockTransactions dco_decode_projected_block_transactions(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return ProjectedBlockTransactions(index: dco_decode_u_32(arr[0]),
transactions: dco_decode_list_projected_transaction(arr[1]),); }

@protected ProjectedTransaction dco_decode_projected_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return ProjectedTransaction(txid: dco_decode_String(arr[0]),
value: dco_decode_u_64(arr[1]),
vsize: dco_decode_u_32(arr[2]),
feeRate: dco_decode_f_64(arr[3]),
flags: dco_decode_u_32(arr[4]),); }

@protected RecommendedFees dco_decode_recommended_fees(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return RecommendedFees(fastestFee: dco_decode_f_64(arr[0]),
halfHourFee: dco_decode_f_64(arr[1]),
hourFee: dco_decode_f_64(arr[2]),
economyFee: dco_decode_f_64(arr[3]),
minimumFee: dco_decode_f_64(arr[4]),); }

@protected (String,double) dco_decode_record_string_f_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_f_64(arr[1]),); }

@protected RepaymentPlan dco_decode_repayment_plan(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RepaymentPlan.values[raw as int]; }

@protected SettleArkPsbtResponse dco_decode_settle_ark_psbt_response(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
                return SettleArkPsbtResponse(intentMessage: dco_decode_String(arr[0]),
intentProof: dco_decode_String(arr[1]),
forfeitPsbts: dco_decode_list_String(arr[2]),
delegateCosignerPk: dco_decode_String(arr[3]),
userPk: dco_decode_String(arr[4]),
derivationPath: dco_decode_opt_String(arr[5]),); }

@protected SwapInfo dco_decode_swap_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 16) throw Exception('unexpected arr length: expect 16 but see ${arr.length}');
                return SwapInfo(id: dco_decode_String(arr[0]),
status: dco_decode_swap_status_simple(arr[1]),
direction: dco_decode_String(arr[2]),
sourceToken: dco_decode_String(arr[3]),
targetToken: dco_decode_String(arr[4]),
sourceAmountSats: dco_decode_i_64(arr[5]),
targetAmountUsd: dco_decode_f_64(arr[6]),
createdAt: dco_decode_String(arr[7]),
lnInvoice: dco_decode_opt_String(arr[8]),
arkadeHtlcAddress: dco_decode_opt_String(arr[9]),
evmHtlcAddress: dco_decode_opt_String(arr[10]),
feeSats: dco_decode_i_64(arr[11]),
canClaimGelato: dco_decode_bool(arr[12]),
canClaimVhtlc: dco_decode_bool(arr[13]),
canRefund: dco_decode_bool(arr[14]),
detailedStatus: dco_decode_String(arr[15]),); }

@protected SwapQuote dco_decode_swap_quote(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
                return SwapQuote(exchangeRate: dco_decode_String(arr[0]),
networkFeeSats: dco_decode_u_64(arr[1]),
protocolFeeSats: dco_decode_u_64(arr[2]),
protocolFeePercent: dco_decode_f_64(arr[3]),
minAmountSats: dco_decode_u_64(arr[4]),
maxAmountSats: dco_decode_u_64(arr[5]),); }

@protected SwapStatusSimple dco_decode_swap_status_simple(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SwapStatusSimple.values[raw as int]; }

@protected TradingPair dco_decode_trading_pair(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return TradingPair(source: dco_decode_asset_info(arr[0]),
target: dco_decode_asset_info(arr[1]),); }

@protected Transaction dco_decode_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
switch (raw[0]) {
                case 0: return Transaction_Boarding(txid: dco_decode_String(raw[1]),amountSats: dco_decode_u_64(raw[2]),confirmedAt: dco_decode_opt_box_autoadd_i_64(raw[3]),);
case 1: return Transaction_Round(txid: dco_decode_String(raw[1]),amountSats: dco_decode_i_64(raw[2]),createdAt: dco_decode_i_64(raw[3]),);
case 2: return Transaction_Redeem(txid: dco_decode_String(raw[1]),amountSats: dco_decode_i_64(raw[2]),isSettled: dco_decode_bool(raw[3]),createdAt: dco_decode_i_64(raw[4]),);
                default: throw Exception("unreachable");
            } }

@protected TxInput dco_decode_tx_input(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 8) throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
                return TxInput(txid: dco_decode_String(arr[0]),
vout: dco_decode_u_32(arr[1]),
prevout: dco_decode_opt_box_autoadd_tx_output(arr[2]),
scriptsig: dco_decode_String(arr[3]),
scriptsigAsm: dco_decode_String(arr[4]),
witness: dco_decode_opt_list_String(arr[5]),
isCoinbase: dco_decode_bool(arr[6]),
sequence: dco_decode_u_32(arr[7]),); }

@protected TxOutput dco_decode_tx_output(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return TxOutput(scriptpubkey: dco_decode_String(arr[0]),
scriptpubkeyAsm: dco_decode_String(arr[1]),
scriptpubkeyType: dco_decode_String(arr[2]),
scriptpubkeyAddress: dco_decode_opt_String(arr[3]),
value: dco_decode_u_64(arr[4]),); }

@protected TxStatus dco_decode_tx_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return TxStatus(confirmed: dco_decode_bool(arr[0]),
blockHeight: dco_decode_opt_box_autoadd_u_64(arr[1]),
blockHash: dco_decode_opt_String(arr[2]),
blockTime: dco_decode_opt_box_autoadd_u_64(arr[3]),); }

@protected int dco_decode_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected BigInt dco_decode_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeU64(raw); }

@protected int dco_decode_u_8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected void dco_decode_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return; }

@protected AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_String(deserializer);
        return AnyhowException(inner); }

@protected Map<String, double> sse_decode_Map_String_f_64_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_f_64(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Sse(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
throw UnimplementedError('Unreachable ()'); }

@protected RustStreamSink<MempoolWsMessage> sse_decode_StreamSink_mempool_ws_message_Sse(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
throw UnimplementedError('Unreachable ()'); }

@protected RustStreamSink<ProjectedBlockTransactions> sse_decode_StreamSink_projected_block_transactions_Sse(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
throw UnimplementedError('Unreachable ()'); }

@protected String sse_decode_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_prim_u_8_strict(deserializer);
        return utf8.decoder.convert(inner); }

@protected Addresses sse_decode_addresses(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_boarding = sse_decode_String(deserializer);
var var_offchain = sse_decode_String(deserializer);
var var_bip21 = sse_decode_String(deserializer);
var var_lightning = sse_decode_opt_box_autoadd_boltz_swap(deserializer);
return Addresses(boarding: var_boarding, offchain: var_offchain, bip21: var_bip21, lightning: var_lightning); }

@protected ArkClaimPsbtResponse sse_decode_ark_claim_psbt_response(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_arkPsbt = sse_decode_String(deserializer);
var var_checkpointPsbts = sse_decode_list_String(deserializer);
return ArkClaimPsbtResponse(arkPsbt: var_arkPsbt, checkpointPsbts: var_checkpointPsbts); }

@protected AssetInfo sse_decode_asset_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_tokenId = sse_decode_String(deserializer);
var var_symbol = sse_decode_String(deserializer);
var var_name = sse_decode_String(deserializer);
var var_chain = sse_decode_String(deserializer);
var var_decimals = sse_decode_u_8(deserializer);
return AssetInfo(tokenId: var_tokenId, symbol: var_symbol, name: var_name, chain: var_chain, decimals: var_decimals); }

@protected AuthResult sse_decode_auth_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            var tag_ = sse_decode_i_32(deserializer);
            switch (tag_) { case 0: var var_userId = sse_decode_String(deserializer);
var var_userName = sse_decode_String(deserializer);
var var_userEmail = sse_decode_opt_String(deserializer);
return AuthResult_Success(userId: var_userId, userName: var_userName, userEmail: var_userEmail);case 1: var var_pubkey = sse_decode_String(deserializer);
return AuthResult_NeedsRegistration(pubkey: var_pubkey); default: throw UnimplementedError(''); }
             }

@protected Balance sse_decode_balance(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_offchain = sse_decode_offchain_balance(deserializer);
return Balance(offchain: var_offchain); }

@protected BitcoinTransaction sse_decode_bitcoin_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_txid = sse_decode_String(deserializer);
var var_version = sse_decode_u_32(deserializer);
var var_locktime = sse_decode_u_32(deserializer);
var var_size = sse_decode_u_32(deserializer);
var var_weight = sse_decode_u_32(deserializer);
var var_fee = sse_decode_u_64(deserializer);
var var_sigops = sse_decode_opt_box_autoadd_u_32(deserializer);
var var_status = sse_decode_tx_status(deserializer);
var var_vin = sse_decode_list_tx_input(deserializer);
var var_vout = sse_decode_list_tx_output(deserializer);
return BitcoinTransaction(txid: var_txid, version: var_version, locktime: var_locktime, size: var_size, weight: var_weight, fee: var_fee, sigops: var_sigops, status: var_status, vin: var_vin, vout: var_vout); }

@protected Block sse_decode_block(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_height = sse_decode_u_64(deserializer);
var var_version = sse_decode_u_32(deserializer);
var var_timestamp = sse_decode_u_64(deserializer);
var var_bits = sse_decode_u_32(deserializer);
var var_nonce = sse_decode_u_32(deserializer);
var var_difficulty = sse_decode_f_64(deserializer);
var var_merkleRoot = sse_decode_String(deserializer);
var var_txCount = sse_decode_u_32(deserializer);
var var_size = sse_decode_u_64(deserializer);
var var_weight = sse_decode_u_64(deserializer);
var var_previousblockhash = sse_decode_opt_String(deserializer);
var var_mediantime = sse_decode_opt_box_autoadd_u_64(deserializer);
var var_stale = sse_decode_opt_box_autoadd_bool(deserializer);
var var_extras = sse_decode_opt_box_autoadd_block_extras(deserializer);
return Block(id: var_id, height: var_height, version: var_version, timestamp: var_timestamp, bits: var_bits, nonce: var_nonce, difficulty: var_difficulty, merkleRoot: var_merkleRoot, txCount: var_txCount, size: var_size, weight: var_weight, previousblockhash: var_previousblockhash, mediantime: var_mediantime, stale: var_stale, extras: var_extras); }

@protected BlockExtras sse_decode_block_extras(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_medianFee = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_totalFees = sse_decode_opt_box_autoadd_u_64(deserializer);
var var_avgFee = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_avgFeeRate = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_reward = sse_decode_opt_box_autoadd_u_64(deserializer);
var var_pool = sse_decode_opt_box_autoadd_mining_pool(deserializer);
var var_matchRate = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_similarity = sse_decode_opt_box_autoadd_f_64(deserializer);
return BlockExtras(medianFee: var_medianFee, totalFees: var_totalFees, avgFee: var_avgFee, avgFeeRate: var_avgFeeRate, reward: var_reward, pool: var_pool, matchRate: var_matchRate, similarity: var_similarity); }

@protected BoltzSwap sse_decode_boltz_swap(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_swapId = sse_decode_String(deserializer);
var var_amountSats = sse_decode_u_64(deserializer);
var var_invoice = sse_decode_String(deserializer);
return BoltzSwap(swapId: var_swapId, amountSats: var_amountSats, invoice: var_invoice); }

@protected bool sse_decode_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8() != 0; }

@protected BlockExtras sse_decode_box_autoadd_block_extras(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_block_extras(deserializer)); }

@protected BoltzSwap sse_decode_box_autoadd_boltz_swap(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_boltz_swap(deserializer)); }

@protected bool sse_decode_box_autoadd_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_bool(deserializer)); }

@protected ContractFilters sse_decode_box_autoadd_contract_filters(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_contract_filters(deserializer)); }

@protected Conversions sse_decode_box_autoadd_conversions(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_conversions(deserializer)); }

@protected DifficultyAdjustment sse_decode_box_autoadd_difficulty_adjustment(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_difficulty_adjustment(deserializer)); }

@protected double sse_decode_box_autoadd_f_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_f_64(deserializer)); }

@protected FearGreedData sse_decode_box_autoadd_fear_greed_data(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_fear_greed_data(deserializer)); }

@protected FearGreedLastUpdated sse_decode_box_autoadd_fear_greed_last_updated(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_fear_greed_last_updated(deserializer)); }

@protected FearGreedValue sse_decode_box_autoadd_fear_greed_value(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_fear_greed_value(deserializer)); }

@protected int sse_decode_box_autoadd_i_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_i_32(deserializer)); }

@protected PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_i_64(deserializer)); }

@protected MiningPool sse_decode_box_autoadd_mining_pool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_mining_pool(deserializer)); }

@protected OfferFilters sse_decode_box_autoadd_offer_filters(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_offer_filters(deserializer)); }

@protected RecommendedFees sse_decode_box_autoadd_recommended_fees(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_recommended_fees(deserializer)); }

@protected TxOutput sse_decode_box_autoadd_tx_output(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_tx_output(deserializer)); }

@protected int sse_decode_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_u_32(deserializer)); }

@protected BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_u_64(deserializer)); }

@protected BtcToEvmSwapResult sse_decode_btc_to_evm_swap_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_swapId = sse_decode_String(deserializer);
var var_lnInvoice = sse_decode_String(deserializer);
var var_arkadeHtlcAddress = sse_decode_String(deserializer);
var var_satsToSend = sse_decode_i_64(deserializer);
var var_targetAmountUsd = sse_decode_f_64(deserializer);
var var_feeSats = sse_decode_i_64(deserializer);
return BtcToEvmSwapResult(swapId: var_swapId, lnInvoice: var_lnInvoice, arkadeHtlcAddress: var_arkadeHtlcAddress, satsToSend: var_satsToSend, targetAmountUsd: var_targetAmountUsd, feeSats: var_feeSats); }

@protected ClaimPsbtResponse sse_decode_claim_psbt_response(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_psbt = sse_decode_String(deserializer);
var var_collateralDescriptor = sse_decode_String(deserializer);
var var_borrowerPk = sse_decode_String(deserializer);
return ClaimPsbtResponse(psbt: var_psbt, collateralDescriptor: var_collateralDescriptor, borrowerPk: var_borrowerPk); }

@protected CollateralAsset sse_decode_collateral_asset(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return CollateralAsset.values[inner]; }

@protected Contract sse_decode_contract(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_status = sse_decode_contract_status(deserializer);
var var_lender = sse_decode_lender_stats(deserializer);
var var_lenderPk = sse_decode_String(deserializer);
var var_borrowerPk = sse_decode_String(deserializer);
var var_borrowerBtcAddress = sse_decode_String(deserializer);
var var_borrowerDerivationPath = sse_decode_opt_String(deserializer);
var var_borrowerLoanAddress = sse_decode_opt_String(deserializer);
var var_loanAsset = sse_decode_loan_asset(deserializer);
var var_collateralAsset = sse_decode_collateral_asset(deserializer);
var var_loanAmount = sse_decode_f_64(deserializer);
var var_interest = sse_decode_f_64(deserializer);
var var_interestRate = sse_decode_f_64(deserializer);
var var_durationDays = sse_decode_i_32(deserializer);
var var_expiry = sse_decode_String(deserializer);
var var_collateralSats = sse_decode_i_64(deserializer);
var var_initialCollateralSats = sse_decode_i_64(deserializer);
var var_depositedSats = sse_decode_i_64(deserializer);
var var_initialLtv = sse_decode_f_64(deserializer);
var var_liquidationPrice = sse_decode_f_64(deserializer);
var var_ltvThresholdMarginCall1 = sse_decode_f_64(deserializer);
var var_ltvThresholdMarginCall2 = sse_decode_f_64(deserializer);
var var_ltvThresholdLiquidation = sse_decode_f_64(deserializer);
var var_balanceOutstanding = sse_decode_f_64(deserializer);
var var_contractAddress = sse_decode_opt_String(deserializer);
var var_collateralScript = sse_decode_opt_String(deserializer);
var var_loanRepaymentAddress = sse_decode_opt_String(deserializer);
var var_btcLoanRepaymentAddress = sse_decode_opt_String(deserializer);
var var_originationFeeSats = sse_decode_i_64(deserializer);
var var_installments = sse_decode_list_installment(deserializer);
var var_transactions = sse_decode_list_loan_transaction(deserializer);
var var_canExtend = sse_decode_bool(deserializer);
var var_extensionInterestRate = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_extensionMaxDurationDays = sse_decode_i_32(deserializer);
var var_extendsContract = sse_decode_opt_String(deserializer);
var var_extendedByContract = sse_decode_opt_String(deserializer);
var var_clientContractId = sse_decode_opt_String(deserializer);
var var_requiresArkSettlement = sse_decode_opt_box_autoadd_bool(deserializer);
var var_createdAt = sse_decode_String(deserializer);
var var_updatedAt = sse_decode_String(deserializer);
return Contract(id: var_id, status: var_status, lender: var_lender, lenderPk: var_lenderPk, borrowerPk: var_borrowerPk, borrowerBtcAddress: var_borrowerBtcAddress, borrowerDerivationPath: var_borrowerDerivationPath, borrowerLoanAddress: var_borrowerLoanAddress, loanAsset: var_loanAsset, collateralAsset: var_collateralAsset, loanAmount: var_loanAmount, interest: var_interest, interestRate: var_interestRate, durationDays: var_durationDays, expiry: var_expiry, collateralSats: var_collateralSats, initialCollateralSats: var_initialCollateralSats, depositedSats: var_depositedSats, initialLtv: var_initialLtv, liquidationPrice: var_liquidationPrice, ltvThresholdMarginCall1: var_ltvThresholdMarginCall1, ltvThresholdMarginCall2: var_ltvThresholdMarginCall2, ltvThresholdLiquidation: var_ltvThresholdLiquidation, balanceOutstanding: var_balanceOutstanding, contractAddress: var_contractAddress, collateralScript: var_collateralScript, loanRepaymentAddress: var_loanRepaymentAddress, btcLoanRepaymentAddress: var_btcLoanRepaymentAddress, originationFeeSats: var_originationFeeSats, installments: var_installments, transactions: var_transactions, canExtend: var_canExtend, extensionInterestRate: var_extensionInterestRate, extensionMaxDurationDays: var_extensionMaxDurationDays, extendsContract: var_extendsContract, extendedByContract: var_extendedByContract, clientContractId: var_clientContractId, requiresArkSettlement: var_requiresArkSettlement, createdAt: var_createdAt, updatedAt: var_updatedAt); }

@protected ContractFilters sse_decode_contract_filters(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_page = sse_decode_opt_box_autoadd_i_32(deserializer);
var var_limit = sse_decode_opt_box_autoadd_i_32(deserializer);
var var_status = sse_decode_opt_list_contract_status(deserializer);
var var_sortBy = sse_decode_opt_String(deserializer);
var var_sortOrder = sse_decode_opt_String(deserializer);
return ContractFilters(page: var_page, limit: var_limit, status: var_status, sortBy: var_sortBy, sortOrder: var_sortOrder); }

@protected ContractStatus sse_decode_contract_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return ContractStatus.values[inner]; }

@protected Conversions sse_decode_conversions(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_time = sse_decode_u_64(deserializer);
var var_usd = sse_decode_f_64(deserializer);
var var_eur = sse_decode_opt_box_autoadd_f_64(deserializer);
return Conversions(time: var_time, usd: var_usd, eur: var_eur); }

@protected CurrencyInfo sse_decode_currency_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_code = sse_decode_String(deserializer);
var var_minBuyAmount = sse_decode_f_64(deserializer);
var var_maxBuyAmount = sse_decode_f_64(deserializer);
return CurrencyInfo(code: var_code, minBuyAmount: var_minBuyAmount, maxBuyAmount: var_maxBuyAmount); }

@protected DifficultyAdjustment sse_decode_difficulty_adjustment(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_progressPercent = sse_decode_f_64(deserializer);
var var_difficultyChange = sse_decode_f_64(deserializer);
var var_estimatedRetargetDate = sse_decode_u_64(deserializer);
var var_remainingBlocks = sse_decode_u_32(deserializer);
var var_remainingTime = sse_decode_u_64(deserializer);
var var_previousRetarget = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_previousTime = sse_decode_opt_box_autoadd_u_64(deserializer);
var var_nextRetargetHeight = sse_decode_u_64(deserializer);
var var_timeAvg = sse_decode_u_64(deserializer);
var var_adjustedTimeAvg = sse_decode_opt_box_autoadd_u_64(deserializer);
var var_timeOffset = sse_decode_i_64(deserializer);
var var_expectedBlocks = sse_decode_f_64(deserializer);
return DifficultyAdjustment(progressPercent: var_progressPercent, difficultyChange: var_difficultyChange, estimatedRetargetDate: var_estimatedRetargetDate, remainingBlocks: var_remainingBlocks, remainingTime: var_remainingTime, previousRetarget: var_previousRetarget, previousTime: var_previousTime, nextRetargetHeight: var_nextRetargetHeight, timeAvg: var_timeAvg, adjustedTimeAvg: var_adjustedTimeAvg, timeOffset: var_timeOffset, expectedBlocks: var_expectedBlocks); }

@protected DifficultyPoint sse_decode_difficulty_point(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_timestamp = sse_decode_opt_box_autoadd_u_64(deserializer);
var var_difficulty = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_height = sse_decode_opt_box_autoadd_u_64(deserializer);
return DifficultyPoint(timestamp: var_timestamp, difficulty: var_difficulty, height: var_height); }

@protected EvmToBtcSwapResult sse_decode_evm_to_btc_swap_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_swapId = sse_decode_String(deserializer);
var var_evmHtlcAddress = sse_decode_String(deserializer);
var var_sourceAmountUsd = sse_decode_f_64(deserializer);
var var_satsToReceive = sse_decode_i_64(deserializer);
var var_feeSats = sse_decode_i_64(deserializer);
var var_sourceTokenAddress = sse_decode_String(deserializer);
var var_createSwapTx = sse_decode_opt_String(deserializer);
var var_approveTx = sse_decode_opt_String(deserializer);
var var_gelatoForwarderAddress = sse_decode_opt_String(deserializer);
var var_gelatoUserNonce = sse_decode_opt_String(deserializer);
var var_gelatoUserDeadline = sse_decode_opt_String(deserializer);
return EvmToBtcSwapResult(swapId: var_swapId, evmHtlcAddress: var_evmHtlcAddress, sourceAmountUsd: var_sourceAmountUsd, satsToReceive: var_satsToReceive, feeSats: var_feeSats, sourceTokenAddress: var_sourceTokenAddress, createSwapTx: var_createSwapTx, approveTx: var_approveTx, gelatoForwarderAddress: var_gelatoForwarderAddress, gelatoUserNonce: var_gelatoUserNonce, gelatoUserDeadline: var_gelatoUserDeadline); }

@protected ExchangeRates sse_decode_exchange_rates(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_base = sse_decode_String(deserializer);
var var_rates = sse_decode_Map_String_f_64_None(deserializer);
var var_timestamp = sse_decode_i_64(deserializer);
return ExchangeRates(base: var_base, rates: var_rates, timestamp: var_timestamp); }

@protected double sse_decode_f_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getFloat64(); }

@protected FearGreedData sse_decode_fear_greed_data(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_now = sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
var var_previousClose = sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
var var_oneWeekAgo = sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
var var_oneMonthAgo = sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
var var_oneYearAgo = sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
return FearGreedData(now: var_now, previousClose: var_previousClose, oneWeekAgo: var_oneWeekAgo, oneMonthAgo: var_oneMonthAgo, oneYearAgo: var_oneYearAgo); }

@protected FearGreedIndex sse_decode_fear_greed_index(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_lastUpdated = sse_decode_opt_box_autoadd_fear_greed_last_updated(deserializer);
var var_fgi = sse_decode_opt_box_autoadd_fear_greed_data(deserializer);
return FearGreedIndex(lastUpdated: var_lastUpdated, fgi: var_fgi); }

@protected FearGreedLastUpdated sse_decode_fear_greed_last_updated(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_epochUnixSeconds = sse_decode_opt_box_autoadd_i_64(deserializer);
var var_humanDate = sse_decode_opt_String(deserializer);
return FearGreedLastUpdated(epochUnixSeconds: var_epochUnixSeconds, humanDate: var_humanDate); }

@protected FearGreedValue sse_decode_fear_greed_value(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_value = sse_decode_opt_box_autoadd_i_32(deserializer);
var var_valueText = sse_decode_opt_String(deserializer);
return FearGreedValue(value: var_value, valueText: var_valueText); }

@protected FiatCurrency sse_decode_fiat_currency(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return FiatCurrency.values[inner]; }

@protected HashrateData sse_decode_hashrate_data(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_currentHashrate = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_currentDifficulty = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_hashrates = sse_decode_list_hashrate_point(deserializer);
var var_difficulty = sse_decode_list_difficulty_point(deserializer);
return HashrateData(currentHashrate: var_currentHashrate, currentDifficulty: var_currentDifficulty, hashrates: var_hashrates, difficulty: var_difficulty); }

@protected HashratePoint sse_decode_hashrate_point(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_timestamp = sse_decode_u_64(deserializer);
var var_avgHashrate = sse_decode_f_64(deserializer);
return HashratePoint(timestamp: var_timestamp, avgHashrate: var_avgHashrate); }

@protected HistoricalPriceData sse_decode_historical_price_data(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_timestamp = sse_decode_String(deserializer);
var var_price = sse_decode_String(deserializer);
return HistoricalPriceData(timestamp: var_timestamp, price: var_price); }

@protected HistoricalPriceResponse sse_decode_historical_price_response(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_prices = sse_decode_list_historical_price_data(deserializer);
return HistoricalPriceResponse(prices: var_prices); }

@protected int sse_decode_i_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt32(); }

@protected PlatformInt64 sse_decode_i_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getPlatformInt64(); }

@protected Info sse_decode_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_serverPk = sse_decode_String(deserializer);
var var_network = sse_decode_String(deserializer);
return Info(serverPk: var_serverPk, network: var_network); }

@protected Installment sse_decode_installment(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_dueDate = sse_decode_String(deserializer);
var var_principal = sse_decode_f_64(deserializer);
var var_interest = sse_decode_f_64(deserializer);
var var_status = sse_decode_installment_status(deserializer);
var var_paidDate = sse_decode_opt_String(deserializer);
var var_paymentId = sse_decode_opt_String(deserializer);
return Installment(id: var_id, dueDate: var_dueDate, principal: var_principal, interest: var_interest, status: var_status, paidDate: var_paidDate, paymentId: var_paymentId); }

@protected InstallmentStatus sse_decode_installment_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return InstallmentStatus.values[inner]; }

@protected LenderStats sse_decode_lender_stats(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_name = sse_decode_String(deserializer);
var var_joinedAt = sse_decode_String(deserializer);
var var_successfulContracts = sse_decode_i_32(deserializer);
var var_vetted = sse_decode_bool(deserializer);
var var_timezone = sse_decode_opt_String(deserializer);
return LenderStats(id: var_id, name: var_name, joinedAt: var_joinedAt, successfulContracts: var_successfulContracts, vetted: var_vetted, timezone: var_timezone); }

@protected List<String> sse_decode_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <String>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_String(deserializer)); }
        return ans_;
         }

@protected List<BitcoinTransaction> sse_decode_list_bitcoin_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <BitcoinTransaction>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_bitcoin_transaction(deserializer)); }
        return ans_;
         }

@protected List<Block> sse_decode_list_block(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Block>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_block(deserializer)); }
        return ans_;
         }

@protected List<Contract> sse_decode_list_contract(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Contract>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_contract(deserializer)); }
        return ans_;
         }

@protected List<ContractStatus> sse_decode_list_contract_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <ContractStatus>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_contract_status(deserializer)); }
        return ans_;
         }

@protected List<DifficultyPoint> sse_decode_list_difficulty_point(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <DifficultyPoint>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_difficulty_point(deserializer)); }
        return ans_;
         }

@protected List<FiatCurrency> sse_decode_list_fiat_currency(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <FiatCurrency>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_fiat_currency(deserializer)); }
        return ans_;
         }

@protected List<HashratePoint> sse_decode_list_hashrate_point(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <HashratePoint>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_hashrate_point(deserializer)); }
        return ans_;
         }

@protected List<HistoricalPriceData> sse_decode_list_historical_price_data(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <HistoricalPriceData>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_historical_price_data(deserializer)); }
        return ans_;
         }

@protected List<Installment> sse_decode_list_installment(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Installment>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_installment(deserializer)); }
        return ans_;
         }

@protected List<LoanOffer> sse_decode_list_loan_offer(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <LoanOffer>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_loan_offer(deserializer)); }
        return ans_;
         }

@protected List<LoanTransaction> sse_decode_list_loan_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <LoanTransaction>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_loan_transaction(deserializer)); }
        return ans_;
         }

@protected List<MempoolBlock> sse_decode_list_mempool_block(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <MempoolBlock>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_mempool_block(deserializer)); }
        return ans_;
         }

@protected List<OriginationFee> sse_decode_list_origination_fee(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <OriginationFee>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_origination_fee(deserializer)); }
        return ans_;
         }

@protected Float64List sse_decode_list_prim_f_64_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getFloat64List(len_); }

@protected Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected List<ProjectedTransaction> sse_decode_list_projected_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <ProjectedTransaction>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_projected_transaction(deserializer)); }
        return ans_;
         }

@protected List<(String,double)> sse_decode_list_record_string_f_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,double)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_f_64(deserializer)); }
        return ans_;
         }

@protected List<SwapInfo> sse_decode_list_swap_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <SwapInfo>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_swap_info(deserializer)); }
        return ans_;
         }

@protected List<TradingPair> sse_decode_list_trading_pair(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <TradingPair>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_trading_pair(deserializer)); }
        return ans_;
         }

@protected List<Transaction> sse_decode_list_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Transaction>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_transaction(deserializer)); }
        return ans_;
         }

@protected List<TxInput> sse_decode_list_tx_input(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <TxInput>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_tx_input(deserializer)); }
        return ans_;
         }

@protected List<TxOutput> sse_decode_list_tx_output(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <TxOutput>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_tx_output(deserializer)); }
        return ans_;
         }

@protected LnPaymentResult sse_decode_ln_payment_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_swapId = sse_decode_String(deserializer);
var var_txid = sse_decode_String(deserializer);
var var_amountSats = sse_decode_u_64(deserializer);
return LnPaymentResult(swapId: var_swapId, txid: var_txid, amountSats: var_amountSats); }

@protected LoanAsset sse_decode_loan_asset(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return LoanAsset.values[inner]; }

@protected LoanOffer sse_decode_loan_offer(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_name = sse_decode_String(deserializer);
var var_lender = sse_decode_lender_stats(deserializer);
var var_lenderPk = sse_decode_String(deserializer);
var var_loanAsset = sse_decode_loan_asset(deserializer);
var var_collateralAsset = sse_decode_collateral_asset(deserializer);
var var_loanAmountMin = sse_decode_f_64(deserializer);
var var_loanAmountMax = sse_decode_f_64(deserializer);
var var_durationDaysMin = sse_decode_i_32(deserializer);
var var_durationDaysMax = sse_decode_i_32(deserializer);
var var_interestRate = sse_decode_f_64(deserializer);
var var_minLtv = sse_decode_f_64(deserializer);
var var_loanPayout = sse_decode_loan_payout(deserializer);
var var_loanRepaymentAddress = sse_decode_String(deserializer);
var var_originationFee = sse_decode_list_origination_fee(deserializer);
var var_repaymentPlan = sse_decode_repayment_plan(deserializer);
var var_status = sse_decode_loan_offer_status(deserializer);
var var_kycLink = sse_decode_opt_String(deserializer);
return LoanOffer(id: var_id, name: var_name, lender: var_lender, lenderPk: var_lenderPk, loanAsset: var_loanAsset, collateralAsset: var_collateralAsset, loanAmountMin: var_loanAmountMin, loanAmountMax: var_loanAmountMax, durationDaysMin: var_durationDaysMin, durationDaysMax: var_durationDaysMax, interestRate: var_interestRate, minLtv: var_minLtv, loanPayout: var_loanPayout, loanRepaymentAddress: var_loanRepaymentAddress, originationFee: var_originationFee, repaymentPlan: var_repaymentPlan, status: var_status, kycLink: var_kycLink); }

@protected LoanOfferStatus sse_decode_loan_offer_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return LoanOfferStatus.values[inner]; }

@protected LoanPayout sse_decode_loan_payout(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return LoanPayout.values[inner]; }

@protected LoanTransaction sse_decode_loan_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_i_64(deserializer);
var var_contractId = sse_decode_String(deserializer);
var var_transactionType = sse_decode_String(deserializer);
var var_txid = sse_decode_String(deserializer);
var var_timestamp = sse_decode_String(deserializer);
return LoanTransaction(id: var_id, contractId: var_contractId, transactionType: var_transactionType, txid: var_txid, timestamp: var_timestamp); }

@protected LogEntry sse_decode_log_entry(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_msg = sse_decode_String(deserializer);
var var_target = sse_decode_String(deserializer);
var var_level = sse_decode_String(deserializer);
var var_file = sse_decode_String(deserializer);
var var_line = sse_decode_String(deserializer);
var var_modulePath = sse_decode_String(deserializer);
var var_data = sse_decode_String(deserializer);
return LogEntry(msg: var_msg, target: var_target, level: var_level, file: var_file, line: var_line, modulePath: var_modulePath, data: var_data); }

@protected MempoolBlock sse_decode_mempool_block(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_blockSize = sse_decode_u_64(deserializer);
var var_blockVsize = sse_decode_f_64(deserializer);
var var_nTx = sse_decode_u_32(deserializer);
var var_totalFees = sse_decode_u_64(deserializer);
var var_medianFee = sse_decode_f_64(deserializer);
var var_feeRange = sse_decode_list_prim_f_64_strict(deserializer);
return MempoolBlock(blockSize: var_blockSize, blockVsize: var_blockVsize, nTx: var_nTx, totalFees: var_totalFees, medianFee: var_medianFee, feeRange: var_feeRange); }

@protected MempoolWsMessage sse_decode_mempool_ws_message(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_mempoolBlocks = sse_decode_opt_list_mempool_block(deserializer);
var var_blocks = sse_decode_opt_list_block(deserializer);
var var_conversions = sse_decode_opt_box_autoadd_conversions(deserializer);
var var_fees = sse_decode_opt_box_autoadd_recommended_fees(deserializer);
var var_da = sse_decode_opt_box_autoadd_difficulty_adjustment(deserializer);
return MempoolWsMessage(mempoolBlocks: var_mempoolBlocks, blocks: var_blocks, conversions: var_conversions, fees: var_fees, da: var_da); }

@protected MiningPool sse_decode_mining_pool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_opt_box_autoadd_u_32(deserializer);
var var_name = sse_decode_String(deserializer);
var var_slug = sse_decode_opt_String(deserializer);
return MiningPool(id: var_id, name: var_name, slug: var_slug); }

@protected MoonPayCurrencyLimits sse_decode_moon_pay_currency_limits(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_quoteCurrency = sse_decode_currency_info(deserializer);
var var_baseCurrency = sse_decode_currency_info(deserializer);
return MoonPayCurrencyLimits(quoteCurrency: var_quoteCurrency, baseCurrency: var_baseCurrency); }

@protected MoonPayEncryptedData sse_decode_moon_pay_encrypted_data(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_ciphertext = sse_decode_String(deserializer);
var var_iv = sse_decode_String(deserializer);
return MoonPayEncryptedData(ciphertext: var_ciphertext, iv: var_iv); }

@protected MoonPayQuote sse_decode_moon_pay_quote(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_baseCurrencyAmount = sse_decode_f_64(deserializer);
var var_quoteCurrencyAmount = sse_decode_f_64(deserializer);
var var_baseCurrencyCode = sse_decode_String(deserializer);
var var_exchangeRate = sse_decode_f_64(deserializer);
var var_timestamp = sse_decode_String(deserializer);
return MoonPayQuote(baseCurrencyAmount: var_baseCurrencyAmount, quoteCurrencyAmount: var_quoteCurrencyAmount, baseCurrencyCode: var_baseCurrencyCode, exchangeRate: var_exchangeRate, timestamp: var_timestamp); }

@protected OffchainBalance sse_decode_offchain_balance(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_pendingSats = sse_decode_u_64(deserializer);
var var_confirmedSats = sse_decode_u_64(deserializer);
var var_totalSats = sse_decode_u_64(deserializer);
return OffchainBalance(pendingSats: var_pendingSats, confirmedSats: var_confirmedSats, totalSats: var_totalSats); }

@protected OfferFilters sse_decode_offer_filters(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_loanType = sse_decode_opt_String(deserializer);
var var_assetType = sse_decode_opt_String(deserializer);
var var_loanAssets = sse_decode_opt_String(deserializer);
var var_kyc = sse_decode_opt_String(deserializer);
var var_minLoanAmount = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_maxLoanAmount = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_maxInterestRate = sse_decode_opt_box_autoadd_f_64(deserializer);
var var_durationMin = sse_decode_opt_box_autoadd_i_32(deserializer);
var var_durationMax = sse_decode_opt_box_autoadd_i_32(deserializer);
var var_collateralAssetType = sse_decode_opt_String(deserializer);
return OfferFilters(loanType: var_loanType, assetType: var_assetType, loanAssets: var_loanAssets, kyc: var_kyc, minLoanAmount: var_minLoanAmount, maxLoanAmount: var_maxLoanAmount, maxInterestRate: var_maxInterestRate, durationMin: var_durationMin, durationMax: var_durationMax, collateralAssetType: var_collateralAssetType); }

@protected String? sse_decode_opt_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_String(deserializer));
            } else {
                return null;
            }
             }

@protected BlockExtras? sse_decode_opt_box_autoadd_block_extras(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_block_extras(deserializer));
            } else {
                return null;
            }
             }

@protected BoltzSwap? sse_decode_opt_box_autoadd_boltz_swap(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_boltz_swap(deserializer));
            } else {
                return null;
            }
             }

@protected bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_bool(deserializer));
            } else {
                return null;
            }
             }

@protected ContractFilters? sse_decode_opt_box_autoadd_contract_filters(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_contract_filters(deserializer));
            } else {
                return null;
            }
             }

@protected Conversions? sse_decode_opt_box_autoadd_conversions(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_conversions(deserializer));
            } else {
                return null;
            }
             }

@protected DifficultyAdjustment? sse_decode_opt_box_autoadd_difficulty_adjustment(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_difficulty_adjustment(deserializer));
            } else {
                return null;
            }
             }

@protected double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_f_64(deserializer));
            } else {
                return null;
            }
             }

@protected FearGreedData? sse_decode_opt_box_autoadd_fear_greed_data(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_fear_greed_data(deserializer));
            } else {
                return null;
            }
             }

@protected FearGreedLastUpdated? sse_decode_opt_box_autoadd_fear_greed_last_updated(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_fear_greed_last_updated(deserializer));
            } else {
                return null;
            }
             }

@protected FearGreedValue? sse_decode_opt_box_autoadd_fear_greed_value(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_fear_greed_value(deserializer));
            } else {
                return null;
            }
             }

@protected int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_i_32(deserializer));
            } else {
                return null;
            }
             }

@protected PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_i_64(deserializer));
            } else {
                return null;
            }
             }

@protected MiningPool? sse_decode_opt_box_autoadd_mining_pool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_mining_pool(deserializer));
            } else {
                return null;
            }
             }

@protected OfferFilters? sse_decode_opt_box_autoadd_offer_filters(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_offer_filters(deserializer));
            } else {
                return null;
            }
             }

@protected RecommendedFees? sse_decode_opt_box_autoadd_recommended_fees(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_recommended_fees(deserializer));
            } else {
                return null;
            }
             }

@protected TxOutput? sse_decode_opt_box_autoadd_tx_output(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_tx_output(deserializer));
            } else {
                return null;
            }
             }

@protected int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_u_32(deserializer));
            } else {
                return null;
            }
             }

@protected BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_u_64(deserializer));
            } else {
                return null;
            }
             }

@protected List<String>? sse_decode_opt_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_String(deserializer));
            } else {
                return null;
            }
             }

@protected List<Block>? sse_decode_opt_list_block(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_block(deserializer));
            } else {
                return null;
            }
             }

@protected List<ContractStatus>? sse_decode_opt_list_contract_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_contract_status(deserializer));
            } else {
                return null;
            }
             }

@protected List<MempoolBlock>? sse_decode_opt_list_mempool_block(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_mempool_block(deserializer));
            } else {
                return null;
            }
             }

@protected OriginationFee sse_decode_origination_fee(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_fee = sse_decode_f_64(deserializer);
var var_fromDay = sse_decode_i_32(deserializer);
return OriginationFee(fee: var_fee, fromDay: var_fromDay); }

@protected PaginatedContractsResponse sse_decode_paginated_contracts_response(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_data = sse_decode_list_contract(deserializer);
var var_page = sse_decode_i_32(deserializer);
var var_limit = sse_decode_i_32(deserializer);
var var_total = sse_decode_i_32(deserializer);
var var_totalPages = sse_decode_i_32(deserializer);
return PaginatedContractsResponse(data: var_data, page: var_page, limit: var_limit, total: var_total, totalPages: var_totalPages); }

@protected PaymentReceived sse_decode_payment_received(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_txid = sse_decode_String(deserializer);
var var_amountSats = sse_decode_u_64(deserializer);
return PaymentReceived(txid: var_txid, amountSats: var_amountSats); }

@protected ProjectedBlockTransactions sse_decode_projected_block_transactions(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_index = sse_decode_u_32(deserializer);
var var_transactions = sse_decode_list_projected_transaction(deserializer);
return ProjectedBlockTransactions(index: var_index, transactions: var_transactions); }

@protected ProjectedTransaction sse_decode_projected_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_txid = sse_decode_String(deserializer);
var var_value = sse_decode_u_64(deserializer);
var var_vsize = sse_decode_u_32(deserializer);
var var_feeRate = sse_decode_f_64(deserializer);
var var_flags = sse_decode_u_32(deserializer);
return ProjectedTransaction(txid: var_txid, value: var_value, vsize: var_vsize, feeRate: var_feeRate, flags: var_flags); }

@protected RecommendedFees sse_decode_recommended_fees(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_fastestFee = sse_decode_f_64(deserializer);
var var_halfHourFee = sse_decode_f_64(deserializer);
var var_hourFee = sse_decode_f_64(deserializer);
var var_economyFee = sse_decode_f_64(deserializer);
var var_minimumFee = sse_decode_f_64(deserializer);
return RecommendedFees(fastestFee: var_fastestFee, halfHourFee: var_halfHourFee, hourFee: var_hourFee, economyFee: var_economyFee, minimumFee: var_minimumFee); }

@protected (String,double) sse_decode_record_string_f_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_f_64(deserializer);
return (var_field0, var_field1); }

@protected RepaymentPlan sse_decode_repayment_plan(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return RepaymentPlan.values[inner]; }

@protected SettleArkPsbtResponse sse_decode_settle_ark_psbt_response(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_intentMessage = sse_decode_String(deserializer);
var var_intentProof = sse_decode_String(deserializer);
var var_forfeitPsbts = sse_decode_list_String(deserializer);
var var_delegateCosignerPk = sse_decode_String(deserializer);
var var_userPk = sse_decode_String(deserializer);
var var_derivationPath = sse_decode_opt_String(deserializer);
return SettleArkPsbtResponse(intentMessage: var_intentMessage, intentProof: var_intentProof, forfeitPsbts: var_forfeitPsbts, delegateCosignerPk: var_delegateCosignerPk, userPk: var_userPk, derivationPath: var_derivationPath); }

@protected SwapInfo sse_decode_swap_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_status = sse_decode_swap_status_simple(deserializer);
var var_direction = sse_decode_String(deserializer);
var var_sourceToken = sse_decode_String(deserializer);
var var_targetToken = sse_decode_String(deserializer);
var var_sourceAmountSats = sse_decode_i_64(deserializer);
var var_targetAmountUsd = sse_decode_f_64(deserializer);
var var_createdAt = sse_decode_String(deserializer);
var var_lnInvoice = sse_decode_opt_String(deserializer);
var var_arkadeHtlcAddress = sse_decode_opt_String(deserializer);
var var_evmHtlcAddress = sse_decode_opt_String(deserializer);
var var_feeSats = sse_decode_i_64(deserializer);
var var_canClaimGelato = sse_decode_bool(deserializer);
var var_canClaimVhtlc = sse_decode_bool(deserializer);
var var_canRefund = sse_decode_bool(deserializer);
var var_detailedStatus = sse_decode_String(deserializer);
return SwapInfo(id: var_id, status: var_status, direction: var_direction, sourceToken: var_sourceToken, targetToken: var_targetToken, sourceAmountSats: var_sourceAmountSats, targetAmountUsd: var_targetAmountUsd, createdAt: var_createdAt, lnInvoice: var_lnInvoice, arkadeHtlcAddress: var_arkadeHtlcAddress, evmHtlcAddress: var_evmHtlcAddress, feeSats: var_feeSats, canClaimGelato: var_canClaimGelato, canClaimVhtlc: var_canClaimVhtlc, canRefund: var_canRefund, detailedStatus: var_detailedStatus); }

@protected SwapQuote sse_decode_swap_quote(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_exchangeRate = sse_decode_String(deserializer);
var var_networkFeeSats = sse_decode_u_64(deserializer);
var var_protocolFeeSats = sse_decode_u_64(deserializer);
var var_protocolFeePercent = sse_decode_f_64(deserializer);
var var_minAmountSats = sse_decode_u_64(deserializer);
var var_maxAmountSats = sse_decode_u_64(deserializer);
return SwapQuote(exchangeRate: var_exchangeRate, networkFeeSats: var_networkFeeSats, protocolFeeSats: var_protocolFeeSats, protocolFeePercent: var_protocolFeePercent, minAmountSats: var_minAmountSats, maxAmountSats: var_maxAmountSats); }

@protected SwapStatusSimple sse_decode_swap_status_simple(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return SwapStatusSimple.values[inner]; }

@protected TradingPair sse_decode_trading_pair(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_source = sse_decode_asset_info(deserializer);
var var_target = sse_decode_asset_info(deserializer);
return TradingPair(source: var_source, target: var_target); }

@protected Transaction sse_decode_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            var tag_ = sse_decode_i_32(deserializer);
            switch (tag_) { case 0: var var_txid = sse_decode_String(deserializer);
var var_amountSats = sse_decode_u_64(deserializer);
var var_confirmedAt = sse_decode_opt_box_autoadd_i_64(deserializer);
return Transaction_Boarding(txid: var_txid, amountSats: var_amountSats, confirmedAt: var_confirmedAt);case 1: var var_txid = sse_decode_String(deserializer);
var var_amountSats = sse_decode_i_64(deserializer);
var var_createdAt = sse_decode_i_64(deserializer);
return Transaction_Round(txid: var_txid, amountSats: var_amountSats, createdAt: var_createdAt);case 2: var var_txid = sse_decode_String(deserializer);
var var_amountSats = sse_decode_i_64(deserializer);
var var_isSettled = sse_decode_bool(deserializer);
var var_createdAt = sse_decode_i_64(deserializer);
return Transaction_Redeem(txid: var_txid, amountSats: var_amountSats, isSettled: var_isSettled, createdAt: var_createdAt); default: throw UnimplementedError(''); }
             }

@protected TxInput sse_decode_tx_input(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_txid = sse_decode_String(deserializer);
var var_vout = sse_decode_u_32(deserializer);
var var_prevout = sse_decode_opt_box_autoadd_tx_output(deserializer);
var var_scriptsig = sse_decode_String(deserializer);
var var_scriptsigAsm = sse_decode_String(deserializer);
var var_witness = sse_decode_opt_list_String(deserializer);
var var_isCoinbase = sse_decode_bool(deserializer);
var var_sequence = sse_decode_u_32(deserializer);
return TxInput(txid: var_txid, vout: var_vout, prevout: var_prevout, scriptsig: var_scriptsig, scriptsigAsm: var_scriptsigAsm, witness: var_witness, isCoinbase: var_isCoinbase, sequence: var_sequence); }

@protected TxOutput sse_decode_tx_output(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_scriptpubkey = sse_decode_String(deserializer);
var var_scriptpubkeyAsm = sse_decode_String(deserializer);
var var_scriptpubkeyType = sse_decode_String(deserializer);
var var_scriptpubkeyAddress = sse_decode_opt_String(deserializer);
var var_value = sse_decode_u_64(deserializer);
return TxOutput(scriptpubkey: var_scriptpubkey, scriptpubkeyAsm: var_scriptpubkeyAsm, scriptpubkeyType: var_scriptpubkeyType, scriptpubkeyAddress: var_scriptpubkeyAddress, value: var_value); }

@protected TxStatus sse_decode_tx_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_confirmed = sse_decode_bool(deserializer);
var var_blockHeight = sse_decode_opt_box_autoadd_u_64(deserializer);
var var_blockHash = sse_decode_opt_String(deserializer);
var var_blockTime = sse_decode_opt_box_autoadd_u_64(deserializer);
return TxStatus(confirmed: var_confirmed, blockHeight: var_blockHeight, blockHash: var_blockHash, blockTime: var_blockTime); }

@protected int sse_decode_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint32(); }

@protected BigInt sse_decode_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getBigUint64(); }

@protected int sse_decode_u_8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8(); }

@protected void sse_decode_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.message, serializer); }

@protected void sse_encode_Map_String_f_64_None(Map<String, double> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_f_64(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_StreamSink_log_entry_Sse(RustStreamSink<LogEntry> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.setupAndSerialize(codec: SseCodec(
            decodeSuccessData: sse_decode_log_entry,
            decodeErrorData: sse_decode_AnyhowException,
        )), serializer); }

@protected void sse_encode_StreamSink_mempool_ws_message_Sse(RustStreamSink<MempoolWsMessage> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.setupAndSerialize(codec: SseCodec(
            decodeSuccessData: sse_decode_mempool_ws_message,
            decodeErrorData: sse_decode_AnyhowException,
        )), serializer); }

@protected void sse_encode_StreamSink_projected_block_transactions_Sse(RustStreamSink<ProjectedBlockTransactions> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.setupAndSerialize(codec: SseCodec(
            decodeSuccessData: sse_decode_projected_block_transactions,
            decodeErrorData: sse_decode_AnyhowException,
        )), serializer); }

@protected void sse_encode_String(String self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer); }

@protected void sse_encode_addresses(Addresses self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.boarding, serializer);
sse_encode_String(self.offchain, serializer);
sse_encode_String(self.bip21, serializer);
sse_encode_opt_box_autoadd_boltz_swap(self.lightning, serializer);
 }

@protected void sse_encode_ark_claim_psbt_response(ArkClaimPsbtResponse self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.arkPsbt, serializer);
sse_encode_list_String(self.checkpointPsbts, serializer);
 }

@protected void sse_encode_asset_info(AssetInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.tokenId, serializer);
sse_encode_String(self.symbol, serializer);
sse_encode_String(self.name, serializer);
sse_encode_String(self.chain, serializer);
sse_encode_u_8(self.decimals, serializer);
 }

@protected void sse_encode_auth_result(AuthResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
switch (self) { case AuthResult_Success(userId: final userId,userName: final userName,userEmail: final userEmail): sse_encode_i_32(0, serializer); sse_encode_String(userId, serializer);
sse_encode_String(userName, serializer);
sse_encode_opt_String(userEmail, serializer);
case AuthResult_NeedsRegistration(pubkey: final pubkey): sse_encode_i_32(1, serializer); sse_encode_String(pubkey, serializer);
  } }

@protected void sse_encode_balance(Balance self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_offchain_balance(self.offchain, serializer);
 }

@protected void sse_encode_bitcoin_transaction(BitcoinTransaction self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.txid, serializer);
sse_encode_u_32(self.version, serializer);
sse_encode_u_32(self.locktime, serializer);
sse_encode_u_32(self.size, serializer);
sse_encode_u_32(self.weight, serializer);
sse_encode_u_64(self.fee, serializer);
sse_encode_opt_box_autoadd_u_32(self.sigops, serializer);
sse_encode_tx_status(self.status, serializer);
sse_encode_list_tx_input(self.vin, serializer);
sse_encode_list_tx_output(self.vout, serializer);
 }

@protected void sse_encode_block(Block self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_u_64(self.height, serializer);
sse_encode_u_32(self.version, serializer);
sse_encode_u_64(self.timestamp, serializer);
sse_encode_u_32(self.bits, serializer);
sse_encode_u_32(self.nonce, serializer);
sse_encode_f_64(self.difficulty, serializer);
sse_encode_String(self.merkleRoot, serializer);
sse_encode_u_32(self.txCount, serializer);
sse_encode_u_64(self.size, serializer);
sse_encode_u_64(self.weight, serializer);
sse_encode_opt_String(self.previousblockhash, serializer);
sse_encode_opt_box_autoadd_u_64(self.mediantime, serializer);
sse_encode_opt_box_autoadd_bool(self.stale, serializer);
sse_encode_opt_box_autoadd_block_extras(self.extras, serializer);
 }

@protected void sse_encode_block_extras(BlockExtras self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_f_64(self.medianFee, serializer);
sse_encode_opt_box_autoadd_u_64(self.totalFees, serializer);
sse_encode_opt_box_autoadd_f_64(self.avgFee, serializer);
sse_encode_opt_box_autoadd_f_64(self.avgFeeRate, serializer);
sse_encode_opt_box_autoadd_u_64(self.reward, serializer);
sse_encode_opt_box_autoadd_mining_pool(self.pool, serializer);
sse_encode_opt_box_autoadd_f_64(self.matchRate, serializer);
sse_encode_opt_box_autoadd_f_64(self.similarity, serializer);
 }

@protected void sse_encode_boltz_swap(BoltzSwap self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.swapId, serializer);
sse_encode_u_64(self.amountSats, serializer);
sse_encode_String(self.invoice, serializer);
 }

@protected void sse_encode_bool(bool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self ? 1 : 0); }

@protected void sse_encode_box_autoadd_block_extras(BlockExtras self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_block_extras(self, serializer); }

@protected void sse_encode_box_autoadd_boltz_swap(BoltzSwap self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_boltz_swap(self, serializer); }

@protected void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_bool(self, serializer); }

@protected void sse_encode_box_autoadd_contract_filters(ContractFilters self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_contract_filters(self, serializer); }

@protected void sse_encode_box_autoadd_conversions(Conversions self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_conversions(self, serializer); }

@protected void sse_encode_box_autoadd_difficulty_adjustment(DifficultyAdjustment self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_difficulty_adjustment(self, serializer); }

@protected void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_f_64(self, serializer); }

@protected void sse_encode_box_autoadd_fear_greed_data(FearGreedData self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_fear_greed_data(self, serializer); }

@protected void sse_encode_box_autoadd_fear_greed_last_updated(FearGreedLastUpdated self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_fear_greed_last_updated(self, serializer); }

@protected void sse_encode_box_autoadd_fear_greed_value(FearGreedValue self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_fear_greed_value(self, serializer); }

@protected void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self, serializer); }

@protected void sse_encode_box_autoadd_i_64(PlatformInt64 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_64(self, serializer); }

@protected void sse_encode_box_autoadd_mining_pool(MiningPool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_mining_pool(self, serializer); }

@protected void sse_encode_box_autoadd_offer_filters(OfferFilters self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_offer_filters(self, serializer); }

@protected void sse_encode_box_autoadd_recommended_fees(RecommendedFees self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_recommended_fees(self, serializer); }

@protected void sse_encode_box_autoadd_tx_output(TxOutput self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_tx_output(self, serializer); }

@protected void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_32(self, serializer); }

@protected void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self, serializer); }

@protected void sse_encode_btc_to_evm_swap_result(BtcToEvmSwapResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.swapId, serializer);
sse_encode_String(self.lnInvoice, serializer);
sse_encode_String(self.arkadeHtlcAddress, serializer);
sse_encode_i_64(self.satsToSend, serializer);
sse_encode_f_64(self.targetAmountUsd, serializer);
sse_encode_i_64(self.feeSats, serializer);
 }

@protected void sse_encode_claim_psbt_response(ClaimPsbtResponse self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.psbt, serializer);
sse_encode_String(self.collateralDescriptor, serializer);
sse_encode_String(self.borrowerPk, serializer);
 }

@protected void sse_encode_collateral_asset(CollateralAsset self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_contract(Contract self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_contract_status(self.status, serializer);
sse_encode_lender_stats(self.lender, serializer);
sse_encode_String(self.lenderPk, serializer);
sse_encode_String(self.borrowerPk, serializer);
sse_encode_String(self.borrowerBtcAddress, serializer);
sse_encode_opt_String(self.borrowerDerivationPath, serializer);
sse_encode_opt_String(self.borrowerLoanAddress, serializer);
sse_encode_loan_asset(self.loanAsset, serializer);
sse_encode_collateral_asset(self.collateralAsset, serializer);
sse_encode_f_64(self.loanAmount, serializer);
sse_encode_f_64(self.interest, serializer);
sse_encode_f_64(self.interestRate, serializer);
sse_encode_i_32(self.durationDays, serializer);
sse_encode_String(self.expiry, serializer);
sse_encode_i_64(self.collateralSats, serializer);
sse_encode_i_64(self.initialCollateralSats, serializer);
sse_encode_i_64(self.depositedSats, serializer);
sse_encode_f_64(self.initialLtv, serializer);
sse_encode_f_64(self.liquidationPrice, serializer);
sse_encode_f_64(self.ltvThresholdMarginCall1, serializer);
sse_encode_f_64(self.ltvThresholdMarginCall2, serializer);
sse_encode_f_64(self.ltvThresholdLiquidation, serializer);
sse_encode_f_64(self.balanceOutstanding, serializer);
sse_encode_opt_String(self.contractAddress, serializer);
sse_encode_opt_String(self.collateralScript, serializer);
sse_encode_opt_String(self.loanRepaymentAddress, serializer);
sse_encode_opt_String(self.btcLoanRepaymentAddress, serializer);
sse_encode_i_64(self.originationFeeSats, serializer);
sse_encode_list_installment(self.installments, serializer);
sse_encode_list_loan_transaction(self.transactions, serializer);
sse_encode_bool(self.canExtend, serializer);
sse_encode_opt_box_autoadd_f_64(self.extensionInterestRate, serializer);
sse_encode_i_32(self.extensionMaxDurationDays, serializer);
sse_encode_opt_String(self.extendsContract, serializer);
sse_encode_opt_String(self.extendedByContract, serializer);
sse_encode_opt_String(self.clientContractId, serializer);
sse_encode_opt_box_autoadd_bool(self.requiresArkSettlement, serializer);
sse_encode_String(self.createdAt, serializer);
sse_encode_String(self.updatedAt, serializer);
 }

@protected void sse_encode_contract_filters(ContractFilters self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_i_32(self.page, serializer);
sse_encode_opt_box_autoadd_i_32(self.limit, serializer);
sse_encode_opt_list_contract_status(self.status, serializer);
sse_encode_opt_String(self.sortBy, serializer);
sse_encode_opt_String(self.sortOrder, serializer);
 }

@protected void sse_encode_contract_status(ContractStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_conversions(Conversions self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self.time, serializer);
sse_encode_f_64(self.usd, serializer);
sse_encode_opt_box_autoadd_f_64(self.eur, serializer);
 }

@protected void sse_encode_currency_info(CurrencyInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.code, serializer);
sse_encode_f_64(self.minBuyAmount, serializer);
sse_encode_f_64(self.maxBuyAmount, serializer);
 }

@protected void sse_encode_difficulty_adjustment(DifficultyAdjustment self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_f_64(self.progressPercent, serializer);
sse_encode_f_64(self.difficultyChange, serializer);
sse_encode_u_64(self.estimatedRetargetDate, serializer);
sse_encode_u_32(self.remainingBlocks, serializer);
sse_encode_u_64(self.remainingTime, serializer);
sse_encode_opt_box_autoadd_f_64(self.previousRetarget, serializer);
sse_encode_opt_box_autoadd_u_64(self.previousTime, serializer);
sse_encode_u_64(self.nextRetargetHeight, serializer);
sse_encode_u_64(self.timeAvg, serializer);
sse_encode_opt_box_autoadd_u_64(self.adjustedTimeAvg, serializer);
sse_encode_i_64(self.timeOffset, serializer);
sse_encode_f_64(self.expectedBlocks, serializer);
 }

@protected void sse_encode_difficulty_point(DifficultyPoint self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_u_64(self.timestamp, serializer);
sse_encode_opt_box_autoadd_f_64(self.difficulty, serializer);
sse_encode_opt_box_autoadd_u_64(self.height, serializer);
 }

@protected void sse_encode_evm_to_btc_swap_result(EvmToBtcSwapResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.swapId, serializer);
sse_encode_String(self.evmHtlcAddress, serializer);
sse_encode_f_64(self.sourceAmountUsd, serializer);
sse_encode_i_64(self.satsToReceive, serializer);
sse_encode_i_64(self.feeSats, serializer);
sse_encode_String(self.sourceTokenAddress, serializer);
sse_encode_opt_String(self.createSwapTx, serializer);
sse_encode_opt_String(self.approveTx, serializer);
sse_encode_opt_String(self.gelatoForwarderAddress, serializer);
sse_encode_opt_String(self.gelatoUserNonce, serializer);
sse_encode_opt_String(self.gelatoUserDeadline, serializer);
 }

@protected void sse_encode_exchange_rates(ExchangeRates self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.base, serializer);
sse_encode_Map_String_f_64_None(self.rates, serializer);
sse_encode_i_64(self.timestamp, serializer);
 }

@protected void sse_encode_f_64(double self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putFloat64(self); }

@protected void sse_encode_fear_greed_data(FearGreedData self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_fear_greed_value(self.now, serializer);
sse_encode_opt_box_autoadd_fear_greed_value(self.previousClose, serializer);
sse_encode_opt_box_autoadd_fear_greed_value(self.oneWeekAgo, serializer);
sse_encode_opt_box_autoadd_fear_greed_value(self.oneMonthAgo, serializer);
sse_encode_opt_box_autoadd_fear_greed_value(self.oneYearAgo, serializer);
 }

@protected void sse_encode_fear_greed_index(FearGreedIndex self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_fear_greed_last_updated(self.lastUpdated, serializer);
sse_encode_opt_box_autoadd_fear_greed_data(self.fgi, serializer);
 }

@protected void sse_encode_fear_greed_last_updated(FearGreedLastUpdated self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_i_64(self.epochUnixSeconds, serializer);
sse_encode_opt_String(self.humanDate, serializer);
 }

@protected void sse_encode_fear_greed_value(FearGreedValue self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_i_32(self.value, serializer);
sse_encode_opt_String(self.valueText, serializer);
 }

@protected void sse_encode_fiat_currency(FiatCurrency self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_hashrate_data(HashrateData self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_f_64(self.currentHashrate, serializer);
sse_encode_opt_box_autoadd_f_64(self.currentDifficulty, serializer);
sse_encode_list_hashrate_point(self.hashrates, serializer);
sse_encode_list_difficulty_point(self.difficulty, serializer);
 }

@protected void sse_encode_hashrate_point(HashratePoint self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self.timestamp, serializer);
sse_encode_f_64(self.avgHashrate, serializer);
 }

@protected void sse_encode_historical_price_data(HistoricalPriceData self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.timestamp, serializer);
sse_encode_String(self.price, serializer);
 }

@protected void sse_encode_historical_price_response(HistoricalPriceResponse self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_historical_price_data(self.prices, serializer);
 }

@protected void sse_encode_i_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt32(self); }

@protected void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putPlatformInt64(self); }

@protected void sse_encode_info(Info self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.serverPk, serializer);
sse_encode_String(self.network, serializer);
 }

@protected void sse_encode_installment(Installment self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_String(self.dueDate, serializer);
sse_encode_f_64(self.principal, serializer);
sse_encode_f_64(self.interest, serializer);
sse_encode_installment_status(self.status, serializer);
sse_encode_opt_String(self.paidDate, serializer);
sse_encode_opt_String(self.paymentId, serializer);
 }

@protected void sse_encode_installment_status(InstallmentStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_lender_stats(LenderStats self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_String(self.name, serializer);
sse_encode_String(self.joinedAt, serializer);
sse_encode_i_32(self.successfulContracts, serializer);
sse_encode_bool(self.vetted, serializer);
sse_encode_opt_String(self.timezone, serializer);
 }

@protected void sse_encode_list_String(List<String> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_String(item, serializer); } }

@protected void sse_encode_list_bitcoin_transaction(List<BitcoinTransaction> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_bitcoin_transaction(item, serializer); } }

@protected void sse_encode_list_block(List<Block> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_block(item, serializer); } }

@protected void sse_encode_list_contract(List<Contract> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_contract(item, serializer); } }

@protected void sse_encode_list_contract_status(List<ContractStatus> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_contract_status(item, serializer); } }

@protected void sse_encode_list_difficulty_point(List<DifficultyPoint> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_difficulty_point(item, serializer); } }

@protected void sse_encode_list_fiat_currency(List<FiatCurrency> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_fiat_currency(item, serializer); } }

@protected void sse_encode_list_hashrate_point(List<HashratePoint> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_hashrate_point(item, serializer); } }

@protected void sse_encode_list_historical_price_data(List<HistoricalPriceData> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_historical_price_data(item, serializer); } }

@protected void sse_encode_list_installment(List<Installment> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_installment(item, serializer); } }

@protected void sse_encode_list_loan_offer(List<LoanOffer> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_loan_offer(item, serializer); } }

@protected void sse_encode_list_loan_transaction(List<LoanTransaction> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_loan_transaction(item, serializer); } }

@protected void sse_encode_list_mempool_block(List<MempoolBlock> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_mempool_block(item, serializer); } }

@protected void sse_encode_list_origination_fee(List<OriginationFee> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_origination_fee(item, serializer); } }

@protected void sse_encode_list_prim_f_64_strict(Float64List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putFloat64List(self); }

@protected void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self); }

@protected void sse_encode_list_projected_transaction(List<ProjectedTransaction> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_projected_transaction(item, serializer); } }

@protected void sse_encode_list_record_string_f_64(List<(String,double)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_f_64(item, serializer); } }

@protected void sse_encode_list_swap_info(List<SwapInfo> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_swap_info(item, serializer); } }

@protected void sse_encode_list_trading_pair(List<TradingPair> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_trading_pair(item, serializer); } }

@protected void sse_encode_list_transaction(List<Transaction> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_transaction(item, serializer); } }

@protected void sse_encode_list_tx_input(List<TxInput> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_tx_input(item, serializer); } }

@protected void sse_encode_list_tx_output(List<TxOutput> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_tx_output(item, serializer); } }

@protected void sse_encode_ln_payment_result(LnPaymentResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.swapId, serializer);
sse_encode_String(self.txid, serializer);
sse_encode_u_64(self.amountSats, serializer);
 }

@protected void sse_encode_loan_asset(LoanAsset self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_loan_offer(LoanOffer self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_String(self.name, serializer);
sse_encode_lender_stats(self.lender, serializer);
sse_encode_String(self.lenderPk, serializer);
sse_encode_loan_asset(self.loanAsset, serializer);
sse_encode_collateral_asset(self.collateralAsset, serializer);
sse_encode_f_64(self.loanAmountMin, serializer);
sse_encode_f_64(self.loanAmountMax, serializer);
sse_encode_i_32(self.durationDaysMin, serializer);
sse_encode_i_32(self.durationDaysMax, serializer);
sse_encode_f_64(self.interestRate, serializer);
sse_encode_f_64(self.minLtv, serializer);
sse_encode_loan_payout(self.loanPayout, serializer);
sse_encode_String(self.loanRepaymentAddress, serializer);
sse_encode_list_origination_fee(self.originationFee, serializer);
sse_encode_repayment_plan(self.repaymentPlan, serializer);
sse_encode_loan_offer_status(self.status, serializer);
sse_encode_opt_String(self.kycLink, serializer);
 }

@protected void sse_encode_loan_offer_status(LoanOfferStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_loan_payout(LoanPayout self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_loan_transaction(LoanTransaction self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_64(self.id, serializer);
sse_encode_String(self.contractId, serializer);
sse_encode_String(self.transactionType, serializer);
sse_encode_String(self.txid, serializer);
sse_encode_String(self.timestamp, serializer);
 }

@protected void sse_encode_log_entry(LogEntry self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.msg, serializer);
sse_encode_String(self.target, serializer);
sse_encode_String(self.level, serializer);
sse_encode_String(self.file, serializer);
sse_encode_String(self.line, serializer);
sse_encode_String(self.modulePath, serializer);
sse_encode_String(self.data, serializer);
 }

@protected void sse_encode_mempool_block(MempoolBlock self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self.blockSize, serializer);
sse_encode_f_64(self.blockVsize, serializer);
sse_encode_u_32(self.nTx, serializer);
sse_encode_u_64(self.totalFees, serializer);
sse_encode_f_64(self.medianFee, serializer);
sse_encode_list_prim_f_64_strict(self.feeRange, serializer);
 }

@protected void sse_encode_mempool_ws_message(MempoolWsMessage self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_list_mempool_block(self.mempoolBlocks, serializer);
sse_encode_opt_list_block(self.blocks, serializer);
sse_encode_opt_box_autoadd_conversions(self.conversions, serializer);
sse_encode_opt_box_autoadd_recommended_fees(self.fees, serializer);
sse_encode_opt_box_autoadd_difficulty_adjustment(self.da, serializer);
 }

@protected void sse_encode_mining_pool(MiningPool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_box_autoadd_u_32(self.id, serializer);
sse_encode_String(self.name, serializer);
sse_encode_opt_String(self.slug, serializer);
 }

@protected void sse_encode_moon_pay_currency_limits(MoonPayCurrencyLimits self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_currency_info(self.quoteCurrency, serializer);
sse_encode_currency_info(self.baseCurrency, serializer);
 }

@protected void sse_encode_moon_pay_encrypted_data(MoonPayEncryptedData self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.ciphertext, serializer);
sse_encode_String(self.iv, serializer);
 }

@protected void sse_encode_moon_pay_quote(MoonPayQuote self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_f_64(self.baseCurrencyAmount, serializer);
sse_encode_f_64(self.quoteCurrencyAmount, serializer);
sse_encode_String(self.baseCurrencyCode, serializer);
sse_encode_f_64(self.exchangeRate, serializer);
sse_encode_String(self.timestamp, serializer);
 }

@protected void sse_encode_offchain_balance(OffchainBalance self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self.pendingSats, serializer);
sse_encode_u_64(self.confirmedSats, serializer);
sse_encode_u_64(self.totalSats, serializer);
 }

@protected void sse_encode_offer_filters(OfferFilters self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_String(self.loanType, serializer);
sse_encode_opt_String(self.assetType, serializer);
sse_encode_opt_String(self.loanAssets, serializer);
sse_encode_opt_String(self.kyc, serializer);
sse_encode_opt_box_autoadd_f_64(self.minLoanAmount, serializer);
sse_encode_opt_box_autoadd_f_64(self.maxLoanAmount, serializer);
sse_encode_opt_box_autoadd_f_64(self.maxInterestRate, serializer);
sse_encode_opt_box_autoadd_i_32(self.durationMin, serializer);
sse_encode_opt_box_autoadd_i_32(self.durationMax, serializer);
sse_encode_opt_String(self.collateralAssetType, serializer);
 }

@protected void sse_encode_opt_String(String? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_String(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_block_extras(BlockExtras? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_block_extras(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_boltz_swap(BoltzSwap? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_boltz_swap(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_bool(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_contract_filters(ContractFilters? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_contract_filters(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_conversions(Conversions? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_conversions(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_difficulty_adjustment(DifficultyAdjustment? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_difficulty_adjustment(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_f_64(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_fear_greed_data(FearGreedData? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_fear_greed_data(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_fear_greed_last_updated(FearGreedLastUpdated? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_fear_greed_last_updated(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_fear_greed_value(FearGreedValue? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_fear_greed_value(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_i_32(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_i_64(PlatformInt64? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_i_64(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_mining_pool(MiningPool? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_mining_pool(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_offer_filters(OfferFilters? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_offer_filters(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_recommended_fees(RecommendedFees? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_recommended_fees(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_tx_output(TxOutput? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_tx_output(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_u_32(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_u_64(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_String(List<String>? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_String(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_block(List<Block>? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_block(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_contract_status(List<ContractStatus>? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_contract_status(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_mempool_block(List<MempoolBlock>? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_mempool_block(self, serializer);
                }
                 }

@protected void sse_encode_origination_fee(OriginationFee self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_f_64(self.fee, serializer);
sse_encode_i_32(self.fromDay, serializer);
 }

@protected void sse_encode_paginated_contracts_response(PaginatedContractsResponse self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_contract(self.data, serializer);
sse_encode_i_32(self.page, serializer);
sse_encode_i_32(self.limit, serializer);
sse_encode_i_32(self.total, serializer);
sse_encode_i_32(self.totalPages, serializer);
 }

@protected void sse_encode_payment_received(PaymentReceived self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.txid, serializer);
sse_encode_u_64(self.amountSats, serializer);
 }

@protected void sse_encode_projected_block_transactions(ProjectedBlockTransactions self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_32(self.index, serializer);
sse_encode_list_projected_transaction(self.transactions, serializer);
 }

@protected void sse_encode_projected_transaction(ProjectedTransaction self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.txid, serializer);
sse_encode_u_64(self.value, serializer);
sse_encode_u_32(self.vsize, serializer);
sse_encode_f_64(self.feeRate, serializer);
sse_encode_u_32(self.flags, serializer);
 }

@protected void sse_encode_recommended_fees(RecommendedFees self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_f_64(self.fastestFee, serializer);
sse_encode_f_64(self.halfHourFee, serializer);
sse_encode_f_64(self.hourFee, serializer);
sse_encode_f_64(self.economyFee, serializer);
sse_encode_f_64(self.minimumFee, serializer);
 }

@protected void sse_encode_record_string_f_64((String,double) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_f_64(self.$2, serializer);
 }

@protected void sse_encode_repayment_plan(RepaymentPlan self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_settle_ark_psbt_response(SettleArkPsbtResponse self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.intentMessage, serializer);
sse_encode_String(self.intentProof, serializer);
sse_encode_list_String(self.forfeitPsbts, serializer);
sse_encode_String(self.delegateCosignerPk, serializer);
sse_encode_String(self.userPk, serializer);
sse_encode_opt_String(self.derivationPath, serializer);
 }

@protected void sse_encode_swap_info(SwapInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_swap_status_simple(self.status, serializer);
sse_encode_String(self.direction, serializer);
sse_encode_String(self.sourceToken, serializer);
sse_encode_String(self.targetToken, serializer);
sse_encode_i_64(self.sourceAmountSats, serializer);
sse_encode_f_64(self.targetAmountUsd, serializer);
sse_encode_String(self.createdAt, serializer);
sse_encode_opt_String(self.lnInvoice, serializer);
sse_encode_opt_String(self.arkadeHtlcAddress, serializer);
sse_encode_opt_String(self.evmHtlcAddress, serializer);
sse_encode_i_64(self.feeSats, serializer);
sse_encode_bool(self.canClaimGelato, serializer);
sse_encode_bool(self.canClaimVhtlc, serializer);
sse_encode_bool(self.canRefund, serializer);
sse_encode_String(self.detailedStatus, serializer);
 }

@protected void sse_encode_swap_quote(SwapQuote self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.exchangeRate, serializer);
sse_encode_u_64(self.networkFeeSats, serializer);
sse_encode_u_64(self.protocolFeeSats, serializer);
sse_encode_f_64(self.protocolFeePercent, serializer);
sse_encode_u_64(self.minAmountSats, serializer);
sse_encode_u_64(self.maxAmountSats, serializer);
 }

@protected void sse_encode_swap_status_simple(SwapStatusSimple self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_trading_pair(TradingPair self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_asset_info(self.source, serializer);
sse_encode_asset_info(self.target, serializer);
 }

@protected void sse_encode_transaction(Transaction self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
switch (self) { case Transaction_Boarding(txid: final txid,amountSats: final amountSats,confirmedAt: final confirmedAt): sse_encode_i_32(0, serializer); sse_encode_String(txid, serializer);
sse_encode_u_64(amountSats, serializer);
sse_encode_opt_box_autoadd_i_64(confirmedAt, serializer);
case Transaction_Round(txid: final txid,amountSats: final amountSats,createdAt: final createdAt): sse_encode_i_32(1, serializer); sse_encode_String(txid, serializer);
sse_encode_i_64(amountSats, serializer);
sse_encode_i_64(createdAt, serializer);
case Transaction_Redeem(txid: final txid,amountSats: final amountSats,isSettled: final isSettled,createdAt: final createdAt): sse_encode_i_32(2, serializer); sse_encode_String(txid, serializer);
sse_encode_i_64(amountSats, serializer);
sse_encode_bool(isSettled, serializer);
sse_encode_i_64(createdAt, serializer);
  } }

@protected void sse_encode_tx_input(TxInput self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.txid, serializer);
sse_encode_u_32(self.vout, serializer);
sse_encode_opt_box_autoadd_tx_output(self.prevout, serializer);
sse_encode_String(self.scriptsig, serializer);
sse_encode_String(self.scriptsigAsm, serializer);
sse_encode_opt_list_String(self.witness, serializer);
sse_encode_bool(self.isCoinbase, serializer);
sse_encode_u_32(self.sequence, serializer);
 }

@protected void sse_encode_tx_output(TxOutput self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.scriptpubkey, serializer);
sse_encode_String(self.scriptpubkeyAsm, serializer);
sse_encode_String(self.scriptpubkeyType, serializer);
sse_encode_opt_String(self.scriptpubkeyAddress, serializer);
sse_encode_u_64(self.value, serializer);
 }

@protected void sse_encode_tx_status(TxStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_bool(self.confirmed, serializer);
sse_encode_opt_box_autoadd_u_64(self.blockHeight, serializer);
sse_encode_opt_String(self.blockHash, serializer);
sse_encode_opt_box_autoadd_u_64(self.blockTime, serializer);
 }

@protected void sse_encode_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint32(self); }

@protected void sse_encode_u_64(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putBigUint64(self); }

@protected void sse_encode_u_8(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self); }

@protected void sse_encode_unit(void self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }
                }
                
