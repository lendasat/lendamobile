// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'api/ark_api.dart';
import 'api/bitcoin_api.dart';
import 'api/mempool_api.dart';
import 'api/mempool_block_tracker.dart';
import 'api/mempool_ws.dart';
import 'api/moonpay_api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'logger.dart';
import 'models/exchange_rates.dart';
import 'models/historical_prices.dart';
import 'models/mempool.dart';
import 'models/moonpay.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -927650036;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_ark_flutter',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<Addresses> crateApiArkApiAddress({BigInt? amount});

  Future<Balance> crateApiArkApiBalance();

  String crateApiCurrencyCode({required FiatCurrency currency});

  Future<ExchangeRates> crateApiFetchExchangeRates();

  Future<HistoricalPriceResponse> crateApiBitcoinApiFetchHistoricalPrices(
      {required String serverUrl, required String timeRange});

  Future<Block> crateApiGetBlockByHash({required String hash});

  Future<Block> crateApiMempoolApiGetBlockByHash({required String hash});

  Future<List<BitcoinTransaction>> crateApiGetBlockTransactions(
      {required String hash, required int startIndex});

  Future<List<BitcoinTransaction>> crateApiMempoolApiGetBlockTransactions(
      {required String hash, required int startIndex});

  Future<List<Block>> crateApiGetBlocks();

  Future<List<Block>> crateApiMempoolApiGetBlocks();

  Future<List<Block>> crateApiGetBlocksAtHeight({required BigInt height});

  Future<List<Block>> crateApiMempoolApiGetBlocksAtHeight(
      {required BigInt height});

  Future<FearGreedIndex> crateApiMempoolApiGetFearGreedIndex();

  Future<HashrateData> crateApiGetHashrateData({required String period});

  Future<HashrateData> crateApiMempoolApiGetHashrateData(
      {required String period});

  Future<RecommendedFees> crateApiGetRecommendedFees();

  Future<RecommendedFees> crateApiMempoolApiGetRecommendedFees();

  List<FiatCurrency> crateApiGetSupportedCurrencies();

  Future<BitcoinTransaction> crateApiGetTransaction({required String txid});

  Future<BitcoinTransaction> crateApiMempoolApiGetTransaction(
      {required String txid, required String baseUrl});

  Future<Info> crateApiArkApiInformation();

  Future<void> crateApiInitApp();

  Stream<LogEntry> crateApiInitLogging();

  Future<String> crateApiArkApiLoadExistingWallet(
      {required String dataDir,
      required String network,
      required String esplora,
      required String server,
      required String boltzUrl});

  Future<MoonPayEncryptedData> crateApiMoonpayEncryptData(
      {required String serverUrl, required String data});

  Future<MoonPayEncryptedData> crateApiMoonpayApiMoonpayEncryptData(
      {required String serverUrl, required String data});

  Future<MoonPayCurrencyLimits> crateApiMoonpayGetCurrencyLimits(
      {required String serverUrl,
      required String baseCurrencyCode,
      required String paymentMethod});

  Future<MoonPayCurrencyLimits> crateApiMoonpayApiMoonpayGetCurrencyLimits(
      {required String serverUrl,
      required String baseCurrencyCode,
      required String paymentMethod});

  Future<MoonPayQuote> crateApiMoonpayGetQuote({required String serverUrl});

  Future<MoonPayQuote> crateApiMoonpayApiMoonpayGetQuote(
      {required String serverUrl});

  Future<String> crateApiArkApiNsec({required String dataDir});

  Future<LnPaymentResult> crateApiArkApiPayLnInvoice({required String invoice});

  Future<void> crateApiArkApiResetWallet({required String dataDir});

  Future<String> crateApiArkApiRestoreWallet(
      {required String nsec,
      required String dataDir,
      required String network,
      required String esplora,
      required String server,
      required String boltzUrl});

  Future<String> crateApiArkApiSend(
      {required String address, required BigInt amountSats});

  Future<void> crateApiArkApiSettle();

  Future<String> crateApiArkApiSetupNewWallet(
      {required String dataDir,
      required String network,
      required String esplora,
      required String server,
      required String boltzUrl});

  Stream<MempoolWsMessage> crateApiSubscribeMempoolUpdates();

  Stream<MempoolWsMessage> crateApiMempoolWsSubscribeMempoolUpdates();

  Stream<ProjectedBlockTransactions> crateApiTrackMempoolBlock(
      {required int blockIndex});

  Stream<ProjectedBlockTransactions>
      crateApiMempoolBlockTrackerTrackMempoolBlock({required int blockIndex});

  Future<List<Transaction>> crateApiArkApiTxHistory();

  Future<PaymentReceived> crateApiArkApiWaitForPayment(
      {String? arkAddress,
      String? boardingAddress,
      String? boltzSwapId,
      required BigInt timeoutSeconds});

  Future<bool> crateApiArkApiWalletExists({required String dataDir});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<Addresses> crateApiArkApiAddress({BigInt? amount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_box_autoadd_u_64(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_addresses,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiAddressConstMeta,
      argValues: [amount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiAddressConstMeta => const TaskConstMeta(
        debugName: "address",
        argNames: ["amount"],
      );

  @override
  Future<Balance> crateApiArkApiBalance() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_balance,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiBalanceConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiBalanceConstMeta => const TaskConstMeta(
        debugName: "balance",
        argNames: [],
      );

  @override
  String crateApiCurrencyCode({required FiatCurrency currency}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_fiat_currency(currency, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCurrencyCodeConstMeta,
      argValues: [currency],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCurrencyCodeConstMeta => const TaskConstMeta(
        debugName: "currency_code",
        argNames: ["currency"],
      );

  @override
  Future<ExchangeRates> crateApiFetchExchangeRates() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_exchange_rates,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiFetchExchangeRatesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFetchExchangeRatesConstMeta => const TaskConstMeta(
        debugName: "fetch_exchange_rates",
        argNames: [],
      );

  @override
  Future<HistoricalPriceResponse> crateApiBitcoinApiFetchHistoricalPrices(
      {required String serverUrl, required String timeRange}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(serverUrl, serializer);
        sse_encode_String(timeRange, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_historical_price_response,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBitcoinApiFetchHistoricalPricesConstMeta,
      argValues: [serverUrl, timeRange],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinApiFetchHistoricalPricesConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_historical_prices",
        argNames: ["serverUrl", "timeRange"],
      );

  @override
  Future<Block> crateApiGetBlockByHash({required String hash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(hash, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_block,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetBlockByHashConstMeta,
      argValues: [hash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetBlockByHashConstMeta => const TaskConstMeta(
        debugName: "get_block_by_hash",
        argNames: ["hash"],
      );

  @override
  Future<Block> crateApiMempoolApiGetBlockByHash({required String hash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(hash, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_block,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetBlockByHashConstMeta,
      argValues: [hash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetBlockByHashConstMeta =>
      const TaskConstMeta(
        debugName: "get_block_by_hash",
        argNames: ["hash"],
      );

  @override
  Future<List<BitcoinTransaction>> crateApiGetBlockTransactions(
      {required String hash, required int startIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(hash, serializer);
        sse_encode_u_32(startIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_bitcoin_transaction,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetBlockTransactionsConstMeta,
      argValues: [hash, startIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetBlockTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "get_block_transactions",
        argNames: ["hash", "startIndex"],
      );

  @override
  Future<List<BitcoinTransaction>> crateApiMempoolApiGetBlockTransactions(
      {required String hash, required int startIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(hash, serializer);
        sse_encode_u_32(startIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_bitcoin_transaction,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetBlockTransactionsConstMeta,
      argValues: [hash, startIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetBlockTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "get_block_transactions",
        argNames: ["hash", "startIndex"],
      );

  @override
  Future<List<Block>> crateApiGetBlocks() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_block,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetBlocksConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetBlocksConstMeta => const TaskConstMeta(
        debugName: "get_blocks",
        argNames: [],
      );

  @override
  Future<List<Block>> crateApiMempoolApiGetBlocks() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_block,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetBlocksConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetBlocksConstMeta =>
      const TaskConstMeta(
        debugName: "get_blocks",
        argNames: [],
      );

  @override
  Future<List<Block>> crateApiGetBlocksAtHeight({required BigInt height}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(height, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_block,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetBlocksAtHeightConstMeta,
      argValues: [height],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetBlocksAtHeightConstMeta => const TaskConstMeta(
        debugName: "get_blocks_at_height",
        argNames: ["height"],
      );

  @override
  Future<List<Block>> crateApiMempoolApiGetBlocksAtHeight(
      {required BigInt height}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(height, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_block,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetBlocksAtHeightConstMeta,
      argValues: [height],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetBlocksAtHeightConstMeta =>
      const TaskConstMeta(
        debugName: "get_blocks_at_height",
        argNames: ["height"],
      );

  @override
  Future<FearGreedIndex> crateApiMempoolApiGetFearGreedIndex() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_fear_greed_index,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetFearGreedIndexConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetFearGreedIndexConstMeta =>
      const TaskConstMeta(
        debugName: "get_fear_greed_index",
        argNames: [],
      );

  @override
  Future<HashrateData> crateApiGetHashrateData({required String period}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(period, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_hashrate_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetHashrateDataConstMeta,
      argValues: [period],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetHashrateDataConstMeta => const TaskConstMeta(
        debugName: "get_hashrate_data",
        argNames: ["period"],
      );

  @override
  Future<HashrateData> crateApiMempoolApiGetHashrateData(
      {required String period}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(period, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_hashrate_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetHashrateDataConstMeta,
      argValues: [period],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetHashrateDataConstMeta =>
      const TaskConstMeta(
        debugName: "get_hashrate_data",
        argNames: ["period"],
      );

  @override
  Future<RecommendedFees> crateApiGetRecommendedFees() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_recommended_fees,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetRecommendedFeesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetRecommendedFeesConstMeta => const TaskConstMeta(
        debugName: "get_recommended_fees",
        argNames: [],
      );

  @override
  Future<RecommendedFees> crateApiMempoolApiGetRecommendedFees() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_recommended_fees,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetRecommendedFeesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetRecommendedFeesConstMeta =>
      const TaskConstMeta(
        debugName: "get_recommended_fees",
        argNames: [],
      );

  @override
  List<FiatCurrency> crateApiGetSupportedCurrencies() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_fiat_currency,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetSupportedCurrenciesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetSupportedCurrenciesConstMeta =>
      const TaskConstMeta(
        debugName: "get_supported_currencies",
        argNames: [],
      );

  @override
  Future<BitcoinTransaction> crateApiGetTransaction({required String txid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(txid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bitcoin_transaction,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetTransactionConstMeta,
      argValues: [txid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetTransactionConstMeta => const TaskConstMeta(
        debugName: "get_transaction",
        argNames: ["txid"],
      );

  @override
  Future<BitcoinTransaction> crateApiMempoolApiGetTransaction(
      {required String txid, required String baseUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(txid, serializer);
        sse_encode_String(baseUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bitcoin_transaction,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolApiGetTransactionConstMeta,
      argValues: [txid, baseUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMempoolApiGetTransactionConstMeta =>
      const TaskConstMeta(
        debugName: "get_transaction",
        argNames: ["txid", "baseUrl"],
      );

  @override
  Future<Info> crateApiArkApiInformation() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiInformationConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiInformationConstMeta => const TaskConstMeta(
        debugName: "information",
        argNames: [],
      );

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Stream<LogEntry> crateApiInitLogging() {
    final sink = RustStreamSink<LogEntry>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_log_entry_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitLoggingConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiInitLoggingConstMeta => const TaskConstMeta(
        debugName: "init_logging",
        argNames: ["sink"],
      );

  @override
  Future<String> crateApiArkApiLoadExistingWallet(
      {required String dataDir,
      required String network,
      required String esplora,
      required String server,
      required String boltzUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dataDir, serializer);
        sse_encode_String(network, serializer);
        sse_encode_String(esplora, serializer);
        sse_encode_String(server, serializer);
        sse_encode_String(boltzUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiLoadExistingWalletConstMeta,
      argValues: [dataDir, network, esplora, server, boltzUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiLoadExistingWalletConstMeta =>
      const TaskConstMeta(
        debugName: "load_existing_wallet",
        argNames: ["dataDir", "network", "esplora", "server", "boltzUrl"],
      );

  @override
  Future<MoonPayEncryptedData> crateApiMoonpayEncryptData(
      {required String serverUrl, required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(serverUrl, serializer);
        sse_encode_String(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_moon_pay_encrypted_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMoonpayEncryptDataConstMeta,
      argValues: [serverUrl, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMoonpayEncryptDataConstMeta => const TaskConstMeta(
        debugName: "moonpay_encrypt_data",
        argNames: ["serverUrl", "data"],
      );

  @override
  Future<MoonPayEncryptedData> crateApiMoonpayApiMoonpayEncryptData(
      {required String serverUrl, required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(serverUrl, serializer);
        sse_encode_String(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_moon_pay_encrypted_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMoonpayApiMoonpayEncryptDataConstMeta,
      argValues: [serverUrl, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMoonpayApiMoonpayEncryptDataConstMeta =>
      const TaskConstMeta(
        debugName: "moonpay_encrypt_data",
        argNames: ["serverUrl", "data"],
      );

  @override
  Future<MoonPayCurrencyLimits> crateApiMoonpayGetCurrencyLimits(
      {required String serverUrl,
      required String baseCurrencyCode,
      required String paymentMethod}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(serverUrl, serializer);
        sse_encode_String(baseCurrencyCode, serializer);
        sse_encode_String(paymentMethod, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_moon_pay_currency_limits,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMoonpayGetCurrencyLimitsConstMeta,
      argValues: [serverUrl, baseCurrencyCode, paymentMethod],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMoonpayGetCurrencyLimitsConstMeta =>
      const TaskConstMeta(
        debugName: "moonpay_get_currency_limits",
        argNames: ["serverUrl", "baseCurrencyCode", "paymentMethod"],
      );

  @override
  Future<MoonPayCurrencyLimits> crateApiMoonpayApiMoonpayGetCurrencyLimits(
      {required String serverUrl,
      required String baseCurrencyCode,
      required String paymentMethod}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(serverUrl, serializer);
        sse_encode_String(baseCurrencyCode, serializer);
        sse_encode_String(paymentMethod, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_moon_pay_currency_limits,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMoonpayApiMoonpayGetCurrencyLimitsConstMeta,
      argValues: [serverUrl, baseCurrencyCode, paymentMethod],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMoonpayApiMoonpayGetCurrencyLimitsConstMeta =>
      const TaskConstMeta(
        debugName: "moonpay_get_currency_limits",
        argNames: ["serverUrl", "baseCurrencyCode", "paymentMethod"],
      );

  @override
  Future<MoonPayQuote> crateApiMoonpayGetQuote({required String serverUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(serverUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_moon_pay_quote,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMoonpayGetQuoteConstMeta,
      argValues: [serverUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMoonpayGetQuoteConstMeta => const TaskConstMeta(
        debugName: "moonpay_get_quote",
        argNames: ["serverUrl"],
      );

  @override
  Future<MoonPayQuote> crateApiMoonpayApiMoonpayGetQuote(
      {required String serverUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(serverUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_moon_pay_quote,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMoonpayApiMoonpayGetQuoteConstMeta,
      argValues: [serverUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMoonpayApiMoonpayGetQuoteConstMeta =>
      const TaskConstMeta(
        debugName: "moonpay_get_quote",
        argNames: ["serverUrl"],
      );

  @override
  Future<String> crateApiArkApiNsec({required String dataDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dataDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiNsecConstMeta,
      argValues: [dataDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiNsecConstMeta => const TaskConstMeta(
        debugName: "nsec",
        argNames: ["dataDir"],
      );

  @override
  Future<LnPaymentResult> crateApiArkApiPayLnInvoice(
      {required String invoice}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(invoice, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ln_payment_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiPayLnInvoiceConstMeta,
      argValues: [invoice],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiPayLnInvoiceConstMeta => const TaskConstMeta(
        debugName: "pay_ln_invoice",
        argNames: ["invoice"],
      );

  @override
  Future<void> crateApiArkApiResetWallet({required String dataDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dataDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiResetWalletConstMeta,
      argValues: [dataDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiResetWalletConstMeta => const TaskConstMeta(
        debugName: "reset_wallet",
        argNames: ["dataDir"],
      );

  @override
  Future<String> crateApiArkApiRestoreWallet(
      {required String nsec,
      required String dataDir,
      required String network,
      required String esplora,
      required String server,
      required String boltzUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(nsec, serializer);
        sse_encode_String(dataDir, serializer);
        sse_encode_String(network, serializer);
        sse_encode_String(esplora, serializer);
        sse_encode_String(server, serializer);
        sse_encode_String(boltzUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiRestoreWalletConstMeta,
      argValues: [nsec, dataDir, network, esplora, server, boltzUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiRestoreWalletConstMeta =>
      const TaskConstMeta(
        debugName: "restore_wallet",
        argNames: [
          "nsec",
          "dataDir",
          "network",
          "esplora",
          "server",
          "boltzUrl"
        ],
      );

  @override
  Future<String> crateApiArkApiSend(
      {required String address, required BigInt amountSats}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        sse_encode_u_64(amountSats, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiSendConstMeta,
      argValues: [address, amountSats],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiSendConstMeta => const TaskConstMeta(
        debugName: "send",
        argNames: ["address", "amountSats"],
      );

  @override
  Future<void> crateApiArkApiSettle() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiSettleConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiSettleConstMeta => const TaskConstMeta(
        debugName: "settle",
        argNames: [],
      );

  @override
  Future<String> crateApiArkApiSetupNewWallet(
      {required String dataDir,
      required String network,
      required String esplora,
      required String server,
      required String boltzUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dataDir, serializer);
        sse_encode_String(network, serializer);
        sse_encode_String(esplora, serializer);
        sse_encode_String(server, serializer);
        sse_encode_String(boltzUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiSetupNewWalletConstMeta,
      argValues: [dataDir, network, esplora, server, boltzUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiSetupNewWalletConstMeta =>
      const TaskConstMeta(
        debugName: "setup_new_wallet",
        argNames: ["dataDir", "network", "esplora", "server", "boltzUrl"],
      );

  @override
  Stream<MempoolWsMessage> crateApiSubscribeMempoolUpdates() {
    final sink = RustStreamSink<MempoolWsMessage>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_mempool_ws_message_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSubscribeMempoolUpdatesConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiSubscribeMempoolUpdatesConstMeta =>
      const TaskConstMeta(
        debugName: "subscribe_mempool_updates",
        argNames: ["sink"],
      );

  @override
  Stream<MempoolWsMessage> crateApiMempoolWsSubscribeMempoolUpdates() {
    final sink = RustStreamSink<MempoolWsMessage>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_mempool_ws_message_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolWsSubscribeMempoolUpdatesConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiMempoolWsSubscribeMempoolUpdatesConstMeta =>
      const TaskConstMeta(
        debugName: "subscribe_mempool_updates",
        argNames: ["sink"],
      );

  @override
  Stream<ProjectedBlockTransactions> crateApiTrackMempoolBlock(
      {required int blockIndex}) {
    final sink = RustStreamSink<ProjectedBlockTransactions>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(blockIndex, serializer);
        sse_encode_StreamSink_projected_block_transactions_Sse(
            sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiTrackMempoolBlockConstMeta,
      argValues: [blockIndex, sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiTrackMempoolBlockConstMeta => const TaskConstMeta(
        debugName: "track_mempool_block",
        argNames: ["blockIndex", "sink"],
      );

  @override
  Stream<ProjectedBlockTransactions>
      crateApiMempoolBlockTrackerTrackMempoolBlock({required int blockIndex}) {
    final sink = RustStreamSink<ProjectedBlockTransactions>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(blockIndex, serializer);
        sse_encode_StreamSink_projected_block_transactions_Sse(
            sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMempoolBlockTrackerTrackMempoolBlockConstMeta,
      argValues: [blockIndex, sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiMempoolBlockTrackerTrackMempoolBlockConstMeta =>
      const TaskConstMeta(
        debugName: "track_mempool_block",
        argNames: ["blockIndex", "sink"],
      );

  @override
  Future<List<Transaction>> crateApiArkApiTxHistory() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_transaction,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiTxHistoryConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiTxHistoryConstMeta => const TaskConstMeta(
        debugName: "tx_history",
        argNames: [],
      );

  @override
  Future<PaymentReceived> crateApiArkApiWaitForPayment(
      {String? arkAddress,
      String? boardingAddress,
      String? boltzSwapId,
      required BigInt timeoutSeconds}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_String(arkAddress, serializer);
        sse_encode_opt_String(boardingAddress, serializer);
        sse_encode_opt_String(boltzSwapId, serializer);
        sse_encode_u_64(timeoutSeconds, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_payment_received,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiWaitForPaymentConstMeta,
      argValues: [arkAddress, boardingAddress, boltzSwapId, timeoutSeconds],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiWaitForPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "wait_for_payment",
        argNames: [
          "arkAddress",
          "boardingAddress",
          "boltzSwapId",
          "timeoutSeconds"
        ],
      );

  @override
  Future<bool> crateApiArkApiWalletExists({required String dataDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dataDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiArkApiWalletExistsConstMeta,
      argValues: [dataDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiArkApiWalletExistsConstMeta => const TaskConstMeta(
        debugName: "wallet_exists",
        argNames: ["dataDir"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Map<String, double> dco_decode_Map_String_f_64_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_f_64(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<MempoolWsMessage> dco_decode_StreamSink_mempool_ws_message_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<ProjectedBlockTransactions>
      dco_decode_StreamSink_projected_block_transactions_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Addresses dco_decode_addresses(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Addresses(
      boarding: dco_decode_String(arr[0]),
      offchain: dco_decode_String(arr[1]),
      bip21: dco_decode_String(arr[2]),
      lightning: dco_decode_opt_box_autoadd_boltz_swap(arr[3]),
    );
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Balance(
      offchain: dco_decode_offchain_balance(arr[0]),
    );
  }

  @protected
  BitcoinTransaction dco_decode_bitcoin_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return BitcoinTransaction(
      txid: dco_decode_String(arr[0]),
      version: dco_decode_u_32(arr[1]),
      locktime: dco_decode_u_32(arr[2]),
      size: dco_decode_u_32(arr[3]),
      weight: dco_decode_u_32(arr[4]),
      fee: dco_decode_u_64(arr[5]),
      sigops: dco_decode_opt_box_autoadd_u_32(arr[6]),
      status: dco_decode_tx_status(arr[7]),
      vin: dco_decode_list_tx_input(arr[8]),
      vout: dco_decode_list_tx_output(arr[9]),
    );
  }

  @protected
  Block dco_decode_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 15)
      throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
    return Block(
      id: dco_decode_String(arr[0]),
      height: dco_decode_u_64(arr[1]),
      version: dco_decode_u_32(arr[2]),
      timestamp: dco_decode_u_64(arr[3]),
      bits: dco_decode_u_32(arr[4]),
      nonce: dco_decode_u_32(arr[5]),
      difficulty: dco_decode_f_64(arr[6]),
      merkleRoot: dco_decode_String(arr[7]),
      txCount: dco_decode_u_32(arr[8]),
      size: dco_decode_u_64(arr[9]),
      weight: dco_decode_u_64(arr[10]),
      previousblockhash: dco_decode_opt_String(arr[11]),
      mediantime: dco_decode_opt_box_autoadd_u_64(arr[12]),
      stale: dco_decode_opt_box_autoadd_bool(arr[13]),
      extras: dco_decode_opt_box_autoadd_block_extras(arr[14]),
    );
  }

  @protected
  BlockExtras dco_decode_block_extras(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return BlockExtras(
      medianFee: dco_decode_opt_box_autoadd_f_64(arr[0]),
      totalFees: dco_decode_opt_box_autoadd_u_64(arr[1]),
      avgFee: dco_decode_opt_box_autoadd_f_64(arr[2]),
      avgFeeRate: dco_decode_opt_box_autoadd_f_64(arr[3]),
      reward: dco_decode_opt_box_autoadd_u_64(arr[4]),
      pool: dco_decode_opt_box_autoadd_mining_pool(arr[5]),
      matchRate: dco_decode_opt_box_autoadd_f_64(arr[6]),
      similarity: dco_decode_opt_box_autoadd_f_64(arr[7]),
    );
  }

  @protected
  BoltzSwap dco_decode_boltz_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return BoltzSwap(
      swapId: dco_decode_String(arr[0]),
      amountSats: dco_decode_u_64(arr[1]),
      invoice: dco_decode_String(arr[2]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BlockExtras dco_decode_box_autoadd_block_extras(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_block_extras(raw);
  }

  @protected
  BoltzSwap dco_decode_box_autoadd_boltz_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_boltz_swap(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Conversions dco_decode_box_autoadd_conversions(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_conversions(raw);
  }

  @protected
  DifficultyAdjustment dco_decode_box_autoadd_difficulty_adjustment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_difficulty_adjustment(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FearGreedData dco_decode_box_autoadd_fear_greed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fear_greed_data(raw);
  }

  @protected
  FearGreedLastUpdated dco_decode_box_autoadd_fear_greed_last_updated(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fear_greed_last_updated(raw);
  }

  @protected
  FearGreedValue dco_decode_box_autoadd_fear_greed_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fear_greed_value(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  MiningPool dco_decode_box_autoadd_mining_pool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_mining_pool(raw);
  }

  @protected
  RecommendedFees dco_decode_box_autoadd_recommended_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_recommended_fees(raw);
  }

  @protected
  TxOutput dco_decode_box_autoadd_tx_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_tx_output(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  Conversions dco_decode_conversions(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Conversions(
      time: dco_decode_u_64(arr[0]),
      usd: dco_decode_f_64(arr[1]),
      eur: dco_decode_opt_box_autoadd_f_64(arr[2]),
    );
  }

  @protected
  CurrencyInfo dco_decode_currency_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CurrencyInfo(
      code: dco_decode_String(arr[0]),
      minBuyAmount: dco_decode_f_64(arr[1]),
      maxBuyAmount: dco_decode_f_64(arr[2]),
    );
  }

  @protected
  DifficultyAdjustment dco_decode_difficulty_adjustment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return DifficultyAdjustment(
      progressPercent: dco_decode_f_64(arr[0]),
      difficultyChange: dco_decode_f_64(arr[1]),
      estimatedRetargetDate: dco_decode_u_64(arr[2]),
      remainingBlocks: dco_decode_u_32(arr[3]),
      remainingTime: dco_decode_u_64(arr[4]),
      previousRetarget: dco_decode_opt_box_autoadd_f_64(arr[5]),
      previousTime: dco_decode_opt_box_autoadd_u_64(arr[6]),
      nextRetargetHeight: dco_decode_u_64(arr[7]),
      timeAvg: dco_decode_u_64(arr[8]),
      adjustedTimeAvg: dco_decode_opt_box_autoadd_u_64(arr[9]),
      timeOffset: dco_decode_i_64(arr[10]),
      expectedBlocks: dco_decode_f_64(arr[11]),
    );
  }

  @protected
  DifficultyPoint dco_decode_difficulty_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DifficultyPoint(
      timestamp: dco_decode_opt_box_autoadd_u_64(arr[0]),
      difficulty: dco_decode_opt_box_autoadd_f_64(arr[1]),
      height: dco_decode_opt_box_autoadd_u_64(arr[2]),
    );
  }

  @protected
  ExchangeRates dco_decode_exchange_rates(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ExchangeRates(
      base: dco_decode_String(arr[0]),
      rates: dco_decode_Map_String_f_64_None(arr[1]),
      timestamp: dco_decode_i_64(arr[2]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FearGreedData dco_decode_fear_greed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return FearGreedData(
      now: dco_decode_opt_box_autoadd_fear_greed_value(arr[0]),
      previousClose: dco_decode_opt_box_autoadd_fear_greed_value(arr[1]),
      oneWeekAgo: dco_decode_opt_box_autoadd_fear_greed_value(arr[2]),
      oneMonthAgo: dco_decode_opt_box_autoadd_fear_greed_value(arr[3]),
      oneYearAgo: dco_decode_opt_box_autoadd_fear_greed_value(arr[4]),
    );
  }

  @protected
  FearGreedIndex dco_decode_fear_greed_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FearGreedIndex(
      lastUpdated: dco_decode_opt_box_autoadd_fear_greed_last_updated(arr[0]),
      fgi: dco_decode_opt_box_autoadd_fear_greed_data(arr[1]),
    );
  }

  @protected
  FearGreedLastUpdated dco_decode_fear_greed_last_updated(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FearGreedLastUpdated(
      epochUnixSeconds: dco_decode_opt_box_autoadd_i_64(arr[0]),
      humanDate: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  FearGreedValue dco_decode_fear_greed_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FearGreedValue(
      value: dco_decode_opt_box_autoadd_i_32(arr[0]),
      valueText: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  FiatCurrency dco_decode_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FiatCurrency.values[raw as int];
  }

  @protected
  HashrateData dco_decode_hashrate_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return HashrateData(
      currentHashrate: dco_decode_opt_box_autoadd_f_64(arr[0]),
      currentDifficulty: dco_decode_opt_box_autoadd_f_64(arr[1]),
      hashrates: dco_decode_list_hashrate_point(arr[2]),
      difficulty: dco_decode_list_difficulty_point(arr[3]),
    );
  }

  @protected
  HashratePoint dco_decode_hashrate_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return HashratePoint(
      timestamp: dco_decode_u_64(arr[0]),
      avgHashrate: dco_decode_f_64(arr[1]),
    );
  }

  @protected
  HistoricalPriceData dco_decode_historical_price_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return HistoricalPriceData(
      timestamp: dco_decode_String(arr[0]),
      price: dco_decode_String(arr[1]),
    );
  }

  @protected
  HistoricalPriceResponse dco_decode_historical_price_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return HistoricalPriceResponse(
      prices: dco_decode_list_historical_price_data(arr[0]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Info dco_decode_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Info(
      serverPk: dco_decode_String(arr[0]),
      network: dco_decode_String(arr[1]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<BitcoinTransaction> dco_decode_list_bitcoin_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_bitcoin_transaction).toList();
  }

  @protected
  List<Block> dco_decode_list_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_block).toList();
  }

  @protected
  List<DifficultyPoint> dco_decode_list_difficulty_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_difficulty_point).toList();
  }

  @protected
  List<FiatCurrency> dco_decode_list_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_fiat_currency).toList();
  }

  @protected
  List<HashratePoint> dco_decode_list_hashrate_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_hashrate_point).toList();
  }

  @protected
  List<HistoricalPriceData> dco_decode_list_historical_price_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_historical_price_data)
        .toList();
  }

  @protected
  List<MempoolBlock> dco_decode_list_mempool_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_mempool_block).toList();
  }

  @protected
  Float64List dco_decode_list_prim_f_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float64List;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ProjectedTransaction> dco_decode_list_projected_transaction(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_projected_transaction)
        .toList();
  }

  @protected
  List<(String, double)> dco_decode_list_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_f_64).toList();
  }

  @protected
  List<Transaction> dco_decode_list_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_transaction).toList();
  }

  @protected
  List<TxInput> dco_decode_list_tx_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_input).toList();
  }

  @protected
  List<TxOutput> dco_decode_list_tx_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_output).toList();
  }

  @protected
  LnPaymentResult dco_decode_ln_payment_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LnPaymentResult(
      swapId: dco_decode_String(arr[0]),
      txid: dco_decode_String(arr[1]),
      amountSats: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  LogEntry dco_decode_log_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return LogEntry(
      msg: dco_decode_String(arr[0]),
      target: dco_decode_String(arr[1]),
      level: dco_decode_String(arr[2]),
      file: dco_decode_String(arr[3]),
      line: dco_decode_String(arr[4]),
      modulePath: dco_decode_String(arr[5]),
      data: dco_decode_String(arr[6]),
    );
  }

  @protected
  MempoolBlock dco_decode_mempool_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return MempoolBlock(
      blockSize: dco_decode_u_64(arr[0]),
      blockVsize: dco_decode_f_64(arr[1]),
      nTx: dco_decode_u_32(arr[2]),
      totalFees: dco_decode_u_64(arr[3]),
      medianFee: dco_decode_f_64(arr[4]),
      feeRange: dco_decode_list_prim_f_64_strict(arr[5]),
    );
  }

  @protected
  MempoolWsMessage dco_decode_mempool_ws_message(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return MempoolWsMessage(
      mempoolBlocks: dco_decode_opt_list_mempool_block(arr[0]),
      blocks: dco_decode_opt_list_block(arr[1]),
      conversions: dco_decode_opt_box_autoadd_conversions(arr[2]),
      fees: dco_decode_opt_box_autoadd_recommended_fees(arr[3]),
      da: dco_decode_opt_box_autoadd_difficulty_adjustment(arr[4]),
    );
  }

  @protected
  MiningPool dco_decode_mining_pool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return MiningPool(
      id: dco_decode_opt_box_autoadd_u_32(arr[0]),
      name: dco_decode_String(arr[1]),
      slug: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  MoonPayCurrencyLimits dco_decode_moon_pay_currency_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MoonPayCurrencyLimits(
      quoteCurrency: dco_decode_currency_info(arr[0]),
      baseCurrency: dco_decode_currency_info(arr[1]),
    );
  }

  @protected
  MoonPayEncryptedData dco_decode_moon_pay_encrypted_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MoonPayEncryptedData(
      ciphertext: dco_decode_String(arr[0]),
      iv: dco_decode_String(arr[1]),
    );
  }

  @protected
  MoonPayQuote dco_decode_moon_pay_quote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return MoonPayQuote(
      baseCurrencyAmount: dco_decode_f_64(arr[0]),
      quoteCurrencyAmount: dco_decode_f_64(arr[1]),
      baseCurrencyCode: dco_decode_String(arr[2]),
      exchangeRate: dco_decode_f_64(arr[3]),
      timestamp: dco_decode_String(arr[4]),
    );
  }

  @protected
  OffchainBalance dco_decode_offchain_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return OffchainBalance(
      pendingSats: dco_decode_u_64(arr[0]),
      confirmedSats: dco_decode_u_64(arr[1]),
      totalSats: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  BlockExtras? dco_decode_opt_box_autoadd_block_extras(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_block_extras(raw);
  }

  @protected
  BoltzSwap? dco_decode_opt_box_autoadd_boltz_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_boltz_swap(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  Conversions? dco_decode_opt_box_autoadd_conversions(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_conversions(raw);
  }

  @protected
  DifficultyAdjustment? dco_decode_opt_box_autoadd_difficulty_adjustment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_difficulty_adjustment(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  FearGreedData? dco_decode_opt_box_autoadd_fear_greed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_fear_greed_data(raw);
  }

  @protected
  FearGreedLastUpdated? dco_decode_opt_box_autoadd_fear_greed_last_updated(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_fear_greed_last_updated(raw);
  }

  @protected
  FearGreedValue? dco_decode_opt_box_autoadd_fear_greed_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_fear_greed_value(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  MiningPool? dco_decode_opt_box_autoadd_mining_pool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_mining_pool(raw);
  }

  @protected
  RecommendedFees? dco_decode_opt_box_autoadd_recommended_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_recommended_fees(raw);
  }

  @protected
  TxOutput? dco_decode_opt_box_autoadd_tx_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_tx_output(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<Block>? dco_decode_opt_list_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_block(raw);
  }

  @protected
  List<MempoolBlock>? dco_decode_opt_list_mempool_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_mempool_block(raw);
  }

  @protected
  PaymentReceived dco_decode_payment_received(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PaymentReceived(
      txid: dco_decode_String(arr[0]),
      amountSats: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  ProjectedBlockTransactions dco_decode_projected_block_transactions(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ProjectedBlockTransactions(
      index: dco_decode_u_32(arr[0]),
      transactions: dco_decode_list_projected_transaction(arr[1]),
    );
  }

  @protected
  ProjectedTransaction dco_decode_projected_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ProjectedTransaction(
      txid: dco_decode_String(arr[0]),
      value: dco_decode_u_64(arr[1]),
      vsize: dco_decode_u_32(arr[2]),
      feeRate: dco_decode_f_64(arr[3]),
      flags: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  RecommendedFees dco_decode_recommended_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RecommendedFees(
      fastestFee: dco_decode_f_64(arr[0]),
      halfHourFee: dco_decode_f_64(arr[1]),
      hourFee: dco_decode_f_64(arr[2]),
      economyFee: dco_decode_f_64(arr[3]),
      minimumFee: dco_decode_f_64(arr[4]),
    );
  }

  @protected
  (String, double) dco_decode_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_f_64(arr[1]),
    );
  }

  @protected
  Transaction dco_decode_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Transaction_Boarding(
          txid: dco_decode_String(raw[1]),
          amountSats: dco_decode_u_64(raw[2]),
          confirmedAt: dco_decode_opt_box_autoadd_i_64(raw[3]),
        );
      case 1:
        return Transaction_Round(
          txid: dco_decode_String(raw[1]),
          amountSats: dco_decode_i_64(raw[2]),
          createdAt: dco_decode_i_64(raw[3]),
        );
      case 2:
        return Transaction_Redeem(
          txid: dco_decode_String(raw[1]),
          amountSats: dco_decode_i_64(raw[2]),
          isSettled: dco_decode_bool(raw[3]),
          createdAt: dco_decode_i_64(raw[4]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TxInput dco_decode_tx_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return TxInput(
      txid: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
      prevout: dco_decode_opt_box_autoadd_tx_output(arr[2]),
      scriptsig: dco_decode_String(arr[3]),
      scriptsigAsm: dco_decode_String(arr[4]),
      witness: dco_decode_opt_list_String(arr[5]),
      isCoinbase: dco_decode_bool(arr[6]),
      sequence: dco_decode_u_32(arr[7]),
    );
  }

  @protected
  TxOutput dco_decode_tx_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return TxOutput(
      scriptpubkey: dco_decode_String(arr[0]),
      scriptpubkeyAsm: dco_decode_String(arr[1]),
      scriptpubkeyType: dco_decode_String(arr[2]),
      scriptpubkeyAddress: dco_decode_opt_String(arr[3]),
      value: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  TxStatus dco_decode_tx_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TxStatus(
      confirmed: dco_decode_bool(arr[0]),
      blockHeight: dco_decode_opt_box_autoadd_u_64(arr[1]),
      blockHash: dco_decode_opt_String(arr[2]),
      blockTime: dco_decode_opt_box_autoadd_u_64(arr[3]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Map<String, double> sse_decode_Map_String_f_64_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_f_64(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<MempoolWsMessage> sse_decode_StreamSink_mempool_ws_message_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<ProjectedBlockTransactions>
      sse_decode_StreamSink_projected_block_transactions_Sse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Addresses sse_decode_addresses(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_boarding = sse_decode_String(deserializer);
    var var_offchain = sse_decode_String(deserializer);
    var var_bip21 = sse_decode_String(deserializer);
    var var_lightning = sse_decode_opt_box_autoadd_boltz_swap(deserializer);
    return Addresses(
        boarding: var_boarding,
        offchain: var_offchain,
        bip21: var_bip21,
        lightning: var_lightning);
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_offchain = sse_decode_offchain_balance(deserializer);
    return Balance(offchain: var_offchain);
  }

  @protected
  BitcoinTransaction sse_decode_bitcoin_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_version = sse_decode_u_32(deserializer);
    var var_locktime = sse_decode_u_32(deserializer);
    var var_size = sse_decode_u_32(deserializer);
    var var_weight = sse_decode_u_32(deserializer);
    var var_fee = sse_decode_u_64(deserializer);
    var var_sigops = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_status = sse_decode_tx_status(deserializer);
    var var_vin = sse_decode_list_tx_input(deserializer);
    var var_vout = sse_decode_list_tx_output(deserializer);
    return BitcoinTransaction(
        txid: var_txid,
        version: var_version,
        locktime: var_locktime,
        size: var_size,
        weight: var_weight,
        fee: var_fee,
        sigops: var_sigops,
        status: var_status,
        vin: var_vin,
        vout: var_vout);
  }

  @protected
  Block sse_decode_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_height = sse_decode_u_64(deserializer);
    var var_version = sse_decode_u_32(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_bits = sse_decode_u_32(deserializer);
    var var_nonce = sse_decode_u_32(deserializer);
    var var_difficulty = sse_decode_f_64(deserializer);
    var var_merkleRoot = sse_decode_String(deserializer);
    var var_txCount = sse_decode_u_32(deserializer);
    var var_size = sse_decode_u_64(deserializer);
    var var_weight = sse_decode_u_64(deserializer);
    var var_previousblockhash = sse_decode_opt_String(deserializer);
    var var_mediantime = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_stale = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_extras = sse_decode_opt_box_autoadd_block_extras(deserializer);
    return Block(
        id: var_id,
        height: var_height,
        version: var_version,
        timestamp: var_timestamp,
        bits: var_bits,
        nonce: var_nonce,
        difficulty: var_difficulty,
        merkleRoot: var_merkleRoot,
        txCount: var_txCount,
        size: var_size,
        weight: var_weight,
        previousblockhash: var_previousblockhash,
        mediantime: var_mediantime,
        stale: var_stale,
        extras: var_extras);
  }

  @protected
  BlockExtras sse_decode_block_extras(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_medianFee = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_totalFees = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_avgFee = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_avgFeeRate = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_reward = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_pool = sse_decode_opt_box_autoadd_mining_pool(deserializer);
    var var_matchRate = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_similarity = sse_decode_opt_box_autoadd_f_64(deserializer);
    return BlockExtras(
        medianFee: var_medianFee,
        totalFees: var_totalFees,
        avgFee: var_avgFee,
        avgFeeRate: var_avgFeeRate,
        reward: var_reward,
        pool: var_pool,
        matchRate: var_matchRate,
        similarity: var_similarity);
  }

  @protected
  BoltzSwap sse_decode_boltz_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapId = sse_decode_String(deserializer);
    var var_amountSats = sse_decode_u_64(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    return BoltzSwap(
        swapId: var_swapId, amountSats: var_amountSats, invoice: var_invoice);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  BlockExtras sse_decode_box_autoadd_block_extras(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_block_extras(deserializer));
  }

  @protected
  BoltzSwap sse_decode_box_autoadd_boltz_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_boltz_swap(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  Conversions sse_decode_box_autoadd_conversions(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_conversions(deserializer));
  }

  @protected
  DifficultyAdjustment sse_decode_box_autoadd_difficulty_adjustment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_difficulty_adjustment(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  FearGreedData sse_decode_box_autoadd_fear_greed_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fear_greed_data(deserializer));
  }

  @protected
  FearGreedLastUpdated sse_decode_box_autoadd_fear_greed_last_updated(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fear_greed_last_updated(deserializer));
  }

  @protected
  FearGreedValue sse_decode_box_autoadd_fear_greed_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fear_greed_value(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  MiningPool sse_decode_box_autoadd_mining_pool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_mining_pool(deserializer));
  }

  @protected
  RecommendedFees sse_decode_box_autoadd_recommended_fees(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_recommended_fees(deserializer));
  }

  @protected
  TxOutput sse_decode_box_autoadd_tx_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_tx_output(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  Conversions sse_decode_conversions(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_time = sse_decode_u_64(deserializer);
    var var_usd = sse_decode_f_64(deserializer);
    var var_eur = sse_decode_opt_box_autoadd_f_64(deserializer);
    return Conversions(time: var_time, usd: var_usd, eur: var_eur);
  }

  @protected
  CurrencyInfo sse_decode_currency_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_code = sse_decode_String(deserializer);
    var var_minBuyAmount = sse_decode_f_64(deserializer);
    var var_maxBuyAmount = sse_decode_f_64(deserializer);
    return CurrencyInfo(
        code: var_code,
        minBuyAmount: var_minBuyAmount,
        maxBuyAmount: var_maxBuyAmount);
  }

  @protected
  DifficultyAdjustment sse_decode_difficulty_adjustment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_progressPercent = sse_decode_f_64(deserializer);
    var var_difficultyChange = sse_decode_f_64(deserializer);
    var var_estimatedRetargetDate = sse_decode_u_64(deserializer);
    var var_remainingBlocks = sse_decode_u_32(deserializer);
    var var_remainingTime = sse_decode_u_64(deserializer);
    var var_previousRetarget = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_previousTime = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_nextRetargetHeight = sse_decode_u_64(deserializer);
    var var_timeAvg = sse_decode_u_64(deserializer);
    var var_adjustedTimeAvg = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_timeOffset = sse_decode_i_64(deserializer);
    var var_expectedBlocks = sse_decode_f_64(deserializer);
    return DifficultyAdjustment(
        progressPercent: var_progressPercent,
        difficultyChange: var_difficultyChange,
        estimatedRetargetDate: var_estimatedRetargetDate,
        remainingBlocks: var_remainingBlocks,
        remainingTime: var_remainingTime,
        previousRetarget: var_previousRetarget,
        previousTime: var_previousTime,
        nextRetargetHeight: var_nextRetargetHeight,
        timeAvg: var_timeAvg,
        adjustedTimeAvg: var_adjustedTimeAvg,
        timeOffset: var_timeOffset,
        expectedBlocks: var_expectedBlocks);
  }

  @protected
  DifficultyPoint sse_decode_difficulty_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_timestamp = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_difficulty = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_height = sse_decode_opt_box_autoadd_u_64(deserializer);
    return DifficultyPoint(
        timestamp: var_timestamp,
        difficulty: var_difficulty,
        height: var_height);
  }

  @protected
  ExchangeRates sse_decode_exchange_rates(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_base = sse_decode_String(deserializer);
    var var_rates = sse_decode_Map_String_f_64_None(deserializer);
    var var_timestamp = sse_decode_i_64(deserializer);
    return ExchangeRates(
        base: var_base, rates: var_rates, timestamp: var_timestamp);
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FearGreedData sse_decode_fear_greed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_now = sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
    var var_previousClose =
        sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
    var var_oneWeekAgo =
        sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
    var var_oneMonthAgo =
        sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
    var var_oneYearAgo =
        sse_decode_opt_box_autoadd_fear_greed_value(deserializer);
    return FearGreedData(
        now: var_now,
        previousClose: var_previousClose,
        oneWeekAgo: var_oneWeekAgo,
        oneMonthAgo: var_oneMonthAgo,
        oneYearAgo: var_oneYearAgo);
  }

  @protected
  FearGreedIndex sse_decode_fear_greed_index(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lastUpdated =
        sse_decode_opt_box_autoadd_fear_greed_last_updated(deserializer);
    var var_fgi = sse_decode_opt_box_autoadd_fear_greed_data(deserializer);
    return FearGreedIndex(lastUpdated: var_lastUpdated, fgi: var_fgi);
  }

  @protected
  FearGreedLastUpdated sse_decode_fear_greed_last_updated(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_epochUnixSeconds = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_humanDate = sse_decode_opt_String(deserializer);
    return FearGreedLastUpdated(
        epochUnixSeconds: var_epochUnixSeconds, humanDate: var_humanDate);
  }

  @protected
  FearGreedValue sse_decode_fear_greed_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_valueText = sse_decode_opt_String(deserializer);
    return FearGreedValue(value: var_value, valueText: var_valueText);
  }

  @protected
  FiatCurrency sse_decode_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FiatCurrency.values[inner];
  }

  @protected
  HashrateData sse_decode_hashrate_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_currentHashrate = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_currentDifficulty = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_hashrates = sse_decode_list_hashrate_point(deserializer);
    var var_difficulty = sse_decode_list_difficulty_point(deserializer);
    return HashrateData(
        currentHashrate: var_currentHashrate,
        currentDifficulty: var_currentDifficulty,
        hashrates: var_hashrates,
        difficulty: var_difficulty);
  }

  @protected
  HashratePoint sse_decode_hashrate_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_avgHashrate = sse_decode_f_64(deserializer);
    return HashratePoint(
        timestamp: var_timestamp, avgHashrate: var_avgHashrate);
  }

  @protected
  HistoricalPriceData sse_decode_historical_price_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_timestamp = sse_decode_String(deserializer);
    var var_price = sse_decode_String(deserializer);
    return HistoricalPriceData(timestamp: var_timestamp, price: var_price);
  }

  @protected
  HistoricalPriceResponse sse_decode_historical_price_response(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prices = sse_decode_list_historical_price_data(deserializer);
    return HistoricalPriceResponse(prices: var_prices);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Info sse_decode_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serverPk = sse_decode_String(deserializer);
    var var_network = sse_decode_String(deserializer);
    return Info(serverPk: var_serverPk, network: var_network);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<BitcoinTransaction> sse_decode_list_bitcoin_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BitcoinTransaction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bitcoin_transaction(deserializer));
    }
    return ans_;
  }

  @protected
  List<Block> sse_decode_list_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Block>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_block(deserializer));
    }
    return ans_;
  }

  @protected
  List<DifficultyPoint> sse_decode_list_difficulty_point(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DifficultyPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_difficulty_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<FiatCurrency> sse_decode_list_fiat_currency(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FiatCurrency>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_fiat_currency(deserializer));
    }
    return ans_;
  }

  @protected
  List<HashratePoint> sse_decode_list_hashrate_point(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <HashratePoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_hashrate_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<HistoricalPriceData> sse_decode_list_historical_price_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <HistoricalPriceData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_historical_price_data(deserializer));
    }
    return ans_;
  }

  @protected
  List<MempoolBlock> sse_decode_list_mempool_block(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MempoolBlock>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_mempool_block(deserializer));
    }
    return ans_;
  }

  @protected
  Float64List sse_decode_list_prim_f_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ProjectedTransaction> sse_decode_list_projected_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProjectedTransaction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_projected_transaction(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, double)> sse_decode_list_record_string_f_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, double)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_f_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<Transaction> sse_decode_list_transaction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Transaction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_transaction(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxInput> sse_decode_list_tx_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxInput>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_input(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxOutput> sse_decode_list_tx_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxOutput>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_output(deserializer));
    }
    return ans_;
  }

  @protected
  LnPaymentResult sse_decode_ln_payment_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapId = sse_decode_String(deserializer);
    var var_txid = sse_decode_String(deserializer);
    var var_amountSats = sse_decode_u_64(deserializer);
    return LnPaymentResult(
        swapId: var_swapId, txid: var_txid, amountSats: var_amountSats);
  }

  @protected
  LogEntry sse_decode_log_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_String(deserializer);
    var var_target = sse_decode_String(deserializer);
    var var_level = sse_decode_String(deserializer);
    var var_file = sse_decode_String(deserializer);
    var var_line = sse_decode_String(deserializer);
    var var_modulePath = sse_decode_String(deserializer);
    var var_data = sse_decode_String(deserializer);
    return LogEntry(
        msg: var_msg,
        target: var_target,
        level: var_level,
        file: var_file,
        line: var_line,
        modulePath: var_modulePath,
        data: var_data);
  }

  @protected
  MempoolBlock sse_decode_mempool_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_blockSize = sse_decode_u_64(deserializer);
    var var_blockVsize = sse_decode_f_64(deserializer);
    var var_nTx = sse_decode_u_32(deserializer);
    var var_totalFees = sse_decode_u_64(deserializer);
    var var_medianFee = sse_decode_f_64(deserializer);
    var var_feeRange = sse_decode_list_prim_f_64_strict(deserializer);
    return MempoolBlock(
        blockSize: var_blockSize,
        blockVsize: var_blockVsize,
        nTx: var_nTx,
        totalFees: var_totalFees,
        medianFee: var_medianFee,
        feeRange: var_feeRange);
  }

  @protected
  MempoolWsMessage sse_decode_mempool_ws_message(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_mempoolBlocks = sse_decode_opt_list_mempool_block(deserializer);
    var var_blocks = sse_decode_opt_list_block(deserializer);
    var var_conversions = sse_decode_opt_box_autoadd_conversions(deserializer);
    var var_fees = sse_decode_opt_box_autoadd_recommended_fees(deserializer);
    var var_da = sse_decode_opt_box_autoadd_difficulty_adjustment(deserializer);
    return MempoolWsMessage(
        mempoolBlocks: var_mempoolBlocks,
        blocks: var_blocks,
        conversions: var_conversions,
        fees: var_fees,
        da: var_da);
  }

  @protected
  MiningPool sse_decode_mining_pool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_slug = sse_decode_opt_String(deserializer);
    return MiningPool(id: var_id, name: var_name, slug: var_slug);
  }

  @protected
  MoonPayCurrencyLimits sse_decode_moon_pay_currency_limits(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_quoteCurrency = sse_decode_currency_info(deserializer);
    var var_baseCurrency = sse_decode_currency_info(deserializer);
    return MoonPayCurrencyLimits(
        quoteCurrency: var_quoteCurrency, baseCurrency: var_baseCurrency);
  }

  @protected
  MoonPayEncryptedData sse_decode_moon_pay_encrypted_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ciphertext = sse_decode_String(deserializer);
    var var_iv = sse_decode_String(deserializer);
    return MoonPayEncryptedData(ciphertext: var_ciphertext, iv: var_iv);
  }

  @protected
  MoonPayQuote sse_decode_moon_pay_quote(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseCurrencyAmount = sse_decode_f_64(deserializer);
    var var_quoteCurrencyAmount = sse_decode_f_64(deserializer);
    var var_baseCurrencyCode = sse_decode_String(deserializer);
    var var_exchangeRate = sse_decode_f_64(deserializer);
    var var_timestamp = sse_decode_String(deserializer);
    return MoonPayQuote(
        baseCurrencyAmount: var_baseCurrencyAmount,
        quoteCurrencyAmount: var_quoteCurrencyAmount,
        baseCurrencyCode: var_baseCurrencyCode,
        exchangeRate: var_exchangeRate,
        timestamp: var_timestamp);
  }

  @protected
  OffchainBalance sse_decode_offchain_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pendingSats = sse_decode_u_64(deserializer);
    var var_confirmedSats = sse_decode_u_64(deserializer);
    var var_totalSats = sse_decode_u_64(deserializer);
    return OffchainBalance(
        pendingSats: var_pendingSats,
        confirmedSats: var_confirmedSats,
        totalSats: var_totalSats);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BlockExtras? sse_decode_opt_box_autoadd_block_extras(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_block_extras(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BoltzSwap? sse_decode_opt_box_autoadd_boltz_swap(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_boltz_swap(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Conversions? sse_decode_opt_box_autoadd_conversions(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_conversions(deserializer));
    } else {
      return null;
    }
  }

  @protected
  DifficultyAdjustment? sse_decode_opt_box_autoadd_difficulty_adjustment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_difficulty_adjustment(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FearGreedData? sse_decode_opt_box_autoadd_fear_greed_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_fear_greed_data(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FearGreedLastUpdated? sse_decode_opt_box_autoadd_fear_greed_last_updated(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_fear_greed_last_updated(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FearGreedValue? sse_decode_opt_box_autoadd_fear_greed_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_fear_greed_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MiningPool? sse_decode_opt_box_autoadd_mining_pool(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_mining_pool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RecommendedFees? sse_decode_opt_box_autoadd_recommended_fees(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_recommended_fees(deserializer));
    } else {
      return null;
    }
  }

  @protected
  TxOutput? sse_decode_opt_box_autoadd_tx_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_tx_output(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<Block>? sse_decode_opt_list_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_block(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<MempoolBlock>? sse_decode_opt_list_mempool_block(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_mempool_block(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentReceived sse_decode_payment_received(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_amountSats = sse_decode_u_64(deserializer);
    return PaymentReceived(txid: var_txid, amountSats: var_amountSats);
  }

  @protected
  ProjectedBlockTransactions sse_decode_projected_block_transactions(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_transactions = sse_decode_list_projected_transaction(deserializer);
    return ProjectedBlockTransactions(
        index: var_index, transactions: var_transactions);
  }

  @protected
  ProjectedTransaction sse_decode_projected_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_value = sse_decode_u_64(deserializer);
    var var_vsize = sse_decode_u_32(deserializer);
    var var_feeRate = sse_decode_f_64(deserializer);
    var var_flags = sse_decode_u_32(deserializer);
    return ProjectedTransaction(
        txid: var_txid,
        value: var_value,
        vsize: var_vsize,
        feeRate: var_feeRate,
        flags: var_flags);
  }

  @protected
  RecommendedFees sse_decode_recommended_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fastestFee = sse_decode_f_64(deserializer);
    var var_halfHourFee = sse_decode_f_64(deserializer);
    var var_hourFee = sse_decode_f_64(deserializer);
    var var_economyFee = sse_decode_f_64(deserializer);
    var var_minimumFee = sse_decode_f_64(deserializer);
    return RecommendedFees(
        fastestFee: var_fastestFee,
        halfHourFee: var_halfHourFee,
        hourFee: var_hourFee,
        economyFee: var_economyFee,
        minimumFee: var_minimumFee);
  }

  @protected
  (String, double) sse_decode_record_string_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_f_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  Transaction sse_decode_transaction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_txid = sse_decode_String(deserializer);
        var var_amountSats = sse_decode_u_64(deserializer);
        var var_confirmedAt = sse_decode_opt_box_autoadd_i_64(deserializer);
        return Transaction_Boarding(
            txid: var_txid,
            amountSats: var_amountSats,
            confirmedAt: var_confirmedAt);
      case 1:
        var var_txid = sse_decode_String(deserializer);
        var var_amountSats = sse_decode_i_64(deserializer);
        var var_createdAt = sse_decode_i_64(deserializer);
        return Transaction_Round(
            txid: var_txid,
            amountSats: var_amountSats,
            createdAt: var_createdAt);
      case 2:
        var var_txid = sse_decode_String(deserializer);
        var var_amountSats = sse_decode_i_64(deserializer);
        var var_isSettled = sse_decode_bool(deserializer);
        var var_createdAt = sse_decode_i_64(deserializer);
        return Transaction_Redeem(
            txid: var_txid,
            amountSats: var_amountSats,
            isSettled: var_isSettled,
            createdAt: var_createdAt);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TxInput sse_decode_tx_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    var var_prevout = sse_decode_opt_box_autoadd_tx_output(deserializer);
    var var_scriptsig = sse_decode_String(deserializer);
    var var_scriptsigAsm = sse_decode_String(deserializer);
    var var_witness = sse_decode_opt_list_String(deserializer);
    var var_isCoinbase = sse_decode_bool(deserializer);
    var var_sequence = sse_decode_u_32(deserializer);
    return TxInput(
        txid: var_txid,
        vout: var_vout,
        prevout: var_prevout,
        scriptsig: var_scriptsig,
        scriptsigAsm: var_scriptsigAsm,
        witness: var_witness,
        isCoinbase: var_isCoinbase,
        sequence: var_sequence);
  }

  @protected
  TxOutput sse_decode_tx_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_scriptpubkey = sse_decode_String(deserializer);
    var var_scriptpubkeyAsm = sse_decode_String(deserializer);
    var var_scriptpubkeyType = sse_decode_String(deserializer);
    var var_scriptpubkeyAddress = sse_decode_opt_String(deserializer);
    var var_value = sse_decode_u_64(deserializer);
    return TxOutput(
        scriptpubkey: var_scriptpubkey,
        scriptpubkeyAsm: var_scriptpubkeyAsm,
        scriptpubkeyType: var_scriptpubkeyType,
        scriptpubkeyAddress: var_scriptpubkeyAddress,
        value: var_value);
  }

  @protected
  TxStatus sse_decode_tx_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_confirmed = sse_decode_bool(deserializer);
    var var_blockHeight = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_blockHash = sse_decode_opt_String(deserializer);
    var var_blockTime = sse_decode_opt_box_autoadd_u_64(deserializer);
    return TxStatus(
        confirmed: var_confirmed,
        blockHeight: var_blockHeight,
        blockHash: var_blockHash,
        blockTime: var_blockTime);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Map_String_f_64_None(
      Map<String, double> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_f_64(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_StreamSink_log_entry_Sse(
      RustStreamSink<LogEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_log_entry,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_mempool_ws_message_Sse(
      RustStreamSink<MempoolWsMessage> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_mempool_ws_message,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_projected_block_transactions_Sse(
      RustStreamSink<ProjectedBlockTransactions> self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_projected_block_transactions,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_addresses(Addresses self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.boarding, serializer);
    sse_encode_String(self.offchain, serializer);
    sse_encode_String(self.bip21, serializer);
    sse_encode_opt_box_autoadd_boltz_swap(self.lightning, serializer);
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_offchain_balance(self.offchain, serializer);
  }

  @protected
  void sse_encode_bitcoin_transaction(
      BitcoinTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.version, serializer);
    sse_encode_u_32(self.locktime, serializer);
    sse_encode_u_32(self.size, serializer);
    sse_encode_u_32(self.weight, serializer);
    sse_encode_u_64(self.fee, serializer);
    sse_encode_opt_box_autoadd_u_32(self.sigops, serializer);
    sse_encode_tx_status(self.status, serializer);
    sse_encode_list_tx_input(self.vin, serializer);
    sse_encode_list_tx_output(self.vout, serializer);
  }

  @protected
  void sse_encode_block(Block self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_64(self.height, serializer);
    sse_encode_u_32(self.version, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_u_32(self.bits, serializer);
    sse_encode_u_32(self.nonce, serializer);
    sse_encode_f_64(self.difficulty, serializer);
    sse_encode_String(self.merkleRoot, serializer);
    sse_encode_u_32(self.txCount, serializer);
    sse_encode_u_64(self.size, serializer);
    sse_encode_u_64(self.weight, serializer);
    sse_encode_opt_String(self.previousblockhash, serializer);
    sse_encode_opt_box_autoadd_u_64(self.mediantime, serializer);
    sse_encode_opt_box_autoadd_bool(self.stale, serializer);
    sse_encode_opt_box_autoadd_block_extras(self.extras, serializer);
  }

  @protected
  void sse_encode_block_extras(BlockExtras self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_f_64(self.medianFee, serializer);
    sse_encode_opt_box_autoadd_u_64(self.totalFees, serializer);
    sse_encode_opt_box_autoadd_f_64(self.avgFee, serializer);
    sse_encode_opt_box_autoadd_f_64(self.avgFeeRate, serializer);
    sse_encode_opt_box_autoadd_u_64(self.reward, serializer);
    sse_encode_opt_box_autoadd_mining_pool(self.pool, serializer);
    sse_encode_opt_box_autoadd_f_64(self.matchRate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.similarity, serializer);
  }

  @protected
  void sse_encode_boltz_swap(BoltzSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapId, serializer);
    sse_encode_u_64(self.amountSats, serializer);
    sse_encode_String(self.invoice, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_block_extras(
      BlockExtras self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_block_extras(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_boltz_swap(
      BoltzSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_boltz_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_conversions(
      Conversions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_conversions(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_difficulty_adjustment(
      DifficultyAdjustment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_difficulty_adjustment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fear_greed_data(
      FearGreedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fear_greed_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fear_greed_last_updated(
      FearGreedLastUpdated self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fear_greed_last_updated(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fear_greed_value(
      FearGreedValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fear_greed_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
      PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_mining_pool(
      MiningPool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_mining_pool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_recommended_fees(
      RecommendedFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_recommended_fees(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_tx_output(
      TxOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_tx_output(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_conversions(Conversions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.time, serializer);
    sse_encode_f_64(self.usd, serializer);
    sse_encode_opt_box_autoadd_f_64(self.eur, serializer);
  }

  @protected
  void sse_encode_currency_info(CurrencyInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.code, serializer);
    sse_encode_f_64(self.minBuyAmount, serializer);
    sse_encode_f_64(self.maxBuyAmount, serializer);
  }

  @protected
  void sse_encode_difficulty_adjustment(
      DifficultyAdjustment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.progressPercent, serializer);
    sse_encode_f_64(self.difficultyChange, serializer);
    sse_encode_u_64(self.estimatedRetargetDate, serializer);
    sse_encode_u_32(self.remainingBlocks, serializer);
    sse_encode_u_64(self.remainingTime, serializer);
    sse_encode_opt_box_autoadd_f_64(self.previousRetarget, serializer);
    sse_encode_opt_box_autoadd_u_64(self.previousTime, serializer);
    sse_encode_u_64(self.nextRetargetHeight, serializer);
    sse_encode_u_64(self.timeAvg, serializer);
    sse_encode_opt_box_autoadd_u_64(self.adjustedTimeAvg, serializer);
    sse_encode_i_64(self.timeOffset, serializer);
    sse_encode_f_64(self.expectedBlocks, serializer);
  }

  @protected
  void sse_encode_difficulty_point(
      DifficultyPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.timestamp, serializer);
    sse_encode_opt_box_autoadd_f_64(self.difficulty, serializer);
    sse_encode_opt_box_autoadd_u_64(self.height, serializer);
  }

  @protected
  void sse_encode_exchange_rates(ExchangeRates self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.base, serializer);
    sse_encode_Map_String_f_64_None(self.rates, serializer);
    sse_encode_i_64(self.timestamp, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_fear_greed_data(
      FearGreedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_fear_greed_value(self.now, serializer);
    sse_encode_opt_box_autoadd_fear_greed_value(self.previousClose, serializer);
    sse_encode_opt_box_autoadd_fear_greed_value(self.oneWeekAgo, serializer);
    sse_encode_opt_box_autoadd_fear_greed_value(self.oneMonthAgo, serializer);
    sse_encode_opt_box_autoadd_fear_greed_value(self.oneYearAgo, serializer);
  }

  @protected
  void sse_encode_fear_greed_index(
      FearGreedIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_fear_greed_last_updated(
        self.lastUpdated, serializer);
    sse_encode_opt_box_autoadd_fear_greed_data(self.fgi, serializer);
  }

  @protected
  void sse_encode_fear_greed_last_updated(
      FearGreedLastUpdated self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_i_64(self.epochUnixSeconds, serializer);
    sse_encode_opt_String(self.humanDate, serializer);
  }

  @protected
  void sse_encode_fear_greed_value(
      FearGreedValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_i_32(self.value, serializer);
    sse_encode_opt_String(self.valueText, serializer);
  }

  @protected
  void sse_encode_fiat_currency(FiatCurrency self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_hashrate_data(HashrateData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_f_64(self.currentHashrate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.currentDifficulty, serializer);
    sse_encode_list_hashrate_point(self.hashrates, serializer);
    sse_encode_list_difficulty_point(self.difficulty, serializer);
  }

  @protected
  void sse_encode_hashrate_point(HashratePoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_f_64(self.avgHashrate, serializer);
  }

  @protected
  void sse_encode_historical_price_data(
      HistoricalPriceData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.timestamp, serializer);
    sse_encode_String(self.price, serializer);
  }

  @protected
  void sse_encode_historical_price_response(
      HistoricalPriceResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_historical_price_data(self.prices, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_info(Info self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serverPk, serializer);
    sse_encode_String(self.network, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_bitcoin_transaction(
      List<BitcoinTransaction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bitcoin_transaction(item, serializer);
    }
  }

  @protected
  void sse_encode_list_block(List<Block> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_block(item, serializer);
    }
  }

  @protected
  void sse_encode_list_difficulty_point(
      List<DifficultyPoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_difficulty_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_fiat_currency(
      List<FiatCurrency> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_fiat_currency(item, serializer);
    }
  }

  @protected
  void sse_encode_list_hashrate_point(
      List<HashratePoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_hashrate_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_historical_price_data(
      List<HistoricalPriceData> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_historical_price_data(item, serializer);
    }
  }

  @protected
  void sse_encode_list_mempool_block(
      List<MempoolBlock> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_mempool_block(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_64_strict(
      Float64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_projected_transaction(
      List<ProjectedTransaction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_projected_transaction(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_f_64(
      List<(String, double)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_f_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_transaction(
      List<Transaction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_transaction(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_input(List<TxInput> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_input(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_output(
      List<TxOutput> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_output(item, serializer);
    }
  }

  @protected
  void sse_encode_ln_payment_result(
      LnPaymentResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapId, serializer);
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.amountSats, serializer);
  }

  @protected
  void sse_encode_log_entry(LogEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.msg, serializer);
    sse_encode_String(self.target, serializer);
    sse_encode_String(self.level, serializer);
    sse_encode_String(self.file, serializer);
    sse_encode_String(self.line, serializer);
    sse_encode_String(self.modulePath, serializer);
    sse_encode_String(self.data, serializer);
  }

  @protected
  void sse_encode_mempool_block(MempoolBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.blockSize, serializer);
    sse_encode_f_64(self.blockVsize, serializer);
    sse_encode_u_32(self.nTx, serializer);
    sse_encode_u_64(self.totalFees, serializer);
    sse_encode_f_64(self.medianFee, serializer);
    sse_encode_list_prim_f_64_strict(self.feeRange, serializer);
  }

  @protected
  void sse_encode_mempool_ws_message(
      MempoolWsMessage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_mempool_block(self.mempoolBlocks, serializer);
    sse_encode_opt_list_block(self.blocks, serializer);
    sse_encode_opt_box_autoadd_conversions(self.conversions, serializer);
    sse_encode_opt_box_autoadd_recommended_fees(self.fees, serializer);
    sse_encode_opt_box_autoadd_difficulty_adjustment(self.da, serializer);
  }

  @protected
  void sse_encode_mining_pool(MiningPool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_32(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.slug, serializer);
  }

  @protected
  void sse_encode_moon_pay_currency_limits(
      MoonPayCurrencyLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_currency_info(self.quoteCurrency, serializer);
    sse_encode_currency_info(self.baseCurrency, serializer);
  }

  @protected
  void sse_encode_moon_pay_encrypted_data(
      MoonPayEncryptedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.ciphertext, serializer);
    sse_encode_String(self.iv, serializer);
  }

  @protected
  void sse_encode_moon_pay_quote(MoonPayQuote self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.baseCurrencyAmount, serializer);
    sse_encode_f_64(self.quoteCurrencyAmount, serializer);
    sse_encode_String(self.baseCurrencyCode, serializer);
    sse_encode_f_64(self.exchangeRate, serializer);
    sse_encode_String(self.timestamp, serializer);
  }

  @protected
  void sse_encode_offchain_balance(
      OffchainBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.pendingSats, serializer);
    sse_encode_u_64(self.confirmedSats, serializer);
    sse_encode_u_64(self.totalSats, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_block_extras(
      BlockExtras? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_block_extras(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_boltz_swap(
      BoltzSwap? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_boltz_swap(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_conversions(
      Conversions? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_conversions(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_difficulty_adjustment(
      DifficultyAdjustment? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_difficulty_adjustment(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_fear_greed_data(
      FearGreedData? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_fear_greed_data(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_fear_greed_last_updated(
      FearGreedLastUpdated? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_fear_greed_last_updated(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_fear_greed_value(
      FearGreedValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_fear_greed_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
      PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_mining_pool(
      MiningPool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_mining_pool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_recommended_fees(
      RecommendedFees? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_recommended_fees(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_tx_output(
      TxOutput? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_tx_output(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
      List<String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_block(List<Block>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_block(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_mempool_block(
      List<MempoolBlock>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_mempool_block(self, serializer);
    }
  }

  @protected
  void sse_encode_payment_received(
      PaymentReceived self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.amountSats, serializer);
  }

  @protected
  void sse_encode_projected_block_transactions(
      ProjectedBlockTransactions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_list_projected_transaction(self.transactions, serializer);
  }

  @protected
  void sse_encode_projected_transaction(
      ProjectedTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.value, serializer);
    sse_encode_u_32(self.vsize, serializer);
    sse_encode_f_64(self.feeRate, serializer);
    sse_encode_u_32(self.flags, serializer);
  }

  @protected
  void sse_encode_recommended_fees(
      RecommendedFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.fastestFee, serializer);
    sse_encode_f_64(self.halfHourFee, serializer);
    sse_encode_f_64(self.hourFee, serializer);
    sse_encode_f_64(self.economyFee, serializer);
    sse_encode_f_64(self.minimumFee, serializer);
  }

  @protected
  void sse_encode_record_string_f_64(
      (String, double) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_f_64(self.$2, serializer);
  }

  @protected
  void sse_encode_transaction(Transaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Transaction_Boarding(
          txid: final txid,
          amountSats: final amountSats,
          confirmedAt: final confirmedAt
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(txid, serializer);
        sse_encode_u_64(amountSats, serializer);
        sse_encode_opt_box_autoadd_i_64(confirmedAt, serializer);
      case Transaction_Round(
          txid: final txid,
          amountSats: final amountSats,
          createdAt: final createdAt
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(txid, serializer);
        sse_encode_i_64(amountSats, serializer);
        sse_encode_i_64(createdAt, serializer);
      case Transaction_Redeem(
          txid: final txid,
          amountSats: final amountSats,
          isSettled: final isSettled,
          createdAt: final createdAt
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_String(txid, serializer);
        sse_encode_i_64(amountSats, serializer);
        sse_encode_bool(isSettled, serializer);
        sse_encode_i_64(createdAt, serializer);
    }
  }

  @protected
  void sse_encode_tx_input(TxInput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
    sse_encode_opt_box_autoadd_tx_output(self.prevout, serializer);
    sse_encode_String(self.scriptsig, serializer);
    sse_encode_String(self.scriptsigAsm, serializer);
    sse_encode_opt_list_String(self.witness, serializer);
    sse_encode_bool(self.isCoinbase, serializer);
    sse_encode_u_32(self.sequence, serializer);
  }

  @protected
  void sse_encode_tx_output(TxOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.scriptpubkey, serializer);
    sse_encode_String(self.scriptpubkeyAsm, serializer);
    sse_encode_String(self.scriptpubkeyType, serializer);
    sse_encode_opt_String(self.scriptpubkeyAddress, serializer);
    sse_encode_u_64(self.value, serializer);
  }

  @protected
  void sse_encode_tx_status(TxStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.confirmed, serializer);
    sse_encode_opt_box_autoadd_u_64(self.blockHeight, serializer);
    sse_encode_opt_String(self.blockHash, serializer);
    sse_encode_opt_box_autoadd_u_64(self.blockTime, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }
}
