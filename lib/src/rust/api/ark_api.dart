// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'ark_api.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

Future<bool> walletExists({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiWalletExists(dataDir: dataDir);

/// Setup a new wallet with a freshly generated 12-word mnemonic.
/// Returns the mnemonic words that the user MUST back up securely.
Future<String> setupNewWallet(
        {required String dataDir,
        required String network,
        required String esplora,
        required String server,
        required String boltzUrl}) =>
    RustLib.instance.api.crateApiArkApiSetupNewWallet(
        dataDir: dataDir,
        network: network,
        esplora: esplora,
        server: server,
        boltzUrl: boltzUrl);

Future<String> loadExistingWallet(
        {required String dataDir,
        required String network,
        required String esplora,
        required String server,
        required String boltzUrl}) =>
    RustLib.instance.api.crateApiArkApiLoadExistingWallet(
        dataDir: dataDir,
        network: network,
        esplora: esplora,
        server: server,
        boltzUrl: boltzUrl);

/// Restore a wallet from a mnemonic phrase (12 or 24 words)
Future<String> restoreWallet(
        {required String mnemonicWords,
        required String dataDir,
        required String network,
        required String esplora,
        required String server,
        required String boltzUrl}) =>
    RustLib.instance.api.crateApiArkApiRestoreWallet(
        mnemonicWords: mnemonicWords,
        dataDir: dataDir,
        network: network,
        esplora: esplora,
        server: server,
        boltzUrl: boltzUrl);

Future<Balance> balance() => RustLib.instance.api.crateApiArkApiBalance();

Future<Addresses> address({BigInt? amount}) =>
    RustLib.instance.api.crateApiArkApiAddress(amount: amount);

Future<List<Transaction>> txHistory() =>
    RustLib.instance.api.crateApiArkApiTxHistory();

Future<String> send({
  required String address,
  required BigInt amountSats,
  BigInt? feeSats,
}) =>
    RustLib.instance.api.crateApiArkApiSend(
      address: address,
      amountSats: amountSats,
      feeSats: feeSats,
    );

/// Pay a BOLT11 Lightning invoice using Ark funds via Boltz submarine swap
Future<LnPaymentResult> payLnInvoice({required String invoice}) =>
    RustLib.instance.api.crateApiArkApiPayLnInvoice(invoice: invoice);

Future<void> settle() => RustLib.instance.api.crateApiArkApiSettle();

/// Get pending boarding UTXOs (on-chain funds at the boarding address that haven't been settled yet)
Future<List<BoardingUtxo>> getBoardingUtxos() =>
    RustLib.instance.api.crateApiArkApiGetBoardingUtxos();

/// Get the total pending balance in sats (on-chain funds waiting to be settled)
Future<BigInt> getPendingBalance() =>
    RustLib.instance.api.crateApiArkApiGetPendingBalance();

/// Settle only boarding UTXOs (on-chain funds) into the Ark protocol.
/// This method settles ONLY the confirmed boarding UTXOs without including
/// any existing VTXOs, avoiding the minExpiryGap rejection from the server.
/// Use this for completing on-chain boarding when you have existing Ark balance.
Future<void> settleBoarding() =>
    RustLib.instance.api.crateApiArkApiSettleBoarding();

/// Get the Nostr secret key (nsec) derived from the wallet mnemonic
/// Note: Nostr keys are network-independent, so we use Bitcoin mainnet for derivation
Future<String> nsec({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiNsec(dataDir: dataDir);

/// Get the Nostr public key (npub) derived from the wallet mnemonic
/// Note: Nostr keys are network-independent, so we use Bitcoin mainnet for derivation
///
/// This is the CANONICAL USER IDENTIFIER used for:
/// - PostHog analytics user identification
/// - Cross-service user correlation
/// - Any feature requiring a consistent user ID
///
/// Returns the public key in bech32 format (npub1...)
Future<String> npub({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiNpub(dataDir: dataDir);

/// Get the mnemonic words for backup (only available for HD wallets)
Future<String> getMnemonic({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiGetMnemonic(dataDir: dataDir);

Future<void> resetWallet({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiResetWallet(dataDir: dataDir);

/// Sign an Ark PSBT using the Ark SDK's key provider and signing functions.
///
/// This uses:
/// - The SDK's key provider to get the keypair (not manual derivation)
/// - ark_core::send::sign_ark_transaction for proper script-path signing
///
/// This matches exactly how Arkade wallet signs PSBTs - using the SDK's
/// identity.sign() equivalent functionality.
Future<String> signPsbtWithArkIdentity({required String psbtHex}) =>
    RustLib.instance.api
        .crateApiArkApiSignPsbtWithArkIdentity(psbtHex: psbtHex);

Future<Info> information() => RustLib.instance.api.crateApiArkApiInformation();

Future<PaymentReceived> waitForPayment(
        {String? arkAddress,
        String? boardingAddress,
        String? boltzSwapId,
        required BigInt timeoutSeconds}) =>
    RustLib.instance.api.crateApiArkApiWaitForPayment(
        arkAddress: arkAddress,
        boardingAddress: boardingAddress,
        boltzSwapId: boltzSwapId,
        timeoutSeconds: timeoutSeconds);

/// Estimate fee for on-chain send (collaborative redemption)
///
/// This estimates the fee for sending to a Bitcoin address.
/// The fee depends on the current network fee rate and the number of VTXOs
/// that need to be spent to cover the amount.
Future<FeeEstimate> estimateOnchainFee(
        {required String address, required BigInt amountSats}) =>
    RustLib.instance.api.crateApiArkApiEstimateOnchainFee(
        address: address, amountSats: amountSats);

/// Estimate fee for Arkade (off-chain) send
///
/// Ark-to-Ark transfers are essentially free since they happen off-chain.
/// Returns 0 fee.
Future<FeeEstimate> estimateArkadeFee(
        {required String address, required BigInt amountSats}) =>
    RustLib.instance.api.crateApiArkApiEstimateArkadeFee(
        address: address, amountSats: amountSats);

/// Estimate fee for Lightning payment
///
/// Fetches real-time fees from Boltz API including percentage fee and miner fees.
Future<FeeEstimate> estimateLightningFee({required BigInt amountSats}) =>
    RustLib.instance.api
        .crateApiArkApiEstimateLightningFee(amountSats: amountSats);

class Addresses {
  final String boarding;
  final String offchain;
  final String bip21;
  final BoltzSwap? lightning;

  const Addresses({
    required this.boarding,
    required this.offchain,
    required this.bip21,
    this.lightning,
  });

  @override
  int get hashCode =>
      boarding.hashCode ^
      offchain.hashCode ^
      bip21.hashCode ^
      lightning.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Addresses &&
          runtimeType == other.runtimeType &&
          boarding == other.boarding &&
          offchain == other.offchain &&
          bip21 == other.bip21 &&
          lightning == other.lightning;
}

class Balance {
  final OffchainBalance offchain;

  const Balance({
    required this.offchain,
  });

  @override
  int get hashCode => offchain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Balance &&
          runtimeType == other.runtimeType &&
          offchain == other.offchain;
}

/// Represents a pending boarding UTXO (on-chain funds waiting to be settled)
class BoardingUtxo {
  final String txid;
  final int vout;
  final BigInt amountSats;
  final bool isConfirmed;

  const BoardingUtxo({
    required this.txid,
    required this.vout,
    required this.amountSats,
    required this.isConfirmed,
  });

  @override
  int get hashCode =>
      txid.hashCode ^
      vout.hashCode ^
      amountSats.hashCode ^
      isConfirmed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BoardingUtxo &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          amountSats == other.amountSats &&
          isConfirmed == other.isConfirmed;
}

class BoltzSwap {
  final String swapId;
  final BigInt amountSats;
  final String invoice;

  const BoltzSwap({
    required this.swapId,
    required this.amountSats,
    required this.invoice,
  });

  @override
  int get hashCode => swapId.hashCode ^ amountSats.hashCode ^ invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BoltzSwap &&
          runtimeType == other.runtimeType &&
          swapId == other.swapId &&
          amountSats == other.amountSats &&
          invoice == other.invoice;
}

/// Fee estimation result for display in the UI
class FeeEstimate {
  /// Estimated fee in satoshis
  final BigInt feeSats;

  /// Fee rate used (sat/vB for on-chain, percentage for Lightning)
  final double feeRate;

  /// Number of VTXOs that would be used (for on-chain sends)
  final int numInputs;

  const FeeEstimate({
    required this.feeSats,
    required this.feeRate,
    required this.numInputs,
  });

  @override
  int get hashCode => feeSats.hashCode ^ feeRate.hashCode ^ numInputs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FeeEstimate &&
          runtimeType == other.runtimeType &&
          feeSats == other.feeSats &&
          feeRate == other.feeRate &&
          numInputs == other.numInputs;
}

class Info {
  final String serverPk;
  final String network;

  const Info({
    required this.serverPk,
    required this.network,
  });

  @override
  int get hashCode => serverPk.hashCode ^ network.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Info &&
          runtimeType == other.runtimeType &&
          serverPk == other.serverPk &&
          network == other.network;
}

/// Result of paying a Lightning invoice
class LnPaymentResult {
  final String swapId;
  final String txid;
  final BigInt amountSats;

  const LnPaymentResult({
    required this.swapId,
    required this.txid,
    required this.amountSats,
  });

  @override
  int get hashCode => swapId.hashCode ^ txid.hashCode ^ amountSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnPaymentResult &&
          runtimeType == other.runtimeType &&
          swapId == other.swapId &&
          txid == other.txid &&
          amountSats == other.amountSats;
}

class OffchainBalance {
  final BigInt pendingSats;
  final BigInt confirmedSats;
  final BigInt expiredSats;
  final BigInt recoverableSats;
  final BigInt totalSats;

  const OffchainBalance({
    required this.pendingSats,
    required this.confirmedSats,
    required this.expiredSats,
    required this.recoverableSats,
    required this.totalSats,
  });

  @override
  int get hashCode =>
      pendingSats.hashCode ^
      confirmedSats.hashCode ^
      expiredSats.hashCode ^
      recoverableSats.hashCode ^
      totalSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OffchainBalance &&
          runtimeType == other.runtimeType &&
          pendingSats == other.pendingSats &&
          confirmedSats == other.confirmedSats &&
          expiredSats == other.expiredSats &&
          recoverableSats == other.recoverableSats &&
          totalSats == other.totalSats;
}

class PaymentReceived {
  final String txid;
  final BigInt amountSats;

  const PaymentReceived({
    required this.txid,
    required this.amountSats,
  });

  @override
  int get hashCode => txid.hashCode ^ amountSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentReceived &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          amountSats == other.amountSats;
}

@freezed
sealed class Transaction with _$Transaction {
  const Transaction._();

  const factory Transaction.boarding({
    required String txid,
    required BigInt amountSats,
    PlatformInt64? confirmedAt,
  }) = Transaction_Boarding;
  const factory Transaction.round({
    required String txid,
    required PlatformInt64 amountSats,
    required PlatformInt64 createdAt,
  }) = Transaction_Round;
  const factory Transaction.redeem({
    required String txid,
    required PlatformInt64 amountSats,
    required bool isSettled,
    required PlatformInt64 createdAt,
  }) = Transaction_Redeem;

  /// On-chain send (collaborative redeem) - funds sent from Ark to on-chain address
  const factory Transaction.offboard({
    required String txid,
    required PlatformInt64 amountSats,
    PlatformInt64? confirmedAt,
  }) = Transaction_Offboard;
}
